<html> <title> SLATEC Keylist Index </title>
<h1> SLATEC Keylist Index </h1>
<ul>
<li> <a href=#15-POINT_GAUSS-KRONROD_RULES>15-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#21-POINT_GAUSS-KRONROD_RULES>21-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#25-POINT_CLENSHAW-CURTIS_INTEGRATION>25-POINT CLENSHAW-CURTIS INTEGRATION</a>
<li> <a href=#31-POINT_GAUSS-KRONROD_RULES>31-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#3J_COEFFICIENTS>3J COEFFICIENTS</a>
<li> <a href=#3J_SYMBOLS>3J SYMBOLS</a>
<li> <a href=#41-POINT_GAUSS-KRONROD_RULES>41-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#51-POINT_GAUSS-KRONROD_RULES>51-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#61-POINT_GAUSS-KRONROD_RULES>61-POINT GAUSS-KRONROD RULES</a>
<li> <a href=#6J_COEFFICIENTS>6J COEFFICIENTS</a>
<li> <a href=#6J_SYMBOLS>6J SYMBOLS</a>
<li> <a href=#ABORT_PROGRAM_EXECUTION>ABORT PROGRAM EXECUTION</a>
<li> <a href=#ABSOLUTE_VALUE>ABSOLUTE VALUE</a>
<li> <a href=#ABSOLUTE_VALUE_OF_THE_LOGARITHM_OF_THE_GAMMA_FUNCTION>ABSOLUTE VALUE OF THE LOGARITHM OF THE GAMMA FUNCTION</a>
<li> <a href=#ACOSH>ACOSH</a>
<li> <a href=#ADAMS_METHOD>ADAMS METHOD</a>
<li> <a href=#ADAMS-BASHFORTH_METHOD>ADAMS-BASHFORTH METHOD</a>
<li> <a href=#ADAPTIVE_QUADRATURE>ADAPTIVE QUADRATURE</a>
<li> <a href=#AIRY_FUNCTION>AIRY FUNCTION</a>
<li> <a href=#ALGEBRAIC-LOGARITHMIC_END_POINT_SINGULARITIES>ALGEBRAIC-LOGARITHMIC END POINT SINGULARITIES</a>
<li> <a href=#ALGEBRAICO-LOGARITHMIC>ALGEBRAICO-LOGARITHMIC</a>
<li> <a href=#ANALYSIS_OF_COVARIANCE>ANALYSIS OF COVARIANCE</a>
<li> <a href=#APPLICATION_OF_PERMUTATION_TO_DATA_VECTOR>APPLICATION OF PERMUTATION TO DATA VECTOR</a>
<li> <a href=#ARC_COSINE>ARC COSINE</a>
<li> <a href=#ARC_HYPERBOLIC_COSINE>ARC HYPERBOLIC COSINE</a>
<li> <a href=#ARC_HYPERBOLIC_SINE>ARC HYPERBOLIC SINE</a>
<li> <a href=#ARC_HYPERBOLIC_TANGENT>ARC HYPERBOLIC TANGENT</a>
<li> <a href=#ARC_SINE>ARC SINE</a>
<li> <a href=#ARC_TANGENT>ARC TANGENT</a>
<li> <a href=#ARGUMENT_OF_A_COMPLEX_NUMBER>ARGUMENT OF A COMPLEX NUMBER</a>
<li> <a href=#ASINH>ASINH</a>
<li> <a href=#ATANH>ATANH</a>
<li> <a href=#AUTOMATIC_INTEGRATOR>AUTOMATIC INTEGRATOR</a>
<li> <a href=#B-SPLINE>B-SPLINE</a>
<li> <a href=#B-SPLINES>B-SPLINES</a>
<li> <a href=#BACKWARD_DIFFERENTIATION_FORMULAS>BACKWARD DIFFERENTIATION FORMULAS</a>
<li> <a href=#BAIRY_FUNCTION>BAIRY FUNCTION</a>
<li> <a href=#BANDED>BANDED</a>
<li> <a href=#BANDED_MATRIX>BANDED MATRIX</a>
<li> <a href=#BASE_TEN_LOGARITHM>BASE TEN LOGARITHM</a>
<li> <a href=#BESSEL_FUNCTION>BESSEL FUNCTION</a>
<li> <a href=#BESSEL_FUNCTION_OF_ORDER_ONE_THIRD>BESSEL FUNCTION OF ORDER ONE THIRD</a>
<li> <a href=#BESSEL_FUNCTION_OF_ORDER_TWO_THIRDS>BESSEL FUNCTION OF ORDER TWO THIRDS</a>
<li> <a href=#BESSEL_FUNCTIONS_OF_COMPLEX_ARGUMENT>BESSEL FUNCTIONS OF COMPLEX ARGUMENT</a>
<li> <a href=#BESSEL_FUNCTIONS_OF_SECOND_KIND>BESSEL FUNCTIONS OF SECOND KIND</a>
<li> <a href=#BESSEL_FUNCTIONS_OF_THE_FIRST_KIND>BESSEL FUNCTIONS OF THE FIRST KIND</a>
<li> <a href=#BESSEL_FUNCTIONS_OF_THE_THIRD_KIND>BESSEL FUNCTIONS OF THE THIRD KIND</a>
<li> <a href=#BICKLEY_FUNCTIONS>BICKLEY FUNCTIONS</a>
<li> <a href=#BICONJUGATE_GRADIENT>BICONJUGATE GRADIENT</a>
<li> <a href=#BICONJUGATE_GRADIENT_SQUARED>BICONJUGATE GRADIENT SQUARED</a>
<li> <a href=#BINOMIAL_COEFFICIENTS>BINOMIAL COEFFICIENTS</a>
<li> <a href=#BISECTION>BISECTION</a>
<li> <a href=#BLAS>BLAS</a>
<li> <a href=#BOUNDS>BOUNDS</a>
<li> <a href=#BROWN'S_METHOD>BROWN'S METHOD</a>
<li> <a href=#CARTESIAN>CARTESIAN</a>
<li> <a href=#CAUCHY_PRINCIPAL_VALUE>CAUCHY PRINCIPAL VALUE</a>
<li> <a href=#CHARACTER_COMPARISON>CHARACTER COMPARISON</a>
<li> <a href=#CHEBYSHEV>CHEBYSHEV</a>
<li> <a href=#CHEBYSHEV_SERIES>CHEBYSHEV SERIES</a>
<li> <a href=#CHEBYSHEV_SERIES_EXPANSION>CHEBYSHEV SERIES EXPANSION</a>
<li> <a href=#CHOLESKY_DECOMPOSITION>CHOLESKY DECOMPOSITION</a>
<li> <a href=#CLEBSCH-GORDAN_COEFFICIENTS>CLEBSCH-GORDAN COEFFICIENTS</a>
<li> <a href=#CLENSHAW-CURTIS_METHOD>CLENSHAW-CURTIS METHOD</a>
<li> <a href=#COEFFICIENTS>COEFFICIENTS</a>
<li> <a href=#COMPLEMENTARY_ERROR_FUNCTION>COMPLEMENTARY ERROR FUNCTION</a>
<li> <a href=#COMPLEMENTARY_INCOMPLETE_GAMMA_FUNCTION>COMPLEMENTARY INCOMPLETE GAMMA FUNCTION</a>
<li> <a href=#COMPLETE_BETA_FUNCTION>COMPLETE BETA FUNCTION</a>
<li> <a href=#COMPLETE_ELLIPTIC_INTEGRAL>COMPLETE ELLIPTIC INTEGRAL</a>
<li> <a href=#COMPLETE_GAMMA_FUNCTION>COMPLETE GAMMA FUNCTION</a>
<li> <a href=#COMPLEX_HERMITIAN>COMPLEX HERMITIAN</a>
<li> <a href=#COMPLEX_LINEAR_EQUATIONS>COMPLEX LINEAR EQUATIONS</a>
<li> <a href=#COMPLEX_POLYNOMIAL>COMPLEX POLYNOMIAL</a>
<li> <a href=#COMPLEX_VALUED>COMPLEX VALUED</a>
<li> <a href=#COMPLEX_VECTORS>COMPLEX VECTORS</a>
<li> <a href=#CONDITION_NUMBER>CONDITION NUMBER</a>
<li> <a href=#CONSTRAINED_LEAST_SQUARES>CONSTRAINED LEAST SQUARES</a>
<li> <a href=#CONSTRAINTS>CONSTRAINTS</a>
<li> <a href=#CONVERGENCE_ACCELERATION>CONVERGENCE ACCELERATION</a>
<li> <a href=#CONVERSION>CONVERSION</a>
<li> <a href=#COPY>COPY</a>
<li> <a href=#CORRECTION_TERM>CORRECTION TERM</a>
<li> <a href=#COS_OR_SIN_IN_WEIGHT_FUNCTION>COS OR SIN IN WEIGHT FUNCTION</a>
<li> <a href=#COSINE>COSINE</a>
<li> <a href=#COSINE_FOURIER_TRANSFORM>COSINE FOURIER TRANSFORM</a>
<li> <a href=#COTANGENT>COTANGENT</a>
<li> <a href=#COVARIANCE_MATRIX>COVARIANCE MATRIX</a>
<li> <a href=#CUBE_ROOT>CUBE ROOT</a>
<li> <a href=#CUBIC_HERMITE_DIFFERENTIATION>CUBIC HERMITE DIFFERENTIATION</a>
<li> <a href=#CUBIC_HERMITE_EVALUATION>CUBIC HERMITE EVALUATION</a>
<li> <a href=#CUBIC_HERMITE_INTERPOLATION>CUBIC HERMITE INTERPOLATION</a>
<li> <a href=#CUBIC_POLYNOMIAL_EVALUATION>CUBIC POLYNOMIAL EVALUATION</a>
<li> <a href=#CUBIC_SPLINES>CUBIC SPLINES</a>
<li> <a href=#CURVE_FITTING>CURVE FITTING</a>
<li> <a href=#CYCLIC_REDUCTION>CYCLIC REDUCTION</a>
<li> <a href=#CYLINDRICAL>CYLINDRICAL</a>
<li> <a href=#DASSL>DASSL</a>
<li> <a href=#DATA_FITTING>DATA FITTING</a>
<li> <a href=#DAWSON'S_FUNCTION>DAWSON'S FUNCTION</a>
<li> <a href=#DEGREES>DEGREES</a>
<li> <a href=#DEPAC>DEPAC</a>
<li> <a href=#DERIVATIVES_OF_THE_GAMMA_FUNCTION>DERIVATIVES OF THE GAMMA FUNCTION</a>
<li> <a href=#DETERMINANT>DETERMINANT</a>
<li> <a href=#DIAGNOSTICS>DIAGNOSTICS</a>
<li> <a href=#DIAGONAL>DIAGONAL</a>
<li> <a href=#DIFFERENTIAL/ALGEBRAIC>DIFFERENTIAL/ALGEBRAIC</a>
<li> <a href=#DIFFERENTIATION_OF_B-SPLINE>DIFFERENTIATION OF B-SPLINE</a>
<li> <a href=#DIFFERENTIATION_OF_SPLINES>DIFFERENTIATION OF SPLINES</a>
<li> <a href=#DIGAMMA_FUNCTION>DIGAMMA FUNCTION</a>
<li> <a href=#DISCLAIMER>DISCLAIMER</a>
<li> <a href=#DOCUMENTATION>DOCUMENTATION</a>
<li> <a href=#DOT_PRODUCT>DOT PRODUCT</a>
<li> <a href=#DOUBLE_PRECISION>DOUBLE PRECISION</a>
<li> <a href=#DOWNDATE>DOWNDATE</a>
<li> <a href=#DUPLICATION_THEOREM>DUPLICATION THEOREM</a>
<li> <a href=#E1_FUNCTION>E1 FUNCTION</a>
<li> <a href=#EASY-TO-USE>EASY-TO-USE</a>
<li> <a href=#EI_FUNCTION>EI FUNCTION</a>
<li> <a href=#EIGENVALUES>EIGENVALUES</a>
<li> <a href=#EIGENVALUES_OF_A_REAL_SYMMETRIC_MATRIX>EIGENVALUES OF A REAL SYMMETRIC MATRIX</a>
<li> <a href=#EIGENVALUES_OF_A_SYMMETRIC_TRIDIAGONAL_MATRIX>EIGENVALUES OF A SYMMETRIC TRIDIAGONAL MATRIX</a>
<li> <a href=#EIGENVECTORS>EIGENVECTORS</a>
<li> <a href=#EIGENVECTORS_OF_A_REAL_SYMMETRIC_MATRIX>EIGENVECTORS OF A REAL SYMMETRIC MATRIX</a>
<li> <a href=#EISPACK>EISPACK</a>
<li> <a href=#ELEMENTARY_FUNCTIONS>ELEMENTARY FUNCTIONS</a>
<li> <a href=#ELLIPTIC>ELLIPTIC</a>
<li> <a href=#ELLIPTIC_INTEGRAL>ELLIPTIC INTEGRAL</a>
<li> <a href=#ELLIPTIC_PDE>ELLIPTIC PDE</a>
<li> <a href=#END_POINT_SINGULARITIES>END POINT SINGULARITIES</a>
<li> <a href=#EPSILON_ALGORITHM>EPSILON ALGORITHM</a>
<li> <a href=#EQUALITY_CONSTRAINTS>EQUALITY CONSTRAINTS</a>
<li> <a href=#ERF>ERF</a>
<li> <a href=#ERFC>ERFC</a>
<li> <a href=#ERROR>ERROR</a>
<li> <a href=#ERROR_CHECKING>ERROR CHECKING</a>
<li> <a href=#ERROR_FUNCTION>ERROR FUNCTION</a>
<li> <a href=#ERROR_MESSAGE>ERROR MESSAGE</a>
<li> <a href=#ERROR_MESSAGES>ERROR MESSAGES</a>
<li> <a href=#ERROR_NUMBER>ERROR NUMBER</a>
<li> <a href=#EUCLIDEAN_LENGTH>EUCLIDEAN LENGTH</a>
<li> <a href=#EUCLIDEAN_NORM>EUCLIDEAN NORM</a>
<li> <a href=#EVALUATION_OF_B-SPLINE>EVALUATION OF B-SPLINE</a>
<li> <a href=#EXCHANGE>EXCHANGE</a>
<li> <a href=#EXPONENTIAL>EXPONENTIAL</a>
<li> <a href=#EXPONENTIAL_INTEGRAL>EXPONENTIAL INTEGRAL</a>
<li> <a href=#EXPONENTIALLY_SCALED>EXPONENTIALLY SCALED</a>
<li> <a href=#EXPONENTIALLY_SCALED_AIRY_FUNCTION>EXPONENTIALLY SCALED AIRY FUNCTION</a>
<li> <a href=#EXTENDED-RANGE_DOUBLE-PRECISION_ARITHMETIC>EXTENDED-RANGE DOUBLE-PRECISION ARITHMETIC</a>
<li> <a href=#EXTENDED-RANGE_SINGLE-PRECISION_ARITHMETIC>EXTENDED-RANGE SINGLE-PRECISION ARITHMETIC</a>
<li> <a href=#EXTRAPOLATION>EXTRAPOLATION</a>
<li> <a href=#FACTORIAL>FACTORIAL</a>
<li> <a href=#FAST_FOURIER_TRANSFORM>FAST FOURIER TRANSFORM</a>
<li> <a href=#FFT>FFT</a>
<li> <a href=#FFTPACK>FFTPACK</a>
<li> <a href=#FIRST_KIND>FIRST KIND</a>
<li> <a href=#FIRST_ORDER>FIRST ORDER</a>
<li> <a href=#FISHPACK>FISHPACK</a>
<li> <a href=#FNLIB>FNLIB</a>
<li> <a href=#FOURIER_INTEGRALS>FOURIER INTEGRALS</a>
<li> <a href=#FOURIER_TRANSFORM>FOURIER TRANSFORM</a>
<li> <a href=#FRACTIONAL_ORDER>FRACTIONAL ORDER</a>
<li> <a href=#GAMMA_FUNCTION>GAMMA FUNCTION</a>
<li> <a href=#GAUSS_QUADRATURE>GAUSS QUADRATURE</a>
<li> <a href=#GAUSS-KRONROD_RULES>GAUSS-KRONROD RULES</a>
<li> <a href=#GAUSS-KRONROD(PATTERSON)_RULES>GAUSS-KRONROD(PATTERSON) RULES</a>
<li> <a href=#GAUSSIAN>GAUSSIAN</a>
<li> <a href=#GEAR'S_METHOD>GEAR'S METHOD</a>
<li> <a href=#GENERAL_MATRIX>GENERAL MATRIX</a>
<li> <a href=#GENERAL_SYSTEM_OF_LINEAR_EQUATIONS>GENERAL SYSTEM OF LINEAR EQUATIONS</a>
<li> <a href=#GENERAL-PURPOSE>GENERAL-PURPOSE</a>
<li> <a href=#GENERALIZED_MINIMUM_RESIDUAL>GENERALIZED MINIMUM RESIDUAL</a>
<li> <a href=#GIVENS_ROTATION>GIVENS ROTATION</a>
<li> <a href=#GIVENS_TRANSFORMATION>GIVENS TRANSFORMATION</a>
<li> <a href=#GLOBALLY_ADAPTIVE>GLOBALLY ADAPTIVE</a>
<li> <a href=#GMRES>GMRES</a>
<li> <a href=#GRADIENTS>GRADIENTS</a>
<li> <a href=#GUIDELINES_FOR_SELECTION>GUIDELINES FOR SELECTION</a>
<li> <a href=#H_BESSEL_FUNCTIONS>H BESSEL FUNCTIONS</a>
<li> <a href=#HANKEL_FUNCTIONS>HANKEL FUNCTIONS</a>
<li> <a href=#HELMHOLTZ>HELMHOLTZ</a>
<li> <a href=#HERMITE_INTERPOLATION>HERMITE INTERPOLATION</a>
<li> <a href=#HERMITIAN>HERMITIAN</a>
<li> <a href=#HYPERBOLIC_BESSEL_FUNCTION>HYPERBOLIC BESSEL FUNCTION</a>
<li> <a href=#HYPERBOLIC_COSINE>HYPERBOLIC COSINE</a>
<li> <a href=#HYPERBOLIC_SINE>HYPERBOLIC SINE</a>
<li> <a href=#HYPERBOLIC_TANGENT>HYPERBOLIC TANGENT</a>
<li> <a href=#I_BESSEL_FUNCTION>I BESSEL FUNCTION</a>
<li> <a href=#I_BESSEL_FUNCTIONS>I BESSEL FUNCTIONS</a>
<li> <a href=#IMPLICIT_DIFFERENTIAL_SYSTEMS>IMPLICIT DIFFERENTIAL SYSTEMS</a>
<li> <a href=#INCOMPLETE_BETA_FUNCTION>INCOMPLETE BETA FUNCTION</a>
<li> <a href=#INCOMPLETE_CHOLESKY>INCOMPLETE CHOLESKY</a>
<li> <a href=#INCOMPLETE_CHOLESKY_FACTORIZATION>INCOMPLETE CHOLESKY FACTORIZATION</a>
<li> <a href=#INCOMPLETE_ELLIPTIC_INTEGRAL>INCOMPLETE ELLIPTIC INTEGRAL</a>
<li> <a href=#INCOMPLETE_FACTORIZATION>INCOMPLETE FACTORIZATION</a>
<li> <a href=#INCOMPLETE_GAMMA_FUNCTION>INCOMPLETE GAMMA FUNCTION</a>
<li> <a href=#INCOMPLETE_LU_FACTORIZATION>INCOMPLETE LU FACTORIZATION</a>
<li> <a href=#INEQUALITY>INEQUALITY</a>
<li> <a href=#INEQUALITY_CONSTRAINTS>INEQUALITY CONSTRAINTS</a>
<li> <a href=#INFINITE_INTERVALS>INFINITE INTERVALS</a>
<li> <a href=#INITIAL_VALUE_PROBLEMS>INITIAL VALUE PROBLEMS</a>
<li> <a href=#INITIALIZE>INITIALIZE</a>
<li> <a href=#INNER_PRODUCT>INNER PRODUCT</a>
<li> <a href=#INTEGRAL_OF_B-SPLINE>INTEGRAL OF B-SPLINE</a>
<li> <a href=#INTEGRAL_OF_B-SPLINES>INTEGRAL OF B-SPLINES</a>
<li> <a href=#INTEGRAL_OF_THE_FIRST_KIND>INTEGRAL OF THE FIRST KIND</a>
<li> <a href=#INTEGRAL_OF_THE_SECOND_KIND>INTEGRAL OF THE SECOND KIND</a>
<li> <a href=#INTEGRAL_OF_THE_THIRD_KIND>INTEGRAL OF THE THIRD KIND</a>
<li> <a href=#INTEGRALS_OF_BESSEL_FUNCTIONS>INTEGRALS OF BESSEL FUNCTIONS</a>
<li> <a href=#INTEGRAND_EXAMINATOR>INTEGRAND EXAMINATOR</a>
<li> <a href=#INTEGRAND_WITH_OSCILLATORY_COS_OR_SIN_FACTOR>INTEGRAND WITH OSCILLATORY COS OR SIN FACTOR</a>
<li> <a href=#INTEGRATION>INTEGRATION</a>
<li> <a href=#INTEGRATION_BETWEEN_ZEROS>INTEGRATION BETWEEN ZEROS</a>
<li> <a href=#INTEGRATION_RULES_FOR_FUNCTIONS_WITH_COS_OR_SIN_FACTOR>INTEGRATION RULES FOR FUNCTIONS WITH COS OR SIN FACTOR</a>
<li> <a href=#INTERCHANGE>INTERCHANGE</a>
<li> <a href=#INTERPOLATION>INTERPOLATION</a>
<li> <a href=#INVERSE>INVERSE</a>
<li> <a href=#INVERSE_COSINE_FOURIER_TRANSFORM>INVERSE COSINE FOURIER TRANSFORM</a>
<li> <a href=#INVERSE_HYPERBOLIC_COSINE>INVERSE HYPERBOLIC COSINE</a>
<li> <a href=#INVERSE_HYPERBOLIC_SINE>INVERSE HYPERBOLIC SINE</a>
<li> <a href=#INVERSE_HYPERBOLIC_TANGENT>INVERSE HYPERBOLIC TANGENT</a>
<li> <a href=#ITERATIVE_IMPROVEMENT>ITERATIVE IMPROVEMENT</a>
<li> <a href=#ITERATIVE_INCOMPLETE_LU_PRECONDITION>ITERATIVE INCOMPLETE LU PRECONDITION</a>
<li> <a href=#ITERATIVE_PRECONDITION>ITERATIVE PRECONDITION</a>
<li> <a href=#J_BESSEL_FUNCTION>J BESSEL FUNCTION</a>
<li> <a href=#J_BESSEL_FUNCTIONS>J BESSEL FUNCTIONS</a>
<li> <a href=#JACOBIAN>JACOBIAN</a>
<li> <a href=#K_BESSEL_FUNCTION>K BESSEL FUNCTION</a>
<li> <a href=#K_BESSEL_FUNCTIONS>K BESSEL FUNCTIONS</a>
<li> <a href=#K-ZERO_BESSEL_FUNCTION>K-ZERO BESSEL FUNCTION</a>
<li> <a href=#L2>L2</a>
<li> <a href=#LARGE_X>LARGE X</a>
<li> <a href=#LEAST_SQUARES>LEAST SQUARES</a>
<li> <a href=#LEGENDRE_FUNCTIONS>LEGENDRE FUNCTIONS</a>
<li> <a href=#LEVEL_2_BLAS>LEVEL 2 BLAS</a>
<li> <a href=#LEVEL_3_BLAS>LEVEL 3 BLAS</a>
<li> <a href=#LEVENBERG-MARQUARDT>LEVENBERG-MARQUARDT</a>
<li> <a href=#LIMITS>LIMITS</a>
<li> <a href=#LINEAR>LINEAR</a>
<li> <a href=#LINEAR_ALGEBRA>LINEAR ALGEBRA</a>
<li> <a href=#LINEAR_CONSTRAINTS>LINEAR CONSTRAINTS</a>
<li> <a href=#LINEAR_EQUATIONS>LINEAR EQUATIONS</a>
<li> <a href=#LINEAR_LEAST_SQUARES>LINEAR LEAST SQUARES</a>
<li> <a href=#LINEAR_OPTIMIZATION>LINEAR OPTIMIZATION</a>
<li> <a href=#LINEAR_PROGRAMMING>LINEAR PROGRAMMING</a>
<li> <a href=#LINEAR_SYSTEM>LINEAR SYSTEM</a>
<li> <a href=#LINEAR_SYSTEM_SOLVE>LINEAR SYSTEM SOLVE</a>
<li> <a href=#LINPACK>LINPACK</a>
<li> <a href=#LOG_GAMMA>LOG GAMMA</a>
<li> <a href=#LOGARITHM>LOGARITHM</a>
<li> <a href=#LOGARITHM_OF_GAMMA_FUNCTION>LOGARITHM OF GAMMA FUNCTION</a>
<li> <a href=#LOGARITHM_OF_THE_COMPLETE_BETA_FUNCTION>LOGARITHM OF THE COMPLETE BETA FUNCTION</a>
<li> <a href=#LOGARITHMIC_CONFLUENT_HYPERGEOMETRIC_FUNCTION>LOGARITHMIC CONFLUENT HYPERGEOMETRIC FUNCTION</a>
<li> <a href=#LOGARITHMIC_INTEGRAL>LOGARITHMIC INTEGRAL</a>
<li> <a href=#LOWER_TRIANGLE>LOWER TRIANGLE</a>
<li> <a href=#LP>LP</a>
<li> <a href=#LQ_FACTORIZATION>LQ FACTORIZATION</a>
<li> <a href=#LR_METHOD>LR METHOD</a>
<li> <a href=#MACHINE_CONSTANTS>MACHINE CONSTANTS</a>
<li> <a href=#MATRIX>MATRIX</a>
<li> <a href=#MATRIX_FACTORIZATION>MATRIX FACTORIZATION</a>
<li> <a href=#MATRIX_READ>MATRIX READ</a>
<li> <a href=#MATRIX_TRANSPOSE_VECTOR_MULTIPLY>MATRIX TRANSPOSE VECTOR MULTIPLY</a>
<li> <a href=#MATRIX_VECTOR_MULTIPLY>MATRIX VECTOR MULTIPLY</a>
<li> <a href=#MAXIMUM_COMPONENT>MAXIMUM COMPONENT</a>
<li> <a href=#MINPACK>MINPACK</a>
<li> <a href=#MODIFIED_BESSEL_FUNCTION>MODIFIED BESSEL FUNCTION</a>
<li> <a href=#MODIFIED_BESSEL_FUNCTIONS>MODIFIED BESSEL FUNCTIONS</a>
<li> <a href=#MODIFIED_CHEBYSHEV_MOMENTS>MODIFIED CHEBYSHEV MOMENTS</a>
<li> <a href=#MODIFIED_GIVENS_ROTATION>MODIFIED GIVENS ROTATION</a>
<li> <a href=#MODULUS>MODULUS</a>
<li> <a href=#MONOTONE_INTERPOLATION>MONOTONE INTERPOLATION</a>
<li> <a href=#NEWTON'S_METHOD>NEWTON'S METHOD</a>
<li> <a href=#NEWTON-COTES>NEWTON-COTES</a>
<li> <a href=#NON-SYMMETRIC_LINEAR_SYSTEM>NON-SYMMETRIC LINEAR SYSTEM</a>
<li> <a href=#NON-SYMMETRIC_LINEAR_SYSTEM_SOLVE>NON-SYMMETRIC LINEAR SYSTEM SOLVE</a>
<li> <a href=#NONADAPTIVE>NONADAPTIVE</a>
<li> <a href=#NONLINEAR>NONLINEAR</a>
<li> <a href=#NONLINEAR_DATA_FITTING>NONLINEAR DATA FITTING</a>
<li> <a href=#NONLINEAR_EQUATIONS>NONLINEAR EQUATIONS</a>
<li> <a href=#NONLINEAR_LEAST_SQUARES>NONLINEAR LEAST SQUARES</a>
<li> <a href=#NONLINEAR_SQUARE_SYSTEM>NONLINEAR SQUARE SYSTEM</a>
<li> <a href=#NONNEGATIVITY_CONSTRAINTS>NONNEGATIVITY CONSTRAINTS</a>
<li> <a href=#NONSYMMETRIC>NONSYMMETRIC</a>
<li> <a href=#NORMAL>NORMAL</a>
<li> <a href=#NORMAL_EQUATIONS>NORMAL EQUATIONS</a>
<li> <a href=#NORMAL_EQUATIONS.>NORMAL EQUATIONS.</a>
<li> <a href=#NUMBER_SORTING>NUMBER SORTING</a>
<li> <a href=#NUMERICAL_INTEGRATION>NUMERICAL INTEGRATION</a>
<li> <a href=#ODE>ODE</a>
<li> <a href=#ORDER_ONE>ORDER ONE</a>
<li> <a href=#ORDER_ZERO>ORDER ZERO</a>
<li> <a href=#ORDINARY_DIFFERENTIAL_EQUATIONS>ORDINARY DIFFERENTIAL EQUATIONS</a>
<li> <a href=#ORTHOGONAL_POLYNOMIAL>ORTHOGONAL POLYNOMIAL</a>
<li> <a href=#ORTHOGONAL_SERIES>ORTHOGONAL SERIES</a>
<li> <a href=#ORTHOGONAL_TRIANGULAR>ORTHOGONAL TRIANGULAR</a>
<li> <a href=#ORTHOMIN>ORTHOMIN</a>
<li> <a href=#ORTHONORMALIZATION>ORTHONORMALIZATION</a>
<li> <a href=#PACK>PACK</a>
<li> <a href=#PACKED>PACKED</a>
<li> <a href=#PASSIVE_SORTING>PASSIVE SORTING</a>
<li> <a href=#PCHIP>PCHIP</a>
<li> <a href=#PDE>PDE</a>
<li> <a href=#PERMUTATION>PERMUTATION</a>
<li> <a href=#PERRON'S_CONTINUED_FRACTION>PERRON'S CONTINUED FRACTION</a>
<li> <a href=#PHASE>PHASE</a>
<li> <a href=#PIECEWISE_CUBIC_EVALUATION>PIECEWISE CUBIC EVALUATION</a>
<li> <a href=#PIECEWISE_CUBIC_INTERPOLATION>PIECEWISE CUBIC INTERPOLATION</a>
<li> <a href=#PIECEWISE_POLYNOMIAL>PIECEWISE POLYNOMIAL</a>
<li> <a href=#PLANE_ROTATION>PLANE ROTATION</a>
<li> <a href=#POCHHAMMER>POCHHAMMER</a>
<li> <a href=#POISSON>POISSON</a>
<li> <a href=#POLAR>POLAR</a>
<li> <a href=#POLAR_ANGEL>POLAR ANGEL</a>
<li> <a href=#POLYGAMMA_FUNCTION>POLYGAMMA FUNCTION</a>
<li> <a href=#POLYNOMIAL>POLYNOMIAL</a>
<li> <a href=#POLYNOMIAL_APPROXIMATION>POLYNOMIAL APPROXIMATION</a>
<li> <a href=#POLYNOMIAL_EVALUATION>POLYNOMIAL EVALUATION</a>
<li> <a href=#POLYNOMIAL_FIT>POLYNOMIAL FIT</a>
<li> <a href=#POLYNOMIAL_INTERPOLATION>POLYNOMIAL INTERPOLATION</a>
<li> <a href=#POLYNOMIAL_ROOTS>POLYNOMIAL ROOTS</a>
<li> <a href=#POLYNOMIAL_ZEROS>POLYNOMIAL ZEROS</a>
<li> <a href=#POSITIVE_DEFINITE>POSITIVE DEFINITE</a>
<li> <a href=#POWELL_HYBRID_METHOD>POWELL HYBRID METHOD</a>
<li> <a href=#PRECONDITIONED_CONJUGATE_GRADIENT>PRECONDITIONED CONJUGATE GRADIENT</a>
<li> <a href=#PREDICTOR-CORRECTOR>PREDICTOR-CORRECTOR</a>
<li> <a href=#PRINTING>PRINTING</a>
<li> <a href=#PSI_FUNCTION>PSI FUNCTION</a>
<li> <a href=#QL_METHOD>QL METHOD</a>
<li> <a href=#QR_DECOMPOSITION>QR DECOMPOSITION</a>
<li> <a href=#QR_FACTORIZATION>QR FACTORIZATION</a>
<li> <a href=#QUADPACK>QUADPACK</a>
<li> <a href=#QUADRANT>QUADRANT</a>
<li> <a href=#QUADRATIC_PROGRAMMING>QUADRATIC PROGRAMMING</a>
<li> <a href=#QUADRATURE>QUADRATURE</a>
<li> <a href=#RACAH_COEFFICIENTS>RACAH COEFFICIENTS</a>
<li> <a href=#RANDOM_NUMBER>RANDOM NUMBER</a>
<li> <a href=#REAL_ROOTS>REAL ROOTS</a>
<li> <a href=#REARRANGEMENT>REARRANGEMENT</a>
<li> <a href=#RECALL>RECALL</a>
<li> <a href=#RECIPROCAL_GAMMA_FUNCTION>RECIPROCAL GAMMA FUNCTION</a>
<li> <a href=#RELATIVE_ADDRESS_DETERMINATION_FUNCTION>RELATIVE ADDRESS DETERMINATION FUNCTION</a>
<li> <a href=#RKF>RKF</a>
<li> <a href=#ROOTS>ROOTS</a>
<li> <a href=#RUNGE-KUTTA-FEHLBERG_METHODS>RUNGE-KUTTA-FEHLBERG METHODS</a>
<li> <a href=#SAVE>SAVE</a>
<li> <a href=#SCALE>SCALE</a>
<li> <a href=#SDRIVE>SDRIVE</a>
<li> <a href=#SECOND_KIND>SECOND KIND</a>
<li> <a href=#SECOND_ORDER>SECOND ORDER</a>
<li> <a href=#SEPARABLE>SEPARABLE</a>
<li> <a href=#SEQUENCE_OF_BESSEL_FUNCTIONS>SEQUENCE OF BESSEL FUNCTIONS</a>
<li> <a href=#SEQUENTIAL_SORTING>SEQUENTIAL SORTING</a>
<li> <a href=#SHAPE-PRESERVING_INTERPOLATION>SHAPE-PRESERVING INTERPOLATION</a>
<li> <a href=#SHOOTING>SHOOTING</a>
<li> <a href=#SINE>SINE</a>
<li> <a href=#SINGLE_PRECISION>SINGLE PRECISION</a>
<li> <a href=#SINGLETON_QUICKSORT>SINGLETON QUICKSORT</a>
<li> <a href=#SINGULAR_VALUE_DECOMPOSITION>SINGULAR VALUE DECOMPOSITION</a>
<li> <a href=#SINGULARITIES_AT_USER_SPECIFIED_POINTS>SINGULARITIES AT USER SPECIFIED POINTS</a>
<li> <a href=#SLAP>SLAP</a>
<li> <a href=#SLAP_SPARSE>SLAP SPARSE</a>
<li> <a href=#SLATEC>SLATEC</a>
<li> <a href=#SMALL_X>SMALL X</a>
<li> <a href=#SMOOTH_INTEGRAND>SMOOTH INTEGRAND</a>
<li> <a href=#SMOOTH_INTERPOLANT>SMOOTH INTERPOLANT</a>
<li> <a href=#SOLUTIONS>SOLUTIONS</a>
<li> <a href=#SOLVE>SOLVE</a>
<li> <a href=#SORT>SORT</a>
<li> <a href=#SORTING>SORTING</a>
<li> <a href=#SPARSE>SPARSE</a>
<li> <a href=#SPARSE_CONSTRAINTS>SPARSE CONSTRAINTS</a>
<li> <a href=#SPARSE_ITERATIVE_METHODS>SPARSE ITERATIVE METHODS</a>
<li> <a href=#SPECIAL_FUNCTIONS>SPECIAL FUNCTIONS</a>
<li> <a href=#SPECIAL-PURPOSE>SPECIAL-PURPOSE</a>
<li> <a href=#SPECIAL-PURPOSE_INTEGRAL>SPECIAL-PURPOSE INTEGRAL</a>
<li> <a href=#SPENCE'S_INTEGRAL>SPENCE'S INTEGRAL</a>
<li> <a href=#SPHERICAL>SPHERICAL</a>
<li> <a href=#SPLINE_INTERPOLATION>SPLINE INTERPOLATION</a>
<li> <a href=#SPLINES>SPLINES</a>
<li> <a href=#STIFF>STIFF</a>
<li> <a href=#STOP_TEST>STOP TEST</a>
<li> <a href=#STRING_SORTING>STRING SORTING</a>
<li> <a href=#SUM_OF_MAGNITUDES_OF_A_VECTOR>SUM OF MAGNITUDES OF A VECTOR</a>
<li> <a href=#SURVEY_OF_INTEGRATORS>SURVEY OF INTEGRATORS</a>
<li> <a href=#SYMMETRIC>SYMMETRIC</a>
<li> <a href=#SYMMETRIC_LINEAR_SYSTEM>SYMMETRIC LINEAR SYSTEM</a>
<li> <a href=#SYMMETRIC_LINEAR_SYSTEM_SOLVE>SYMMETRIC LINEAR SYSTEM SOLVE</a>
<li> <a href=#TABULATED_DATA>TABULATED DATA</a>
<li> <a href=#TANGENT>TANGENT</a>
<li> <a href=#TAYLOR_SERIES>TAYLOR SERIES</a>
<li> <a href=#THIRD_KIND>THIRD KIND</a>
<li> <a href=#TRANSFORMATION>TRANSFORMATION</a>
<li> <a href=#TRIAD>TRIAD</a>
<li> <a href=#TRIANGULAR>TRIANGULAR</a>
<li> <a href=#TRIANGULAR_LINEAR_SYSTEM>TRIANGULAR LINEAR SYSTEM</a>
<li> <a href=#TRIANGULAR_MATRIX>TRIANGULAR MATRIX</a>
<li> <a href=#TRICOMI>TRICOMI</a>
<li> <a href=#TRIDIAGONAL>TRIDIAGONAL</a>
<li> <a href=#TRIDIAGONAL_LINEAR_SYSTEM>TRIDIAGONAL LINEAR SYSTEM</a>
<li> <a href=#TRIGONOMETRIC>TRIGONOMETRIC</a>
<li> <a href=#TWO-POINT_BOUNDARY_VALUE_PROBLEM>TWO-POINT BOUNDARY VALUE PROBLEM</a>
<li> <a href=#UNDERDETERMINED_LINEAR_SYSTEM>UNDERDETERMINED LINEAR SYSTEM</a>
<li> <a href=#UNDERDETERMINED_LINEAR_SYSTEMS>UNDERDETERMINED LINEAR SYSTEMS</a>
<li> <a href=#UNIFORM>UNIFORM</a>
<li> <a href=#UNITARY>UNITARY</a>
<li> <a href=#UNPACK>UNPACK</a>
<li> <a href=#UPDATE>UPDATE</a>
<li> <a href=#UTILITY_ROUTINE>UTILITY ROUTINE</a>
<li> <a href=#VECTOR>VECTOR</a>
<li> <a href=#VECTOR_ADDITION_COEFFICIENTS>VECTOR ADDITION COEFFICIENTS</a>
<li> <a href=#VERSION>VERSION</a>
<li> <a href=#WEBER'S_FUNCTION>WEBER'S FUNCTION</a>
<li> <a href=#WEIGHT_FUNCTION>WEIGHT FUNCTION</a>
<li> <a href=#WEIGHTED_LEAST_SQUARES>WEIGHTED LEAST SQUARES</a>
<li> <a href=#WIGNER_COEFFICIENTS>WIGNER COEFFICIENTS</a>
<li> <a href=#WORKSPACE_CHECKING>WORKSPACE CHECKING</a>
<li> <a href=#XERMSG>XERMSG</a>
<li> <a href=#XERROR>XERROR</a>
<li> <a href=#Y_BESSEL_FUNCTION>Y BESSEL FUNCTION</a>
<li> <a href=#Y_BESSEL_FUNCTIONS>Y BESSEL FUNCTIONS</a>
<li> <a href=#ZEROS>ZEROS</a>
<h3> <a name="15-POINT_GAUSS-KRONROD_RULES"> 15-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk15.f.html> dqk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk15i.f.html> dqk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=dqk15w.f.html> dqk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
<li><a href=qk15.f.html> qk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=qk15i.f.html> qk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=qk15w.f.html> qk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
</ul>
<h3> <a name="21-POINT_GAUSS-KRONROD_RULES"> 21-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk21.f.html> dqk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk21.f.html> qk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
</ul>
<h3> <a name="25-POINT_CLENSHAW-CURTIS_INTEGRATION"> 25-POINT CLENSHAW-CURTIS INTEGRATION </a> </h3>
<ul>
<li><a href=dqc25c.f.html> dqc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=dqc25s.f.html> dqc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
<li><a href=qc25c.f.html> qc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=qc25s.f.html> qc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
</ul>
<h3> <a name="31-POINT_GAUSS-KRONROD_RULES"> 31-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk31.f.html> dqk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk31.f.html> qk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
</ul>
<h3> <a name="3J_COEFFICIENTS"> 3J COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="3J_SYMBOLS"> 3J SYMBOLS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="41-POINT_GAUSS-KRONROD_RULES"> 41-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk41.f.html> dqk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk41.f.html> qk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
</ul>
<h3> <a name="51-POINT_GAUSS-KRONROD_RULES"> 51-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk51.f.html> dqk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk51.f.html> qk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
</ul>
<h3> <a name="61-POINT_GAUSS-KRONROD_RULES"> 61-POINT GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqk61.f.html> dqk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk61.f.html> qk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
</ul>
<h3> <a name="6J_COEFFICIENTS"> 6J COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="6J_SYMBOLS"> 6J SYMBOLS </a> </h3>
<ul>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="ABORT_PROGRAM_EXECUTION"> ABORT PROGRAM EXECUTION </a> </h3>
<ul>
<li><a href=xerhlt.f.html> xerhlt </a>
<pre>
Abort program execution and print error message.
</pre>
</ul>
<h3> <a name="ABSOLUTE_VALUE"> ABSOLUTE VALUE </a> </h3>
<ul>
<li><a href=alngam.f.html> alngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=clngam.f.html> clngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dlngam.f.html> dlngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
</ul>
<h3> <a name="ABSOLUTE_VALUE_OF_THE_LOGARITHM_OF_THE_GAMMA_FUNCTION"> ABSOLUTE VALUE OF THE LOGARITHM OF THE GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=algams.f.html> algams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dlgams.f.html> dlgams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
</ul>
<h3> <a name="ACOSH"> ACOSH </a> </h3>
<ul>
<li><a href=acosh.f.html> acosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=cacosh.f.html> cacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=dacosh.f.html> dacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
</ul>
<h3> <a name="ADAMS_METHOD"> ADAMS METHOD </a> </h3>
<ul>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="ADAMS-BASHFORTH_METHOD"> ADAMS-BASHFORTH METHOD </a> </h3>
<ul>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
</ul>
<h3> <a name="ADAPTIVE_QUADRATURE"> ADAPTIVE QUADRATURE </a> </h3>
<ul>
<li><a href=dgaus8.f.html> dgaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=dqnc79.f.html> dqnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
<li><a href=gaus8.f.html> gaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=qnc79.f.html> qnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
</ul>
<h3> <a name="AIRY_FUNCTION"> AIRY FUNCTION </a> </h3>
<ul>
<li><a href=ai.f.html> ai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=cairy.f.html> cairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=cbiry.f.html> cbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
<li><a href=d9aimp.f.html> d9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=dai.f.html> dai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=r9aimp.f.html> r9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=zairy.f.html> zairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=zbiry.f.html> zbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
</ul>
<h3> <a name="ALGEBRAIC-LOGARITHMIC_END_POINT_SINGULARITIES"> ALGEBRAIC-LOGARITHMIC END POINT SINGULARITIES </a> </h3>
<ul>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="ALGEBRAICO-LOGARITHMIC"> ALGEBRAICO-LOGARITHMIC </a> </h3>
<ul>
<li><a href=dqwgts.f.html> dqwgts </a>
<pre>
This function subprogram is used together with the
routine DQAWS and defines the WEIGHT function.
</pre>
<li><a href=qwgts.f.html> qwgts </a>
<pre>
This function subprogram is used together with the
routine QAWS and defines the WEIGHT function.
</pre>
</ul>
<h3> <a name="ANALYSIS_OF_COVARIANCE"> ANALYSIS OF COVARIANCE </a> </h3>
<ul>
<li><a href=cv.f.html> cv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram FC.
</pre>
<li><a href=dcv.f.html> dcv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram DFC.
</pre>
</ul>
<h3> <a name="APPLICATION_OF_PERMUTATION_TO_DATA_VECTOR"> APPLICATION OF PERMUTATION TO DATA VECTOR </a> </h3>
<ul>
<li><a href=hpperm.f.html> hpperm </a>
<pre>
Rearrange a given array according to a prescribed
permutation vector.
</pre>
<li><a href=ipperm.f.html> ipperm </a>
<pre>
Rearrange a given array according to a prescribed
permutation vector.
</pre>
<li><a href=spperm.f.html> spperm </a>
<pre>
Rearrange a given array according to a prescribed
permutation vector.
</pre>
</ul>
<h3> <a name="ARC_COSINE"> ARC COSINE </a> </h3>
<ul>
<li><a href=cacos.f.html> cacos </a>
<pre>
Compute the complex arc cosine.
</pre>
</ul>
<h3> <a name="ARC_HYPERBOLIC_COSINE"> ARC HYPERBOLIC COSINE </a> </h3>
<ul>
<li><a href=acosh.f.html> acosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=cacosh.f.html> cacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=dacosh.f.html> dacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
</ul>
<h3> <a name="ARC_HYPERBOLIC_SINE"> ARC HYPERBOLIC SINE </a> </h3>
<ul>
<li><a href=asinh.f.html> asinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=casinh.f.html> casinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=dasinh.f.html> dasinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
</ul>
<h3> <a name="ARC_HYPERBOLIC_TANGENT"> ARC HYPERBOLIC TANGENT </a> </h3>
<ul>
<li><a href=atanh.f.html> atanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=catanh.f.html> catanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=datanh.f.html> datanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
</ul>
<h3> <a name="ARC_SINE"> ARC SINE </a> </h3>
<ul>
<li><a href=casin.f.html> casin </a>
<pre>
Compute the complex arc sine.
</pre>
</ul>
<h3> <a name="ARC_TANGENT"> ARC TANGENT </a> </h3>
<ul>
<li><a href=catan.f.html> catan </a>
<pre>
Compute the complex arc tangent.
</pre>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
<li><a href=d9atn1.f.html> d9atn1 </a>
<pre>
Evaluate DATAN(X) from first order relative accuracy so
that DATAN(X) = X + X**3*D9ATN1(X).
</pre>
<li><a href=r9atn1.f.html> r9atn1 </a>
<pre>
Evaluate ATAN(X) from first order relative accuracy so that
ATAN(X) = X + X**3*R9ATN1(X).
</pre>
</ul>
<h3> <a name="ARGUMENT_OF_A_COMPLEX_NUMBER"> ARGUMENT OF A COMPLEX NUMBER </a> </h3>
<ul>
<li><a href=carg.f.html> carg </a>
<pre>
Compute the argument of a complex number.
</pre>
</ul>
<h3> <a name="ASINH"> ASINH </a> </h3>
<ul>
<li><a href=asinh.f.html> asinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=casinh.f.html> casinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=dasinh.f.html> dasinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
</ul>
<h3> <a name="ATANH"> ATANH </a> </h3>
<ul>
<li><a href=atanh.f.html> atanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=catanh.f.html> catanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=datanh.f.html> datanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
</ul>
<h3> <a name="AUTOMATIC_INTEGRATOR"> AUTOMATIC INTEGRATOR </a> </h3>
<ul>
<li><a href=dgaus8.f.html> dgaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=gaus8.f.html> gaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="B-SPLINE"> B-SPLINE </a> </h3>
<ul>
<li><a href=bint4.f.html> bint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=bintk.f.html> bintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=bspdoc.f.html> bspdoc </a>
<pre>
Documentation for BSPLINE, a package of subprograms for
working with piecewise polynomial functions
in B-representation.
</pre>
<li><a href=bspdr.f.html> bspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=bspev.f.html> bspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=bsppp.f.html> bsppp </a>
<pre>
Convert the B-representation of a B-spline to the piecewise
polynomial (PP) form.
</pre>
<li><a href=cv.f.html> cv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram FC.
</pre>
<li><a href=dbint4.f.html> dbint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=dbintk.f.html> dbintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=dbspdr.f.html> dbspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=dbspev.f.html> dbspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dbsppp.f.html> dbsppp </a>
<pre>
Convert the B-representation of a B-spline to the piecewise
polynomial (PP) form.
</pre>
<li><a href=dcv.f.html> dcv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram DFC.
</pre>
<li><a href=defc.f.html> defc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=dfc.f.html> dfc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=dintrv.f.html> dintrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision of
the X interval.
</pre>
<li><a href=dpfqad.f.html> dpfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a
function F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=dppqad.f.html> dppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=dppval.f.html> dppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
<li><a href=efc.f.html> efc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=fc.f.html> fc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=intrv.f.html> intrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision
of the X interval.
</pre>
<li><a href=pfqad.f.html> pfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a function
F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=ppqad.f.html> ppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=ppval.f.html> ppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
</ul>
<h3> <a name="B-SPLINES"> B-SPLINES </a> </h3>
<ul>
<li><a href=dpchbs.f.html> dpchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=pchbs.f.html> pchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
</ul>
<h3> <a name="BACKWARD_DIFFERENTIATION_FORMULAS"> BACKWARD DIFFERENTIATION FORMULAS </a> </h3>
<ul>
<li><a href=ddassl.f.html> ddassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=sdassl.f.html> sdassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
</ul>
<h3> <a name="BAIRY_FUNCTION"> BAIRY FUNCTION </a> </h3>
<ul>
<li><a href=bi.f.html> bi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=bie.f.html> bie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=dbi.f.html> dbi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=dbie.f.html> dbie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
</ul>
<h3> <a name="BANDED"> BANDED </a> </h3>
<ul>
<li><a href=cgbco.f.html> cgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgbfa.f.html> cgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=cgbsl.f.html> cgbsl </a>
<pre>
Solve the complex band system A*X=B or CTRANS(A)*X=B using
the factors computed by CGBCO or CGBFA.
</pre>
<li><a href=cnbco.f.html> cnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=cnbdi.f.html> cnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by CNBCO or CNBFA.
</pre>
<li><a href=cnbfa.f.html> cnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=cnbfs.f.html> cnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=cnbir.f.html> cnbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=cnbsl.f.html> cnbsl </a>
<pre>
Solve a complex band system using the factors computed by
CNBCO or CNBFA.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpbfa.f.html> cpbfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=dgbco.f.html> dgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgbfa.f.html> dgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=dgbsl.f.html> dgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by DGBCO or DGBFA.
</pre>
<li><a href=dnbco.f.html> dnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=dnbdi.f.html> dnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DNBCO or DNBFA.
</pre>
<li><a href=dnbfa.f.html> dnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=dnbfs.f.html> dnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=dnbsl.f.html> dnbsl </a>
<pre>
Solve a real band system using the factors computed by
DNBCO or DNBFA.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpbfa.f.html> dpbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
in band form.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=sgbco.f.html> sgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgbfa.f.html> sgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=sgbsl.f.html> sgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by SGBCO or SGBFA.
</pre>
<li><a href=snbco.f.html> snbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=snbdi.f.html> snbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SNBCO or SNBFA.
</pre>
<li><a href=snbfa.f.html> snbfa </a>
<pre>
Factor a real band matrix by elimination.
</pre>
<li><a href=snbfs.f.html> snbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=snbir.f.html> snbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=snbsl.f.html> snbsl </a>
<pre>
Solve a real band system using the factors computed by
SNBCO or SNBFA.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spbfa.f.html> spbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
</ul>
<h3> <a name="BANDED_MATRIX"> BANDED MATRIX </a> </h3>
<ul>
<li><a href=bndacc.f.html> bndacc </a>
<pre>
Compute the LU factorization of a banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=bndsol.f.html> bndsol </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbndac.f.html> dbndac </a>
<pre>
Compute the LU factorization of a  banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbndsl.f.html> dbndsl </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
</ul>
<h3> <a name="BASE_TEN_LOGARITHM"> BASE TEN LOGARITHM </a> </h3>
<ul>
<li><a href=clog10.f.html> clog10 </a>
<pre>
Compute the principal value of the complex base 10
logarithm.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTION"> BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besj0.f.html> besj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=besj1.f.html> besj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=besy0.f.html> besy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=besy1.f.html> besy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=d9b0mp.f.html> d9b0mp </a>
<pre>
Evaluate the modulus and phase for the J0 and Y0 Bessel
functions.
</pre>
<li><a href=d9b1mp.f.html> d9b1mp </a>
<pre>
Evaluate the modulus and phase for the J1 and Y1 Bessel
functions.
</pre>
<li><a href=d9knus.f.html> d9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
<li><a href=dbesj0.f.html> dbesj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=dbesj1.f.html> dbesj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbesy0.f.html> dbesy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbesy1.f.html> dbesy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=r9knus.f.html> r9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTION_OF_ORDER_ONE_THIRD"> BESSEL FUNCTION OF ORDER ONE THIRD </a> </h3>
<ul>
<li><a href=cairy.f.html> cairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=cbiry.f.html> cbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
<li><a href=zairy.f.html> zairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=zbiry.f.html> zbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTION_OF_ORDER_TWO_THIRDS"> BESSEL FUNCTION OF ORDER TWO THIRDS </a> </h3>
<ul>
<li><a href=cairy.f.html> cairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=cbiry.f.html> cbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
<li><a href=zairy.f.html> zairy </a>
<pre>
Compute the Airy function Ai(z) or its derivative dAi/dz
for complex argument z.  A scaling option is available
to help avoid underflow and overflow.
</pre>
<li><a href=zbiry.f.html> zbiry </a>
<pre>
Compute the Airy function Bi(z) or its derivative dBi/dz
for complex argument z.  A scaling option is available
to help avoid overflow.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTIONS_OF_COMPLEX_ARGUMENT"> BESSEL FUNCTIONS OF COMPLEX ARGUMENT </a> </h3>
<ul>
<li><a href=cbesh.f.html> cbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
<li><a href=cbesi.f.html> cbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=cbesj.f.html> cbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=cbesk.f.html> cbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=cbesy.f.html> cbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesh.f.html> zbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
<li><a href=zbesi.f.html> zbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesj.f.html> zbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesk.f.html> zbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesy.f.html> zbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTIONS_OF_SECOND_KIND"> BESSEL FUNCTIONS OF SECOND KIND </a> </h3>
<ul>
<li><a href=cbesy.f.html> cbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesy.f.html> zbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTIONS_OF_THE_FIRST_KIND"> BESSEL FUNCTIONS OF THE FIRST KIND </a> </h3>
<ul>
<li><a href=cbesj.f.html> cbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesj.f.html> zbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="BESSEL_FUNCTIONS_OF_THE_THIRD_KIND"> BESSEL FUNCTIONS OF THE THIRD KIND </a> </h3>
<ul>
<li><a href=cbesh.f.html> cbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
<li><a href=zbesh.f.html> zbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
</ul>
<h3> <a name="BICKLEY_FUNCTIONS"> BICKLEY FUNCTIONS </a> </h3>
<ul>
<li><a href=bskin.f.html> bskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
<li><a href=dbskin.f.html> dbskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
</ul>
<h3> <a name="BICONJUGATE_GRADIENT"> BICONJUGATE GRADIENT </a> </h3>
<ul>
<li><a href=dbcg.f.html> dbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=dcgs.f.html> dcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=sbcg.f.html> sbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=scgs.f.html> scgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
</ul>
<h3> <a name="BICONJUGATE_GRADIENT_SQUARED"> BICONJUGATE GRADIENT SQUARED </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="BINOMIAL_COEFFICIENTS"> BINOMIAL COEFFICIENTS </a> </h3>
<ul>
<li><a href=binom.f.html> binom </a>
<pre>
Compute the binomial coefficients.
</pre>
<li><a href=dbinom.f.html> dbinom </a>
<pre>
Compute the binomial coefficients.
</pre>
</ul>
<h3> <a name="BISECTION"> BISECTION </a> </h3>
<ul>
<li><a href=dfzero.f.html> dfzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=fzero.f.html> fzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
</ul>
<h3> <a name="BLAS"> BLAS </a> </h3>
<ul>
<li><a href=caxpy.f.html> caxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=ccopy.f.html> ccopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=cdcdot.f.html> cdcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=cdotc.f.html> cdotc </a>
<pre>
Dot product of two complex vectors using the complex
conjugate of the first vector.
</pre>
<li><a href=cdotu.f.html> cdotu </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=crotg.f.html> crotg </a>
<pre>
Construct a Givens transformation.
</pre>
<li><a href=cscal.f.html> cscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=csscal.f.html> csscal </a>
<pre>
Scale a complex vector.
</pre>
<li><a href=cswap.f.html> cswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=dasum.f.html> dasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=daxpy.f.html> daxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dcopy.f.html> dcopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=dcopym.f.html> dcopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
<li><a href=ddot.f.html> ddot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drotg.f.html> drotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=drotm.f.html> drotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=drotmg.f.html> drotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=dscal.f.html> dscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dswap.f.html> dswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=icamax.f.html> icamax </a>
<pre>
Find the smallest index of the component of a complex
vector having the maximum sum of magnitudes of real
and imaginary parts.
</pre>
<li><a href=icopy.f.html> icopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=idamax.f.html> idamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=isamax.f.html> isamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=iswap.f.html> iswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=sasum.f.html> sasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=saxpy.f.html> saxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=scasum.f.html> scasum </a>
<pre>
Compute the sum of the magnitudes of the real and
imaginary elements of a complex vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=scopy.f.html> scopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=scopym.f.html> scopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
<li><a href=sdot.f.html> sdot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=sdsdot.f.html> sdsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srotg.f.html> srotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=srotm.f.html> srotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=srotmg.f.html> srotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=sscal.f.html> sscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=sswap.f.html> sswap </a>
<pre>
Interchange two vectors.
</pre>
</ul>
<h3> <a name="BOUNDS"> BOUNDS </a> </h3>
<ul>
<li><a href=dbocls.f.html> dbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=dbols.f.html> dbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
<li><a href=sbocls.f.html> sbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=sbols.f.html> sbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
</ul>
<h3> <a name="BROWN'S_METHOD"> BROWN'S METHOD </a> </h3>
<ul>
<li><a href=dsos.f.html> dsos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
<li><a href=sos.f.html> sos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
</ul>
<h3> <a name="CARTESIAN"> CARTESIAN </a> </h3>
<ul>
<li><a href=hw3crt.f.html> hw3crt </a>
<pre>
Solve the standard seven-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscrt.f.html> hwscrt </a>
<pre>
Solves the standard five-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
</ul>
<h3> <a name="CAUCHY_PRINCIPAL_VALUE"> CAUCHY PRINCIPAL VALUE </a> </h3>
<ul>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqwgtc.f.html> dqwgtc </a>
<pre>
This function subprogram is used together with the
routine DQAWC and defines the WEIGHT function.
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qwgtc.f.html> qwgtc </a>
<pre>
This function subprogram is used together with the
routine QAWC and defines the WEIGHT function.
</pre>
</ul>
<h3> <a name="CHARACTER_COMPARISON"> CHARACTER COMPARISON </a> </h3>
<ul>
<li><a href=lsame.f.html> lsame </a>
<pre>
Test two characters to determine if they are the same
letter, except for case.
</pre>
</ul>
<h3> <a name="CHEBYSHEV"> CHEBYSHEV </a> </h3>
<ul>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
</ul>
<h3> <a name="CHEBYSHEV_SERIES"> CHEBYSHEV SERIES </a> </h3>
<ul>
<li><a href=csevl.f.html> csevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
<li><a href=dcsevl.f.html> dcsevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
</ul>
<h3> <a name="CHEBYSHEV_SERIES_EXPANSION"> CHEBYSHEV SERIES EXPANSION </a> </h3>
<ul>
<li><a href=dqcheb.f.html> dqcheb </a>
<pre>
This routine computes the CHEBYSHEV series expansion
of degrees 12 and 24 of a function using A
FAST FOURIER TRANSFORM METHOD
F(X) = SUM(K=1,..,13) (CHEB12(K)*T(K-1,X)),
F(X) = SUM(K=1,..,25) (CHEB24(K)*T(K-1,X)),
Where T(K,X) is the CHEBYSHEV POLYNOMIAL OF DEGREE K.
</pre>
<li><a href=qcheb.f.html> qcheb </a>
<pre>
This routine computes the CHEBYSHEV series expansion
of degrees 12 and 24 of a function using A
FAST FOURIER TRANSFORM METHOD
F(X) = SUM(K=1,..,13) (CHEB12(K)*T(K-1,X)),
F(X) = SUM(K=1,..,25) (CHEB24(K)*T(K-1,X)),
Where T(K,X) is the CHEBYSHEV POLYNOMIAL OF DEGREE K.
</pre>
</ul>
<h3> <a name="CHOLESKY_DECOMPOSITION"> CHOLESKY DECOMPOSITION </a> </h3>
<ul>
<li><a href=cchdc.f.html> cchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=cchdd.f.html> cchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=cchud.f.html> cchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=dchdc.f.html> dchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=dchdd.f.html> dchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dchud.f.html> dchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=schdc.f.html> schdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=schdd.f.html> schdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=schud.f.html> schud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
</ul>
<h3> <a name="CLEBSCH-GORDAN_COEFFICIENTS"> CLEBSCH-GORDAN COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="CLENSHAW-CURTIS_METHOD"> CLENSHAW-CURTIS METHOD </a> </h3>
<ul>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqc25f.f.html> dqc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) or W(X)=SIN(OMEGA*X) and to
compute J = Integral of ABS(F) over (A,B). For small value
of OMEGA or small intervals (A,B) the 15-point GAUSS-KRONRO
Rule is used. Otherwise a generalized CLENSHAW-CURTIS
method is used.
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qc25f.f.html> qc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) Or (WX)=SIN(OMEGA*X)
and to compute J=Integral of ABS(F) over (A,B). For small
value of OMEGA or small intervals (A,B) 15-point GAUSS-
KRONROD Rule used. Otherwise generalized CLENSHAW-CURTIS us
</pre>
</ul>
<h3> <a name="COEFFICIENTS"> COEFFICIENTS </a> </h3>
<ul>
<li><a href=dpolcf.f.html> dpolcf </a>
<pre>
Compute the coefficients of the polynomial fit (including
Hermite polynomial fits) produced by a previous call to
POLINT.
</pre>
<li><a href=polcof.f.html> polcof </a>
<pre>
Compute the coefficients of the polynomial fit (including
Hermite polynomial fits) produced by a previous call to
POLINT.
</pre>
</ul>
<h3> <a name="COMPLEMENTARY_ERROR_FUNCTION"> COMPLEMENTARY ERROR FUNCTION </a> </h3>
<ul>
<li><a href=derfc.f.html> derfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=erfc.f.html> erfc </a>
<pre>
Compute the complementary error function.
</pre>
</ul>
<h3> <a name="COMPLEMENTARY_INCOMPLETE_GAMMA_FUNCTION"> COMPLEMENTARY INCOMPLETE GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=d9gmic.f.html> d9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and X small.
</pre>
<li><a href=d9gmit.f.html> d9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=d9lgic.f.html> d9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=dgamic.f.html> dgamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=dgamit.f.html> dgamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=gamic.f.html> gamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=gamit.f.html> gamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=r9gmic.f.html> r9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and for small X.
</pre>
<li><a href=r9gmit.f.html> r9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=r9lgic.f.html> r9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
</ul>
<h3> <a name="COMPLETE_BETA_FUNCTION"> COMPLETE BETA FUNCTION </a> </h3>
<ul>
<li><a href=beta.f.html> beta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=cbeta.f.html> cbeta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=dbeta.f.html> dbeta </a>
<pre>
Compute the complete Beta function.
</pre>
</ul>
<h3> <a name="COMPLETE_ELLIPTIC_INTEGRAL"> COMPLETE ELLIPTIC INTEGRAL </a> </h3>
<ul>
<li><a href=drd.f.html> drd </a>
<pre>
Compute the incomplete or complete elliptic integral of
the 2nd kind. For X and Y nonnegative, X+Y and Z positive,
DRD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=drf.f.html> drf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=drj.f.html> drj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                  -1/2     -1/2     -1/2     -1
        (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
<li><a href=rd.f.html> rd </a>
<pre>
Compute the incomplete or complete elliptic integral of the
2nd kind.  For X and Y nonnegative, X+Y and Z positive,
 RD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=rf.f.html> rf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=rj.f.html> rj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                      -1/2     -1/2     -1/2     -1
            (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
</ul>
<h3> <a name="COMPLETE_GAMMA_FUNCTION"> COMPLETE GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=alngam.f.html> alngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=cgamma.f.html> cgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=clngam.f.html> clngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=dgamlm.f.html> dgamlm </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=dgamma.f.html> dgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=dlngam.f.html> dlngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=gamlim.f.html> gamlim </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=gamma.f.html> gamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
</ul>
<h3> <a name="COMPLEX_HERMITIAN"> COMPLEX HERMITIAN </a> </h3>
<ul>
<li><a href=chiev.f.html> chiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=ssiev.f.html> ssiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
</ul>
<h3> <a name="COMPLEX_LINEAR_EQUATIONS"> COMPLEX LINEAR EQUATIONS </a> </h3>
<ul>
<li><a href=cgefs.f.html> cgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=cgeir.f.html> cgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
<li><a href=dgefs.f.html> dgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgefs.f.html> sgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgeir.f.html> sgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
</ul>
<h3> <a name="COMPLEX_POLYNOMIAL"> COMPLEX POLYNOMIAL </a> </h3>
<ul>
<li><a href=cpqr79.f.html> cpqr79 </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=rpqr79.f.html> rpqr79 </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
</ul>
<h3> <a name="COMPLEX_VALUED"> COMPLEX VALUED </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
</ul>
<h3> <a name="COMPLEX_VECTORS"> COMPLEX VECTORS </a> </h3>
<ul>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
</ul>
<h3> <a name="CONDITION_NUMBER"> CONDITION NUMBER </a> </h3>
<ul>
<li><a href=cgbco.f.html> cgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=cgeco.f.html> cgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=chico.f.html> chico </a>
<pre>
Factor a complex Hermitian matrix by elimination with sym-
metric pivoting and estimate the condition of the matrix.
</pre>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpoco.f.html> cpoco </a>
<pre>
Factor a complex Hermitian positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=csico.f.html> csico </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting and estimate the condition number of the
matrix.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=ctrco.f.html> ctrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=dgbco.f.html> dgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=dgeco.f.html> dgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpoco.f.html> dpoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition of the matrix.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dsico.f.html> dsico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dtrco.f.html> dtrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=sgbco.f.html> sgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=sgeco.f.html> sgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spoco.f.html> spoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=ssico.f.html> ssico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=strco.f.html> strco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
</ul>
<h3> <a name="CONSTRAINED_LEAST_SQUARES"> CONSTRAINED LEAST SQUARES </a> </h3>
<ul>
<li><a href=cv.f.html> cv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram FC.
</pre>
<li><a href=dcv.f.html> dcv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram DFC.
</pre>
<li><a href=defc.f.html> defc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=dfc.f.html> dfc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=fc.f.html> fc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="CONSTRAINTS"> CONSTRAINTS </a> </h3>
<ul>
<li><a href=dbocls.f.html> dbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=dbols.f.html> dbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
<li><a href=sbocls.f.html> sbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=sbols.f.html> sbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
</ul>
<h3> <a name="CONVERGENCE_ACCELERATION"> CONVERGENCE ACCELERATION </a> </h3>
<ul>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqelg.f.html> dqelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P.Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qelg.f.html> qelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P. Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
</ul>
<h3> <a name="CONVERSION"> CONVERSION </a> </h3>
<ul>
<li><a href=dpchbs.f.html> dpchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=pchbs.f.html> pchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
</ul>
<h3> <a name="COPY"> COPY </a> </h3>
<ul>
<li><a href=ccopy.f.html> ccopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=dcopy.f.html> dcopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=dcopym.f.html> dcopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
<li><a href=icopy.f.html> icopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=scopy.f.html> scopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=scopym.f.html> scopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
</ul>
<h3> <a name="CORRECTION_TERM"> CORRECTION TERM </a> </h3>
<ul>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
</ul>
<h3> <a name="COS_OR_SIN_IN_WEIGHT_FUNCTION"> COS OR SIN IN WEIGHT FUNCTION </a> </h3>
<ul>
<li><a href=dqwgtf.f.html> dqwgtf </a>
<pre>
This function subprogram is used together with the
routine DQAWF and defines the WEIGHT function.
</pre>
<li><a href=qwgtf.f.html> qwgtf </a>
<pre>
This function subprogram is used together with the
routine QAWF and defines the WEIGHT function.
</pre>
</ul>
<h3> <a name="COSINE"> COSINE </a> </h3>
<ul>
<li><a href=cosdg.f.html> cosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dcosdg.f.html> dcosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
</ul>
<h3> <a name="COSINE_FOURIER_TRANSFORM"> COSINE FOURIER TRANSFORM </a> </h3>
<ul>
<li><a href=cosqf.f.html> cosqf </a>
<pre>
Compute the forward cosine transform with odd wave numbers.
</pre>
<li><a href=cosqi.f.html> cosqi </a>
<pre>
Initialize a work array for COSQF and COSQB.
</pre>
<li><a href=cost.f.html> cost </a>
<pre>
Compute the cosine transform of a real, even sequence.
</pre>
<li><a href=costi.f.html> costi </a>
<pre>
Initialize a work array for COST.
</pre>
</ul>
<h3> <a name="COTANGENT"> COTANGENT </a> </h3>
<ul>
<li><a href=ccot.f.html> ccot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=cot.f.html> cot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=dcot.f.html> dcot </a>
<pre>
Compute the cotangent.
</pre>
</ul>
<h3> <a name="COVARIANCE_MATRIX"> COVARIANCE MATRIX </a> </h3>
<ul>
<li><a href=dcov.f.html> dcov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either DNLS1 or DNLS1E.
</pre>
<li><a href=scov.f.html> scov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either SNLS1 or SNLS1E.
</pre>
</ul>
<h3> <a name="CUBE_ROOT"> CUBE ROOT </a> </h3>
<ul>
<li><a href=cbrt.f.html> cbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccbrt.f.html> ccbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=dcbrt.f.html> dcbrt </a>
<pre>
Compute the cube root.
</pre>
</ul>
<h3> <a name="CUBIC_HERMITE_DIFFERENTIATION"> CUBIC HERMITE DIFFERENTIATION </a> </h3>
<ul>
<li><a href=chfdv.f.html> chfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by PCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use CHFEV instead.
</pre>
<li><a href=dchfdv.f.html> dchfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by DPCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use DCHFEV instead.
</pre>
<li><a href=dpchfd.f.html> dpchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for DPCHIM
or DPCHIC. If only function values are required, use
DPCHFE instead.
</pre>
<li><a href=pchfd.f.html> pchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for PCHIM
or PCHIC.  If only function values are required, use
PCHFE instead.
</pre>
</ul>
<h3> <a name="CUBIC_HERMITE_EVALUATION"> CUBIC HERMITE EVALUATION </a> </h3>
<ul>
<li><a href=chfdv.f.html> chfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by PCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use CHFEV instead.
</pre>
<li><a href=chfev.f.html> chfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by PCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
<li><a href=dchfdv.f.html> dchfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by DPCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use DCHFEV instead.
</pre>
<li><a href=dchfev.f.html> dchfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by DPCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
<li><a href=dpchfd.f.html> dpchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for DPCHIM
or DPCHIC. If only function values are required, use
DPCHFE instead.
</pre>
<li><a href=dpchfe.f.html> dpchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for DPCHIM or DPCHIC.
</pre>
<li><a href=pchfd.f.html> pchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for PCHIM
or PCHIC.  If only function values are required, use
PCHFE instead.
</pre>
<li><a href=pchfe.f.html> pchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for PCHIM or PCHIC.
</pre>
</ul>
<h3> <a name="CUBIC_HERMITE_INTERPOLATION"> CUBIC HERMITE INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchbs.f.html> dpchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=dpchcm.f.html> dpchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=dpchia.f.html> dpchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=dpchic.f.html> dpchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=dpchid.f.html> dpchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=dpchim.f.html> dpchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See DPCHIC if user control
is desired over boundary or switch conditions.)
</pre>
<li><a href=dpchsp.f.html> dpchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
<li><a href=pchbs.f.html> pchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=pchcm.f.html> pchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=pchdoc.f.html> pchdoc </a>
<pre>
Documentation for PCHIP, a Fortran package for piecewise
cubic Hermite interpolation of data.
</pre>
<li><a href=pchia.f.html> pchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=pchic.f.html> pchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=pchid.f.html> pchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=pchim.f.html> pchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See PCHIC if user control is
desired over boundary or switch conditions.)
</pre>
<li><a href=pchsp.f.html> pchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
</ul>
<h3> <a name="CUBIC_POLYNOMIAL_EVALUATION"> CUBIC POLYNOMIAL EVALUATION </a> </h3>
<ul>
<li><a href=chfdv.f.html> chfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by PCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use CHFEV instead.
</pre>
<li><a href=chfev.f.html> chfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by PCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
<li><a href=dchfdv.f.html> dchfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by DPCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use DCHFEV instead.
</pre>
<li><a href=dchfev.f.html> dchfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by DPCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
</ul>
<h3> <a name="CUBIC_SPLINES"> CUBIC SPLINES </a> </h3>
<ul>
<li><a href=bint4.f.html> bint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=dbint4.f.html> dbint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
</ul>
<h3> <a name="CURVE_FITTING"> CURVE FITTING </a> </h3>
<ul>
<li><a href=bndacc.f.html> bndacc </a>
<pre>
Compute the LU factorization of a banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=bndsol.f.html> bndsol </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=cv.f.html> cv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram FC.
</pre>
<li><a href=dbndac.f.html> dbndac </a>
<pre>
Compute the LU factorization of a  banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbndsl.f.html> dbndsl </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dcv.f.html> dcv </a>
<pre>
Evaluate the variance function of the curve obtained
by the constrained B-spline fitting subprogram DFC.
</pre>
<li><a href=defc.f.html> defc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=dfc.f.html> dfc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=dhfti.f.html> dhfti </a>
<pre>
Solve a least squares problem for banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dp1vlu.f.html> dp1vlu </a>
<pre>
Use the coefficients generated by DPOLFT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
<li><a href=dpcoef.f.html> dpcoef </a>
<pre>
Convert the DPOLFT coefficients to Taylor series form.
</pre>
<li><a href=dpolft.f.html> dpolft </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=efc.f.html> efc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=fc.f.html> fc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=hfti.f.html> hfti </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=pcoef.f.html> pcoef </a>
<pre>
Convert the POLFIT coefficients to Taylor series form.
</pre>
<li><a href=polfit.f.html> polfit </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=pvalue.f.html> pvalue </a>
<pre>
Use the coefficients generated by POLFIT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="CYCLIC_REDUCTION"> CYCLIC REDUCTION </a> </h3>
<ul>
<li><a href=cmgnbn.f.html> cmgnbn </a>
<pre>
Solve a complex block tridiagonal linear system of
equations by a cyclic reduction algorithm.
</pre>
</ul>
<h3> <a name="CYLINDRICAL"> CYLINDRICAL </a> </h3>
<ul>
<li><a href=hstcyl.f.html> hstcyl </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified
Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hwscyl.f.html> hwscyl </a>
<pre>
Solve a standard finite difference approximation
to the Helmholtz equation in cylindrical coordinates.
</pre>
</ul>
<h3> <a name="DASSL"> DASSL </a> </h3>
<ul>
<li><a href=ddassl.f.html> ddassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
<li><a href=sdassl.f.html> sdassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
</ul>
<h3> <a name="DATA_FITTING"> DATA FITTING </a> </h3>
<ul>
<li><a href=bint4.f.html> bint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=bintk.f.html> bintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=bspdr.f.html> bspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=bspev.f.html> bspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dbint4.f.html> dbint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=dbintk.f.html> dbintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=dbspdr.f.html> dbspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=dbspev.f.html> dbspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dintrv.f.html> dintrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision of
the X interval.
</pre>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dpcoef.f.html> dpcoef </a>
<pre>
Convert the DPOLFT coefficients to Taylor series form.
</pre>
<li><a href=dpfqad.f.html> dpfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a
function F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=dpolft.f.html> dpolft </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=dppqad.f.html> dppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=dppval.f.html> dppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=intrv.f.html> intrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision
of the X interval.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=pcoef.f.html> pcoef </a>
<pre>
Convert the POLFIT coefficients to Taylor series form.
</pre>
<li><a href=pfqad.f.html> pfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a function
F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=polfit.f.html> polfit </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=ppqad.f.html> ppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=ppval.f.html> ppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="DAWSON'S_FUNCTION"> DAWSON'S FUNCTION </a> </h3>
<ul>
<li><a href=daws.f.html> daws </a>
<pre>
Compute Dawson's function.
</pre>
<li><a href=ddaws.f.html> ddaws </a>
<pre>
Compute Dawson's function.
</pre>
</ul>
<h3> <a name="DEGREES"> DEGREES </a> </h3>
<ul>
<li><a href=cosdg.f.html> cosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dcosdg.f.html> dcosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dsindg.f.html> dsindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=sindg.f.html> sindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
</ul>
<h3> <a name="DEPAC"> DEPAC </a> </h3>
<ul>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="DERIVATIVES_OF_THE_GAMMA_FUNCTION"> DERIVATIVES OF THE GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=dpsifn.f.html> dpsifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
<li><a href=psifn.f.html> psifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
</ul>
<h3> <a name="DETERMINANT"> DETERMINANT </a> </h3>
<ul>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgedi.f.html> cgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=cnbdi.f.html> cnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by CNBCO or CNBFA.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=ctrdi.f.html> ctrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgedi.f.html> dgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dnbdi.f.html> dnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DNBCO or DNBFA.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dtrdi.f.html> dtrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgedi.f.html> sgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by SGECO or SGEFA.
</pre>
<li><a href=snbdi.f.html> snbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SNBCO or SNBFA.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
</ul>
<h3> <a name="DIAGNOSTICS"> DIAGNOSTICS </a> </h3>
<ul>
<li><a href=dcpplt.f.html> dcpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=dtin.f.html> dtin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=dtout.f.html> dtout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=scpplt.f.html> scpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=stin.f.html> stin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=stout.f.html> stout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
</ul>
<h3> <a name="DIAGONAL"> DIAGONAL </a> </h3>
<ul>
<li><a href=dsd2s.f.html> dsd2s </a>
<pre>
Diagonal Scaling Preconditioner SLAP Normal Eqns Set Up.
Routine to compute the inverse of the diagonal of the
matrix A*A', where A is stored in SLAP-Column format.
</pre>
<li><a href=dsds.f.html> dsds </a>
<pre>
Diagonal Scaling Preconditioner SLAP Set Up.
Routine to compute the inverse of the diagonal of a matrix
stored in the SLAP Column format.
</pre>
<li><a href=dsdscl.f.html> dsdscl </a>
<pre>
Diagonal Scaling of system Ax = b.
This routine scales (and unscales) the system  Ax = b
by symmetric diagonal scaling.
</pre>
<li><a href=ssd2s.f.html> ssd2s </a>
<pre>
Diagonal Scaling Preconditioner SLAP Normal Eqns Set Up.
Routine to compute the inverse of the diagonal of the
matrix A*A', where A is stored in SLAP-Column format.
</pre>
<li><a href=ssds.f.html> ssds </a>
<pre>
Diagonal Scaling Preconditioner SLAP Set Up.
Routine to compute the inverse of the diagonal of a matrix
stored in the SLAP Column format.
</pre>
<li><a href=ssdscl.f.html> ssdscl </a>
<pre>
Diagonal Scaling of system Ax = b.
This routine scales (and unscales) the system  Ax = b
by symmetric diagonal scaling.
</pre>
</ul>
<h3> <a name="DIFFERENTIAL/ALGEBRAIC"> DIFFERENTIAL/ALGEBRAIC </a> </h3>
<ul>
<li><a href=ddassl.f.html> ddassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
<li><a href=sdassl.f.html> sdassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
</ul>
<h3> <a name="DIFFERENTIATION_OF_B-SPLINE"> DIFFERENTIATION OF B-SPLINE </a> </h3>
<ul>
<li><a href=bspvd.f.html> bspvd </a>
<pre>
Calculate the value and all derivatives of order less than
NDERIV of all basis functions which do not vanish at X.
</pre>
<li><a href=bvalu.f.html> bvalu </a>
<pre>
Evaluate the B-representation of a B-spline at X for the
function value or any of its derivatives.
</pre>
<li><a href=dbspvd.f.html> dbspvd </a>
<pre>
Calculate the value and all derivatives of order less than
NDERIV of all basis functions which do not vanish at X.
</pre>
<li><a href=dbvalu.f.html> dbvalu </a>
<pre>
Evaluate the B-representation of a B-spline at X for the
function value or any of its derivatives.
</pre>
</ul>
<h3> <a name="DIFFERENTIATION_OF_SPLINES"> DIFFERENTIATION OF SPLINES </a> </h3>
<ul>
<li><a href=bspdr.f.html> bspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=dbspdr.f.html> dbspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
</ul>
<h3> <a name="DIGAMMA_FUNCTION"> DIGAMMA FUNCTION </a> </h3>
<ul>
<li><a href=cpsi.f.html> cpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=dpsi.f.html> dpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=psi.f.html> psi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
</ul>
<h3> <a name="DISCLAIMER"> DISCLAIMER </a> </h3>
<ul>
<li><a href=aaaaaa.f.html> aaaaaa </a>
<pre>
SLATEC Common Mathematical Library disclaimer and version.
</pre>
</ul>
<h3> <a name="DOCUMENTATION"> DOCUMENTATION </a> </h3>
<ul>
<li><a href=aaaaaa.f.html> aaaaaa </a>
<pre>
SLATEC Common Mathematical Library disclaimer and version.
</pre>
<li><a href=bspdoc.f.html> bspdoc </a>
<pre>
Documentation for BSPLINE, a package of subprograms for
working with piecewise polynomial functions
in B-representation.
</pre>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=fftdoc.f.html> fftdoc </a>
<pre>
Documentation for FFTPACK, a collection of Fast Fourier
Transform routines.
</pre>
<li><a href=fundoc.f.html> fundoc </a>
<pre>
Documentation for FNLIB, a collection of routines for
evaluating elementary and special functions.
</pre>
<li><a href=pchdoc.f.html> pchdoc </a>
<pre>
Documentation for PCHIP, a Fortran package for piecewise
cubic Hermite interpolation of data.
</pre>
<li><a href=qpdoc.f.html> qpdoc </a>
<pre>
Documentation for QUADPACK, a package of subprograms for
automatic evaluation of one-dimensional definite integrals.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="DOT_PRODUCT"> DOT PRODUCT </a> </h3>
<ul>
<li><a href=cdcdot.f.html> cdcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dqdota.f.html> dqdota </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dqdoti.f.html> dqdoti </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=sdsdot.f.html> sdsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
</ul>
<h3> <a name="DOUBLE_PRECISION"> DOUBLE PRECISION </a> </h3>
<ul>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
</ul>
<h3> <a name="DOWNDATE"> DOWNDATE </a> </h3>
<ul>
<li><a href=cchdd.f.html> cchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=dchdd.f.html> dchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=schdd.f.html> schdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
</ul>
<h3> <a name="DUPLICATION_THEOREM"> DUPLICATION THEOREM </a> </h3>
<ul>
<li><a href=drc.f.html> drc </a>
<pre>
Calculate a double precision approximation to
 DRC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=drd.f.html> drd </a>
<pre>
Compute the incomplete or complete elliptic integral of
the 2nd kind. For X and Y nonnegative, X+Y and Z positive,
DRD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=drf.f.html> drf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=drj.f.html> drj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                  -1/2     -1/2     -1/2     -1
        (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
<li><a href=rc.f.html> rc </a>
<pre>
Calculate an approximation to
 RC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=rd.f.html> rd </a>
<pre>
Compute the incomplete or complete elliptic integral of the
2nd kind.  For X and Y nonnegative, X+Y and Z positive,
 RD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=rf.f.html> rf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=rj.f.html> rj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                      -1/2     -1/2     -1/2     -1
            (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
</ul>
<h3> <a name="E1_FUNCTION"> E1 FUNCTION </a> </h3>
<ul>
<li><a href=de1.f.html> de1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=e1.f.html> e1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
</ul>
<h3> <a name="EASY-TO-USE"> EASY-TO-USE </a> </h3>
<ul>
<li><a href=dnls1e.f.html> dnls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
<li><a href=dnsqe.f.html> dnsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
<li><a href=snls1e.f.html> snls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
<li><a href=snsqe.f.html> snsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
</ul>
<h3> <a name="EI_FUNCTION"> EI FUNCTION </a> </h3>
<ul>
<li><a href=dei.f.html> dei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=ei.f.html> ei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
</ul>
<h3> <a name="EIGENVALUES"> EIGENVALUES </a> </h3>
<ul>
<li><a href=bandr.f.html> bandr </a>
<pre>
Reduce a real symmetric band matrix to symmetric
tridiagonal matrix and, optionally, accumulate
orthogonal similarity transformations.
</pre>
<li><a href=bisect.f.html> bisect </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
in a given interval using Sturm sequencing.
</pre>
<li><a href=bqr.f.html> bqr </a>
<pre>
Compute some of the eigenvalues of a real symmetric
matrix using the QR method with shifts of origin.
</pre>
<li><a href=cg.f.html> cg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=ch.f.html> ch </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cgeev.f.html> cgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=chiev.f.html> chiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cinvit.f.html> cinvit </a>
<pre>
Compute the eigenvectors of a complex upper Hessenberg
associated with specified eigenvalues using inverse
iteration.
</pre>
<li><a href=combak.f.html> combak </a>
<pre>
Form the eigenvectors of a complex general matrix from the
eigenvectors of a upper Hessenberg matrix output from
COMHES.
</pre>
<li><a href=comhes.f.html> comhes </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using stabilized elementary similarity
transformations.
</pre>
<li><a href=comlr.f.html> comlr </a>
<pre>
Compute the eigenvalues of a complex upper Hessenberg
matrix using the modified LR method.
</pre>
<li><a href=comlr2.f.html> comlr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix using the modified LR method.
</pre>
<li><a href=comqr.f.html> comqr </a>
<pre>
Compute the eigenvalues of complex upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=comqr2.f.html> comqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix.
</pre>
<li><a href=cortb.f.html> cortb </a>
<pre>
Form the eigenvectors of a complex general matrix from
eigenvectors of upper Hessenberg matrix output from
CORTH.
</pre>
<li><a href=corth.f.html> corth </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using unitary similarity transformations.
</pre>
<li><a href=eisdoc.f.html> eisdoc </a>
<pre>
Documentation for EISPACK, a collection of subprograms for
solving matrix eigen-problems.
</pre>
<li><a href=elmbak.f.html> elmbak </a>
<pre>
Form the eigenvectors of a real general matrix from the
eigenvectors of the upper Hessenberg matrix output from
ELMHES.
</pre>
<li><a href=elmhes.f.html> elmhes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using stabilized elementary similarity transformations.
</pre>
<li><a href=eltran.f.html> eltran </a>
<pre>
Accumulates the stabilized elementary similarity
transformations used in the reduction of a real general
matrix to upper Hessenberg form by ELMHES.
</pre>
<li><a href=figi.f.html> figi </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=figi2.f.html> figi2 </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=hqr.f.html> hqr </a>
<pre>
Compute the eigenvalues of a real upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=hqr2.f.html> hqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a real upper
Hessenberg matrix using QR method.
</pre>
<li><a href=htrib3.f.html> htrib3 </a>
<pre>
Compute the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRID3.
</pre>
<li><a href=htribk.f.html> htribk </a>
<pre>
Form the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRIDI.
</pre>
<li><a href=htrid3.f.html> htrid3 </a>
<pre>
Reduce a complex Hermitian (packed) matrix to a real
symmetric tridiagonal matrix by unitary similarity
transformations.
</pre>
<li><a href=htridi.f.html> htridi </a>
<pre>
Reduce a complex Hermitian matrix to a real symmetric
tridiagonal matrix using unitary similarity
transformations.
</pre>
<li><a href=imtql1.f.html> imtql1 </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.
</pre>
<li><a href=imtql2.f.html> imtql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a symmetric
tridiagonal matrix using the implicit QL method.
</pre>
<li><a href=imtqlv.f.html> imtqlv </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.  Eigenvectors may be computed
later.
</pre>
<li><a href=invit.f.html> invit </a>
<pre>
Compute the eigenvectors of a real upper Hessenberg
matrix associated with specified eigenvalues by inverse
iteration.
</pre>
<li><a href=minfit.f.html> minfit </a>
<pre>
Compute the singular value decomposition of a rectangular
matrix and solve the related linear least squares problem.
</pre>
<li><a href=ortbak.f.html> ortbak </a>
<pre>
Form the eigenvectors of a general real matrix from the
eigenvectors of the upper Hessenberg matrix output from
ORTHES.
</pre>
<li><a href=orthes.f.html> orthes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using orthogonal similarity transformations.
</pre>
<li><a href=ortran.f.html> ortran </a>
<pre>
Accumulate orthogonal similarity transformations in the
reduction of real general matrix by ORTHES.
</pre>
<li><a href=qzhes.f.html> qzhes </a>
<pre>
The first step of the QZ algorithm for solving generalized
matrix eigenproblems.  Accepts a pair of real general
matrices and reduces one of them to upper Hessenberg
and the other to upper triangular form using orthogonal
transformations. Usually followed by QZIT, QZVAL, QZVEC.
</pre>
<li><a href=qzit.f.html> qzit </a>
<pre>
The second step of the QZ algorithm for generalized
eigenproblems.  Accepts an upper Hessenberg and an upper
triangular matrix and reduces the former to
quasi-triangular form while preserving the form of the
latter.  Usually preceded by QZHES and followed by QZVAL
and QZVEC.
</pre>
<li><a href=qzval.f.html> qzval </a>
<pre>
The third step of the QZ algorithm for generalized
eigenproblems.  Accepts a pair of real matrices, one in
quasi-triangular form and the other in upper triangular
form and computes the eigenvalues of the associated
eigenproblem.  Usually preceded by QZHES, QZIT, and
followed by QZVEC.
</pre>
<li><a href=qzvec.f.html> qzvec </a>
<pre>
The optional fourth step of the QZ algorithm for
generalized eigenproblems.  Accepts a matrix in
quasi-triangular form and another in upper triangular
and computes the eigenvectors of the triangular problem
and transforms them back to the original coordinates
Usually preceded by QZHES, QZIT, and QZVAL.
</pre>
<li><a href=ratqr.f.html> ratqr </a>
<pre>
Compute the largest or smallest eigenvalues of a symmetric
tridiagonal matrix using the rational QR method with Newton
correction.
</pre>
<li><a href=rebak.f.html> rebak </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC or REDUC2.
</pre>
<li><a href=rebakb.f.html> rebakb </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC2.
</pre>
<li><a href=reduc.f.html> reduc </a>
<pre>
Reduce a generalized symmetric eigenproblem to a standard
symmetric eigenproblem using Cholesky factorization.
</pre>
<li><a href=reduc2.f.html> reduc2 </a>
<pre>
Reduce a certain generalized symmetric eigenproblem to a
standard symmetric eigenproblem using Cholesky
factorization.
</pre>
<li><a href=rg.f.html> rg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=rgg.f.html> rgg </a>
<pre>
Compute the eigenvalues and eigenvectors for a real
generalized eigenproblem.
</pre>
<li><a href=rs.f.html> rs </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=rsb.f.html> rsb </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric band matrix.
</pre>
<li><a href=rsg.f.html> rsg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgab.f.html> rsgab </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgba.f.html> rsgba </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsp.f.html> rsp </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix packed into a one dimensional
array.
</pre>
<li><a href=rst.f.html> rst </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric tridiagonal matrix.
</pre>
<li><a href=rt.f.html> rt </a>
<pre>
Compute the eigenvalues and eigenvectors of a special real
tridiagonal matrix.
</pre>
<li><a href=sgeev.f.html> sgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=ssiev.f.html> ssiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=sspev.f.html> sspev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix stored in packed form.
</pre>
<li><a href=tql2.f.html> tql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of symmetric
tridiagonal matrix.
</pre>
<li><a href=tred1.f.html> tred1 </a>
<pre>
Reduce a real symmetric matrix to symmetric tridiagonal
matrix using orthogonal similarity transformations.
</pre>
<li><a href=tred2.f.html> tred2 </a>
<pre>
Reduce a real symmetric matrix to a symmetric tridiagonal
matrix using and accumulating orthogonal transformations.
</pre>
<li><a href=tred3.f.html> tred3 </a>
<pre>
Reduce a real symmetric matrix stored in packed form to
symmetric tridiagonal matrix using orthogonal
transformations.
</pre>
<li><a href=tsturm.f.html> tsturm </a>
<pre>
Find those eigenvalues of a symmetric tridiagonal matrix
in a given interval and their associated eigenvectors by
Sturm sequencing.
</pre>
</ul>
<h3> <a name="EIGENVALUES_OF_A_REAL_SYMMETRIC_MATRIX"> EIGENVALUES OF A REAL SYMMETRIC MATRIX </a> </h3>
<ul>
<li><a href=tridib.f.html> tridib </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
in a given interval using Sturm sequencing.
</pre>
</ul>
<h3> <a name="EIGENVALUES_OF_A_SYMMETRIC_TRIDIAGONAL_MATRIX"> EIGENVALUES OF A SYMMETRIC TRIDIAGONAL MATRIX </a> </h3>
<ul>
<li><a href=tql1.f.html> tql1 </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix by
the QL method.
</pre>
<li><a href=tqlrat.f.html> tqlrat </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix
using a rational variant of the QL method.
</pre>
</ul>
<h3> <a name="EIGENVECTORS"> EIGENVECTORS </a> </h3>
<ul>
<li><a href=bakvec.f.html> bakvec </a>
<pre>
Form the eigenvectors of a certain real non-symmetric
tridiagonal matrix from a symmetric tridiagonal matrix
output from FIGI.
</pre>
<li><a href=balanc.f.html> balanc </a>
<pre>
Balance a real general matrix and isolate eigenvalues
whenever possible.
</pre>
<li><a href=balbak.f.html> balbak </a>
<pre>
Form the eigenvectors of a real general matrix from the
eigenvectors of matrix output from BALANC.
</pre>
<li><a href=bandr.f.html> bandr </a>
<pre>
Reduce a real symmetric band matrix to symmetric
tridiagonal matrix and, optionally, accumulate
orthogonal similarity transformations.
</pre>
<li><a href=bandv.f.html> bandv </a>
<pre>
Form the eigenvectors of a real symmetric band matrix
associated with a set of ordered approximate eigenvalues
by inverse iteration.
</pre>
<li><a href=cbabk2.f.html> cbabk2 </a>
<pre>
Form the eigenvectors of a complex general matrix from the
eigenvectors of matrix output from CBAL.
</pre>
<li><a href=cbal.f.html> cbal </a>
<pre>
Balance a complex general matrix and isolate eigenvalues
whenever possible.
</pre>
<li><a href=cg.f.html> cg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=ch.f.html> ch </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cgeev.f.html> cgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=chiev.f.html> chiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cinvit.f.html> cinvit </a>
<pre>
Compute the eigenvectors of a complex upper Hessenberg
associated with specified eigenvalues using inverse
iteration.
</pre>
<li><a href=combak.f.html> combak </a>
<pre>
Form the eigenvectors of a complex general matrix from the
eigenvectors of a upper Hessenberg matrix output from
COMHES.
</pre>
<li><a href=comhes.f.html> comhes </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using stabilized elementary similarity
transformations.
</pre>
<li><a href=comlr2.f.html> comlr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix using the modified LR method.
</pre>
<li><a href=comqr.f.html> comqr </a>
<pre>
Compute the eigenvalues of complex upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=comqr2.f.html> comqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix.
</pre>
<li><a href=cortb.f.html> cortb </a>
<pre>
Form the eigenvectors of a complex general matrix from
eigenvectors of upper Hessenberg matrix output from
CORTH.
</pre>
<li><a href=corth.f.html> corth </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using unitary similarity transformations.
</pre>
<li><a href=eisdoc.f.html> eisdoc </a>
<pre>
Documentation for EISPACK, a collection of subprograms for
solving matrix eigen-problems.
</pre>
<li><a href=elmbak.f.html> elmbak </a>
<pre>
Form the eigenvectors of a real general matrix from the
eigenvectors of the upper Hessenberg matrix output from
ELMHES.
</pre>
<li><a href=elmhes.f.html> elmhes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using stabilized elementary similarity transformations.
</pre>
<li><a href=eltran.f.html> eltran </a>
<pre>
Accumulates the stabilized elementary similarity
transformations used in the reduction of a real general
matrix to upper Hessenberg form by ELMHES.
</pre>
<li><a href=figi.f.html> figi </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=figi2.f.html> figi2 </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=hqr.f.html> hqr </a>
<pre>
Compute the eigenvalues of a real upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=hqr2.f.html> hqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a real upper
Hessenberg matrix using QR method.
</pre>
<li><a href=htrib3.f.html> htrib3 </a>
<pre>
Compute the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRID3.
</pre>
<li><a href=htribk.f.html> htribk </a>
<pre>
Form the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRIDI.
</pre>
<li><a href=htrid3.f.html> htrid3 </a>
<pre>
Reduce a complex Hermitian (packed) matrix to a real
symmetric tridiagonal matrix by unitary similarity
transformations.
</pre>
<li><a href=htridi.f.html> htridi </a>
<pre>
Reduce a complex Hermitian matrix to a real symmetric
tridiagonal matrix using unitary similarity
transformations.
</pre>
<li><a href=imtql1.f.html> imtql1 </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.
</pre>
<li><a href=imtql2.f.html> imtql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a symmetric
tridiagonal matrix using the implicit QL method.
</pre>
<li><a href=imtqlv.f.html> imtqlv </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.  Eigenvectors may be computed
later.
</pre>
<li><a href=invit.f.html> invit </a>
<pre>
Compute the eigenvectors of a real upper Hessenberg
matrix associated with specified eigenvalues by inverse
iteration.
</pre>
<li><a href=minfit.f.html> minfit </a>
<pre>
Compute the singular value decomposition of a rectangular
matrix and solve the related linear least squares problem.
</pre>
<li><a href=ortbak.f.html> ortbak </a>
<pre>
Form the eigenvectors of a general real matrix from the
eigenvectors of the upper Hessenberg matrix output from
ORTHES.
</pre>
<li><a href=orthes.f.html> orthes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using orthogonal similarity transformations.
</pre>
<li><a href=ortran.f.html> ortran </a>
<pre>
Accumulate orthogonal similarity transformations in the
reduction of real general matrix by ORTHES.
</pre>
<li><a href=qzhes.f.html> qzhes </a>
<pre>
The first step of the QZ algorithm for solving generalized
matrix eigenproblems.  Accepts a pair of real general
matrices and reduces one of them to upper Hessenberg
and the other to upper triangular form using orthogonal
transformations. Usually followed by QZIT, QZVAL, QZVEC.
</pre>
<li><a href=qzit.f.html> qzit </a>
<pre>
The second step of the QZ algorithm for generalized
eigenproblems.  Accepts an upper Hessenberg and an upper
triangular matrix and reduces the former to
quasi-triangular form while preserving the form of the
latter.  Usually preceded by QZHES and followed by QZVAL
and QZVEC.
</pre>
<li><a href=qzval.f.html> qzval </a>
<pre>
The third step of the QZ algorithm for generalized
eigenproblems.  Accepts a pair of real matrices, one in
quasi-triangular form and the other in upper triangular
form and computes the eigenvalues of the associated
eigenproblem.  Usually preceded by QZHES, QZIT, and
followed by QZVEC.
</pre>
<li><a href=qzvec.f.html> qzvec </a>
<pre>
The optional fourth step of the QZ algorithm for
generalized eigenproblems.  Accepts a matrix in
quasi-triangular form and another in upper triangular
and computes the eigenvectors of the triangular problem
and transforms them back to the original coordinates
Usually preceded by QZHES, QZIT, and QZVAL.
</pre>
<li><a href=ratqr.f.html> ratqr </a>
<pre>
Compute the largest or smallest eigenvalues of a symmetric
tridiagonal matrix using the rational QR method with Newton
correction.
</pre>
<li><a href=rebak.f.html> rebak </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC or REDUC2.
</pre>
<li><a href=rebakb.f.html> rebakb </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC2.
</pre>
<li><a href=reduc.f.html> reduc </a>
<pre>
Reduce a generalized symmetric eigenproblem to a standard
symmetric eigenproblem using Cholesky factorization.
</pre>
<li><a href=reduc2.f.html> reduc2 </a>
<pre>
Reduce a certain generalized symmetric eigenproblem to a
standard symmetric eigenproblem using Cholesky
factorization.
</pre>
<li><a href=rg.f.html> rg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=rgg.f.html> rgg </a>
<pre>
Compute the eigenvalues and eigenvectors for a real
generalized eigenproblem.
</pre>
<li><a href=rs.f.html> rs </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=rsb.f.html> rsb </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric band matrix.
</pre>
<li><a href=rsg.f.html> rsg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgab.f.html> rsgab </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgba.f.html> rsgba </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsp.f.html> rsp </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix packed into a one dimensional
array.
</pre>
<li><a href=rst.f.html> rst </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric tridiagonal matrix.
</pre>
<li><a href=rt.f.html> rt </a>
<pre>
Compute the eigenvalues and eigenvectors of a special real
tridiagonal matrix.
</pre>
<li><a href=sgeev.f.html> sgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=ssiev.f.html> ssiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=sspev.f.html> sspev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix stored in packed form.
</pre>
<li><a href=tinvit.f.html> tinvit </a>
<pre>
Compute the eigenvectors of symmetric tridiagonal matrix
corresponding to specified eigenvalues, using inverse
iteration.
</pre>
<li><a href=tql2.f.html> tql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of symmetric
tridiagonal matrix.
</pre>
<li><a href=tred1.f.html> tred1 </a>
<pre>
Reduce a real symmetric matrix to symmetric tridiagonal
matrix using orthogonal similarity transformations.
</pre>
<li><a href=tred2.f.html> tred2 </a>
<pre>
Reduce a real symmetric matrix to a symmetric tridiagonal
matrix using and accumulating orthogonal transformations.
</pre>
<li><a href=tred3.f.html> tred3 </a>
<pre>
Reduce a real symmetric matrix stored in packed form to
symmetric tridiagonal matrix using orthogonal
transformations.
</pre>
<li><a href=tsturm.f.html> tsturm </a>
<pre>
Find those eigenvalues of a symmetric tridiagonal matrix
in a given interval and their associated eigenvectors by
Sturm sequencing.
</pre>
</ul>
<h3> <a name="EIGENVECTORS_OF_A_REAL_SYMMETRIC_MATRIX"> EIGENVECTORS OF A REAL SYMMETRIC MATRIX </a> </h3>
<ul>
<li><a href=trbak1.f.html> trbak1 </a>
<pre>
Form the eigenvectors of real symmetric matrix from
the eigenvectors of a symmetric tridiagonal matrix formed
by TRED1.
</pre>
<li><a href=trbak3.f.html> trbak3 </a>
<pre>
Form the eigenvectors of a real symmetric matrix from the
eigenvectors of a symmetric tridiagonal matrix formed
by TRED3.
</pre>
</ul>
<h3> <a name="EISPACK"> EISPACK </a> </h3>
<ul>
<li><a href=bakvec.f.html> bakvec </a>
<pre>
Form the eigenvectors of a certain real non-symmetric
tridiagonal matrix from a symmetric tridiagonal matrix
output from FIGI.
</pre>
<li><a href=balanc.f.html> balanc </a>
<pre>
Balance a real general matrix and isolate eigenvalues
whenever possible.
</pre>
<li><a href=balbak.f.html> balbak </a>
<pre>
Form the eigenvectors of a real general matrix from the
eigenvectors of matrix output from BALANC.
</pre>
<li><a href=bandr.f.html> bandr </a>
<pre>
Reduce a real symmetric band matrix to symmetric
tridiagonal matrix and, optionally, accumulate
orthogonal similarity transformations.
</pre>
<li><a href=bandv.f.html> bandv </a>
<pre>
Form the eigenvectors of a real symmetric band matrix
associated with a set of ordered approximate eigenvalues
by inverse iteration.
</pre>
<li><a href=bisect.f.html> bisect </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
in a given interval using Sturm sequencing.
</pre>
<li><a href=bqr.f.html> bqr </a>
<pre>
Compute some of the eigenvalues of a real symmetric
matrix using the QR method with shifts of origin.
</pre>
<li><a href=cbabk2.f.html> cbabk2 </a>
<pre>
Form the eigenvectors of a complex general matrix from the
eigenvectors of matrix output from CBAL.
</pre>
<li><a href=cbal.f.html> cbal </a>
<pre>
Balance a complex general matrix and isolate eigenvalues
whenever possible.
</pre>
<li><a href=cg.f.html> cg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=ch.f.html> ch </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cinvit.f.html> cinvit </a>
<pre>
Compute the eigenvectors of a complex upper Hessenberg
associated with specified eigenvalues using inverse
iteration.
</pre>
<li><a href=combak.f.html> combak </a>
<pre>
Form the eigenvectors of a complex general matrix from the
eigenvectors of a upper Hessenberg matrix output from
COMHES.
</pre>
<li><a href=comhes.f.html> comhes </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using stabilized elementary similarity
transformations.
</pre>
<li><a href=comlr.f.html> comlr </a>
<pre>
Compute the eigenvalues of a complex upper Hessenberg
matrix using the modified LR method.
</pre>
<li><a href=comlr2.f.html> comlr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix using the modified LR method.
</pre>
<li><a href=comqr.f.html> comqr </a>
<pre>
Compute the eigenvalues of complex upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=comqr2.f.html> comqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix.
</pre>
<li><a href=cortb.f.html> cortb </a>
<pre>
Form the eigenvectors of a complex general matrix from
eigenvectors of upper Hessenberg matrix output from
CORTH.
</pre>
<li><a href=corth.f.html> corth </a>
<pre>
Reduce a complex general matrix to complex upper Hessenberg
form using unitary similarity transformations.
</pre>
<li><a href=eisdoc.f.html> eisdoc </a>
<pre>
Documentation for EISPACK, a collection of subprograms for
solving matrix eigen-problems.
</pre>
<li><a href=elmbak.f.html> elmbak </a>
<pre>
Form the eigenvectors of a real general matrix from the
eigenvectors of the upper Hessenberg matrix output from
ELMHES.
</pre>
<li><a href=elmhes.f.html> elmhes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using stabilized elementary similarity transformations.
</pre>
<li><a href=eltran.f.html> eltran </a>
<pre>
Accumulates the stabilized elementary similarity
transformations used in the reduction of a real general
matrix to upper Hessenberg form by ELMHES.
</pre>
<li><a href=figi.f.html> figi </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=figi2.f.html> figi2 </a>
<pre>
Transforms certain real non-symmetric tridiagonal matrix
to symmetric tridiagonal matrix.
</pre>
<li><a href=hqr.f.html> hqr </a>
<pre>
Compute the eigenvalues of a real upper Hessenberg matrix
using the QR method.
</pre>
<li><a href=hqr2.f.html> hqr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a real upper
Hessenberg matrix using QR method.
</pre>
<li><a href=htrib3.f.html> htrib3 </a>
<pre>
Compute the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRID3.
</pre>
<li><a href=htribk.f.html> htribk </a>
<pre>
Form the eigenvectors of a complex Hermitian matrix from
the eigenvectors of a real symmetric tridiagonal matrix
output from HTRIDI.
</pre>
<li><a href=htrid3.f.html> htrid3 </a>
<pre>
Reduce a complex Hermitian (packed) matrix to a real
symmetric tridiagonal matrix by unitary similarity
transformations.
</pre>
<li><a href=htridi.f.html> htridi </a>
<pre>
Reduce a complex Hermitian matrix to a real symmetric
tridiagonal matrix using unitary similarity
transformations.
</pre>
<li><a href=imtql1.f.html> imtql1 </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.
</pre>
<li><a href=imtql2.f.html> imtql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a symmetric
tridiagonal matrix using the implicit QL method.
</pre>
<li><a href=imtqlv.f.html> imtqlv </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
using the implicit QL method.  Eigenvectors may be computed
later.
</pre>
<li><a href=invit.f.html> invit </a>
<pre>
Compute the eigenvectors of a real upper Hessenberg
matrix associated with specified eigenvalues by inverse
iteration.
</pre>
<li><a href=minfit.f.html> minfit </a>
<pre>
Compute the singular value decomposition of a rectangular
matrix and solve the related linear least squares problem.
</pre>
<li><a href=ortbak.f.html> ortbak </a>
<pre>
Form the eigenvectors of a general real matrix from the
eigenvectors of the upper Hessenberg matrix output from
ORTHES.
</pre>
<li><a href=orthes.f.html> orthes </a>
<pre>
Reduce a real general matrix to upper Hessenberg form
using orthogonal similarity transformations.
</pre>
<li><a href=ortran.f.html> ortran </a>
<pre>
Accumulate orthogonal similarity transformations in the
reduction of real general matrix by ORTHES.
</pre>
<li><a href=qzhes.f.html> qzhes </a>
<pre>
The first step of the QZ algorithm for solving generalized
matrix eigenproblems.  Accepts a pair of real general
matrices and reduces one of them to upper Hessenberg
and the other to upper triangular form using orthogonal
transformations. Usually followed by QZIT, QZVAL, QZVEC.
</pre>
<li><a href=qzit.f.html> qzit </a>
<pre>
The second step of the QZ algorithm for generalized
eigenproblems.  Accepts an upper Hessenberg and an upper
triangular matrix and reduces the former to
quasi-triangular form while preserving the form of the
latter.  Usually preceded by QZHES and followed by QZVAL
and QZVEC.
</pre>
<li><a href=qzval.f.html> qzval </a>
<pre>
The third step of the QZ algorithm for generalized
eigenproblems.  Accepts a pair of real matrices, one in
quasi-triangular form and the other in upper triangular
form and computes the eigenvalues of the associated
eigenproblem.  Usually preceded by QZHES, QZIT, and
followed by QZVEC.
</pre>
<li><a href=qzvec.f.html> qzvec </a>
<pre>
The optional fourth step of the QZ algorithm for
generalized eigenproblems.  Accepts a matrix in
quasi-triangular form and another in upper triangular
and computes the eigenvectors of the triangular problem
and transforms them back to the original coordinates
Usually preceded by QZHES, QZIT, and QZVAL.
</pre>
<li><a href=ratqr.f.html> ratqr </a>
<pre>
Compute the largest or smallest eigenvalues of a symmetric
tridiagonal matrix using the rational QR method with Newton
correction.
</pre>
<li><a href=rebak.f.html> rebak </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC or REDUC2.
</pre>
<li><a href=rebakb.f.html> rebakb </a>
<pre>
Form the eigenvectors of a generalized symmetric
eigensystem from the eigenvectors of derived matrix output
from REDUC2.
</pre>
<li><a href=reduc.f.html> reduc </a>
<pre>
Reduce a generalized symmetric eigenproblem to a standard
symmetric eigenproblem using Cholesky factorization.
</pre>
<li><a href=reduc2.f.html> reduc2 </a>
<pre>
Reduce a certain generalized symmetric eigenproblem to a
standard symmetric eigenproblem using Cholesky
factorization.
</pre>
<li><a href=rg.f.html> rg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=rgg.f.html> rgg </a>
<pre>
Compute the eigenvalues and eigenvectors for a real
generalized eigenproblem.
</pre>
<li><a href=rs.f.html> rs </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=rsb.f.html> rsb </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric band matrix.
</pre>
<li><a href=rsg.f.html> rsg </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgab.f.html> rsgab </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsgba.f.html> rsgba </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a symmetric generalized eigenproblem.
</pre>
<li><a href=rsp.f.html> rsp </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix packed into a one dimensional
array.
</pre>
<li><a href=rst.f.html> rst </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric tridiagonal matrix.
</pre>
<li><a href=rt.f.html> rt </a>
<pre>
Compute the eigenvalues and eigenvectors of a special real
tridiagonal matrix.
</pre>
<li><a href=sspev.f.html> sspev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix stored in packed form.
</pre>
<li><a href=tinvit.f.html> tinvit </a>
<pre>
Compute the eigenvectors of symmetric tridiagonal matrix
corresponding to specified eigenvalues, using inverse
iteration.
</pre>
<li><a href=tql1.f.html> tql1 </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix by
the QL method.
</pre>
<li><a href=tql2.f.html> tql2 </a>
<pre>
Compute the eigenvalues and eigenvectors of symmetric
tridiagonal matrix.
</pre>
<li><a href=tqlrat.f.html> tqlrat </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix
using a rational variant of the QL method.
</pre>
<li><a href=trbak1.f.html> trbak1 </a>
<pre>
Form the eigenvectors of real symmetric matrix from
the eigenvectors of a symmetric tridiagonal matrix formed
by TRED1.
</pre>
<li><a href=trbak3.f.html> trbak3 </a>
<pre>
Form the eigenvectors of a real symmetric matrix from the
eigenvectors of a symmetric tridiagonal matrix formed
by TRED3.
</pre>
<li><a href=tred1.f.html> tred1 </a>
<pre>
Reduce a real symmetric matrix to symmetric tridiagonal
matrix using orthogonal similarity transformations.
</pre>
<li><a href=tred2.f.html> tred2 </a>
<pre>
Reduce a real symmetric matrix to a symmetric tridiagonal
matrix using and accumulating orthogonal transformations.
</pre>
<li><a href=tred3.f.html> tred3 </a>
<pre>
Reduce a real symmetric matrix stored in packed form to
symmetric tridiagonal matrix using orthogonal
transformations.
</pre>
<li><a href=tridib.f.html> tridib </a>
<pre>
Compute the eigenvalues of a symmetric tridiagonal matrix
in a given interval using Sturm sequencing.
</pre>
<li><a href=tsturm.f.html> tsturm </a>
<pre>
Find those eigenvalues of a symmetric tridiagonal matrix
in a given interval and their associated eigenvectors by
Sturm sequencing.
</pre>
</ul>
<h3> <a name="ELEMENTARY_FUNCTIONS"> ELEMENTARY FUNCTIONS </a> </h3>
<ul>
<li><a href=acosh.f.html> acosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=alnrel.f.html> alnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=asinh.f.html> asinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=atanh.f.html> atanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=c9ln2r.f.html> c9ln2r </a>
<pre>
Evaluate LOG(1+Z) from second order relative accuracy so
that  LOG(1+Z) = Z - Z**2/2 + Z**3*C9LN2R(Z).
</pre>
<li><a href=cacos.f.html> cacos </a>
<pre>
Compute the complex arc cosine.
</pre>
<li><a href=cacosh.f.html> cacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=carg.f.html> carg </a>
<pre>
Compute the argument of a complex number.
</pre>
<li><a href=casin.f.html> casin </a>
<pre>
Compute the complex arc sine.
</pre>
<li><a href=casinh.f.html> casinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=catan.f.html> catan </a>
<pre>
Compute the complex arc tangent.
</pre>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
<li><a href=catanh.f.html> catanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=cbrt.f.html> cbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccbrt.f.html> ccbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccosh.f.html> ccosh </a>
<pre>
Compute the complex hyperbolic cosine.
</pre>
<li><a href=ccot.f.html> ccot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=cexprl.f.html> cexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=clnrel.f.html> clnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=clog10.f.html> clog10 </a>
<pre>
Compute the principal value of the complex base 10
logarithm.
</pre>
<li><a href=cosdg.f.html> cosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=cot.f.html> cot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=csinh.f.html> csinh </a>
<pre>
Compute the complex hyperbolic sine.
</pre>
<li><a href=ctan.f.html> ctan </a>
<pre>
Compute the complex tangent.
</pre>
<li><a href=ctanh.f.html> ctanh </a>
<pre>
Compute the complex hyperbolic tangent.
</pre>
<li><a href=d9atn1.f.html> d9atn1 </a>
<pre>
Evaluate DATAN(X) from first order relative accuracy so
that DATAN(X) = X + X**3*D9ATN1(X).
</pre>
<li><a href=d9ln2r.f.html> d9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*D9LN2R(X)
</pre>
<li><a href=dacosh.f.html> dacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=dasinh.f.html> dasinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=datanh.f.html> datanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=dcbrt.f.html> dcbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=dcosdg.f.html> dcosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dcot.f.html> dcot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=dexprl.f.html> dexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=dlnrel.f.html> dlnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=drc.f.html> drc </a>
<pre>
Calculate a double precision approximation to
 DRC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=dsindg.f.html> dsindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=exprel.f.html> exprel </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=fundoc.f.html> fundoc </a>
<pre>
Documentation for FNLIB, a collection of routines for
evaluating elementary and special functions.
</pre>
<li><a href=r9atn1.f.html> r9atn1 </a>
<pre>
Evaluate ATAN(X) from first order relative accuracy so that
ATAN(X) = X + X**3*R9ATN1(X).
</pre>
<li><a href=r9ln2r.f.html> r9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*R9LN2R(X).
</pre>
<li><a href=rc.f.html> rc </a>
<pre>
Calculate an approximation to
 RC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=sindg.f.html> sindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
</ul>
<h3> <a name="ELLIPTIC"> ELLIPTIC </a> </h3>
<ul>
<li><a href=genbun.f.html> genbun </a>
<pre>
Solve by a cyclic reduction algorithm the linear system
of equations that results from a finite difference
approximation to certain 2-d elliptic PDE's on a centered
grid .
</pre>
<li><a href=hstcrt.f.html> hstcrt </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in Cartesian coordinates.
</pre>
<li><a href=hstcsp.f.html> hstcsp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified Helmholtz
equation in spherical coordinates assuming axisymmetry
(no dependence on longitude).
</pre>
<li><a href=hstcyl.f.html> hstcyl </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified
Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hstplr.f.html> hstplr </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in polar coordinates.
</pre>
<li><a href=hstssp.f.html> hstssp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz
equation in spherical coordinates and on the surface of
the unit sphere (radius of 1).
</pre>
<li><a href=hw3crt.f.html> hw3crt </a>
<pre>
Solve the standard seven-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscrt.f.html> hwscrt </a>
<pre>
Solves the standard five-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscsp.f.html> hwscsp </a>
<pre>
Solve a finite difference approximation to the modified
Helmholtz equation in spherical coordinates assuming
axisymmetry  (no dependence on longitude).
</pre>
<li><a href=hwscyl.f.html> hwscyl </a>
<pre>
Solve a standard finite difference approximation
to the Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hwsplr.f.html> hwsplr </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in polar coordinates.
</pre>
<li><a href=hwsssp.f.html> hwsssp </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in spherical coordinates and on the surface of the
unit sphere (radius of 1).
</pre>
<li><a href=poistg.f.html> poistg </a>
<pre>
Solve a block tridiagonal system of linear equations
that results from a staggered grid finite difference
approximation to 2-D elliptic PDE's.
</pre>
<li><a href=sepeli.f.html> sepeli </a>
<pre>
Discretize and solve a second and, optionally, a fourth
order finite difference approximation on a uniform grid to
the general separable elliptic partial differential
equation on a rectangle with any combination of periodic or
mixed boundary conditions.
</pre>
<li><a href=sepx4.f.html> sepx4 </a>
<pre>
Solve for either the second or fourth order finite
difference approximation to the solution of a separable
elliptic partial differential equation on a rectangle.
Any combination of periodic or mixed boundary conditions is
allowed.
</pre>
</ul>
<h3> <a name="ELLIPTIC_INTEGRAL"> ELLIPTIC INTEGRAL </a> </h3>
<ul>
<li><a href=drc.f.html> drc </a>
<pre>
Calculate a double precision approximation to
 DRC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=rc.f.html> rc </a>
<pre>
Calculate an approximation to
 RC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
</ul>
<h3> <a name="ELLIPTIC_PDE"> ELLIPTIC PDE </a> </h3>
<ul>
<li><a href=blktri.f.html> blktri </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cblktr.f.html> cblktr </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cmgnbn.f.html> cmgnbn </a>
<pre>
Solve a complex block tridiagonal linear system of
equations by a cyclic reduction algorithm.
</pre>
<li><a href=pois3d.f.html> pois3d </a>
<pre>
Solve a three-dimensional block tridiagonal linear system
which arises from a finite difference approximation to a
three-dimensional Poisson equation using the Fourier
transform package FFTPAK written by Paul Swarztrauber.
</pre>
</ul>
<h3> <a name="END_POINT_SINGULARITIES"> END POINT SINGULARITIES </a> </h3>
<ul>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqwgts.f.html> dqwgts </a>
<pre>
This function subprogram is used together with the
routine DQAWS and defines the WEIGHT function.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qwgts.f.html> qwgts </a>
<pre>
This function subprogram is used together with the
routine QAWS and defines the WEIGHT function.
</pre>
</ul>
<h3> <a name="EPSILON_ALGORITHM"> EPSILON ALGORITHM </a> </h3>
<ul>
<li><a href=dqelg.f.html> dqelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P.Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
<li><a href=qelg.f.html> qelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P. Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
</ul>
<h3> <a name="EQUALITY_CONSTRAINTS"> EQUALITY CONSTRAINTS </a> </h3>
<ul>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="ERF"> ERF </a> </h3>
<ul>
<li><a href=derf.f.html> derf </a>
<pre>
Compute the error function.
</pre>
<li><a href=erf.f.html> erf </a>
<pre>
Compute the error function.
</pre>
</ul>
<h3> <a name="ERFC"> ERFC </a> </h3>
<ul>
<li><a href=derfc.f.html> derfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=erfc.f.html> erfc </a>
<pre>
Compute the complementary error function.
</pre>
</ul>
<h3> <a name="ERROR"> ERROR </a> </h3>
<ul>
<li><a href=fdump.f.html> fdump </a>
<pre>
Symbolic dump (should be locally written).
</pre>
<li><a href=xerclr.f.html> xerclr </a>
<pre>
Reset current error number to zero.
</pre>
<li><a href=xercnt.f.html> xercnt </a>
<pre>
Allow user control over handling of errors.
</pre>
<li><a href=xerdmp.f.html> xerdmp </a>
<pre>
Print the error tables and then clear them.
</pre>
<li><a href=xerhlt.f.html> xerhlt </a>
<pre>
Abort program execution and print error message.
</pre>
<li><a href=xermax.f.html> xermax </a>
<pre>
Set maximum number of times any error message is to be
printed.
</pre>
<li><a href=xersve.f.html> xersve </a>
<pre>
Record that an error has occurred.
</pre>
<li><a href=xgetf.f.html> xgetf </a>
<pre>
Return the current value of the error control flag.
</pre>
<li><a href=xgetua.f.html> xgetua </a>
<pre>
Return unit number(s) to which error messages are being
sent.
</pre>
<li><a href=xgetun.f.html> xgetun </a>
<pre>
Return the (first) output file to which error messages
are being sent.
</pre>
<li><a href=xsetf.f.html> xsetf </a>
<pre>
Set the error control flag.
</pre>
<li><a href=xsetua.f.html> xsetua </a>
<pre>
Set logical unit numbers (up to 5) to which error
messages are to be sent.
</pre>
<li><a href=xsetun.f.html> xsetun </a>
<pre>
Set output file to which error messages are to be sent.
</pre>
</ul>
<h3> <a name="ERROR_CHECKING"> ERROR CHECKING </a> </h3>
<ul>
<li><a href=dchkw.f.html> dchkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
<li><a href=schkw.f.html> schkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
</ul>
<h3> <a name="ERROR_FUNCTION"> ERROR FUNCTION </a> </h3>
<ul>
<li><a href=derf.f.html> derf </a>
<pre>
Compute the error function.
</pre>
<li><a href=erf.f.html> erf </a>
<pre>
Compute the error function.
</pre>
</ul>
<h3> <a name="ERROR_MESSAGE"> ERROR MESSAGE </a> </h3>
<ul>
<li><a href=xerbla.f.html> xerbla </a>
<pre>
Error handler for the Level 2 and Level 3 BLAS Routines.
</pre>
<li><a href=xermsg.f.html> xermsg </a>
<pre>
Process error messages for SLATEC and other libraries.
</pre>
</ul>
<h3> <a name="ERROR_MESSAGES"> ERROR MESSAGES </a> </h3>
<ul>
<li><a href=j4save.f.html> j4save </a>
<pre>
Save or recall global variables needed by error
handling routines.
</pre>
<li><a href=xerprn.f.html> xerprn </a>
<pre>
Print error messages processed by XERMSG.
</pre>
</ul>
<h3> <a name="ERROR_NUMBER"> ERROR NUMBER </a> </h3>
<ul>
<li><a href=j4save.f.html> j4save </a>
<pre>
Save or recall global variables needed by error
handling routines.
</pre>
<li><a href=numxer.f.html> numxer </a>
<pre>
Return the most recent error number.
</pre>
</ul>
<h3> <a name="EUCLIDEAN_LENGTH"> EUCLIDEAN LENGTH </a> </h3>
<ul>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
</ul>
<h3> <a name="EUCLIDEAN_NORM"> EUCLIDEAN NORM </a> </h3>
<ul>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
</ul>
<h3> <a name="EVALUATION_OF_B-SPLINE"> EVALUATION OF B-SPLINE </a> </h3>
<ul>
<li><a href=bspvd.f.html> bspvd </a>
<pre>
Calculate the value and all derivatives of order less than
NDERIV of all basis functions which do not vanish at X.
</pre>
<li><a href=bspvn.f.html> bspvn </a>
<pre>
Calculate the value of all (possibly) nonzero basis
functions at X.
</pre>
<li><a href=bvalu.f.html> bvalu </a>
<pre>
Evaluate the B-representation of a B-spline at X for the
function value or any of its derivatives.
</pre>
<li><a href=dbspvd.f.html> dbspvd </a>
<pre>
Calculate the value and all derivatives of order less than
NDERIV of all basis functions which do not vanish at X.
</pre>
<li><a href=dbspvn.f.html> dbspvn </a>
<pre>
Calculate the value of all (possibly) nonzero basis
functions at X.
</pre>
<li><a href=dbvalu.f.html> dbvalu </a>
<pre>
Evaluate the B-representation of a B-spline at X for the
function value or any of its derivatives.
</pre>
</ul>
<h3> <a name="EXCHANGE"> EXCHANGE </a> </h3>
<ul>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
</ul>
<h3> <a name="EXPONENTIAL"> EXPONENTIAL </a> </h3>
<ul>
<li><a href=cexprl.f.html> cexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=dexprl.f.html> dexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=exprel.f.html> exprel </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
</ul>
<h3> <a name="EXPONENTIAL_INTEGRAL"> EXPONENTIAL INTEGRAL </a> </h3>
<ul>
<li><a href=bskin.f.html> bskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
<li><a href=dbskin.f.html> dbskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
<li><a href=de1.f.html> de1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=dei.f.html> dei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=dexint.f.html> dexint </a>
<pre>
Compute an M member sequence of exponential integrals
E(N+K,X), K=0,1,...,M-1 for N .GE. 1 and X .GE. 0.
</pre>
<li><a href=e1.f.html> e1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=ei.f.html> ei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=exint.f.html> exint </a>
<pre>
Compute an M member sequence of exponential integrals
E(N+K,X), K=0,1,...,M-1 for N .GE. 1 and X .GE. 0.
</pre>
</ul>
<h3> <a name="EXPONENTIALLY_SCALED"> EXPONENTIALLY SCALED </a> </h3>
<ul>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=bie.f.html> bie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=dbie.f.html> dbie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
</ul>
<h3> <a name="EXPONENTIALLY_SCALED_AIRY_FUNCTION"> EXPONENTIALLY SCALED AIRY FUNCTION </a> </h3>
<ul>
<li><a href=aie.f.html> aie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
<li><a href=daie.f.html> daie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
</ul>
<h3> <a name="EXTENDED-RANGE_DOUBLE-PRECISION_ARITHMETIC"> EXTENDED-RANGE DOUBLE-PRECISION ARITHMETIC </a> </h3>
<ul>
<li><a href=dxadd.f.html> dxadd </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=dxadj.f.html> dxadj </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=dxc210.f.html> dxc210 </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=dxcon.f.html> dxcon </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=dxred.f.html> dxred </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=dxset.f.html> dxset </a>
<pre>
To provide double-precision floating-point arithmetic
with an extended exponent range.
</pre>
</ul>
<h3> <a name="EXTENDED-RANGE_SINGLE-PRECISION_ARITHMETIC"> EXTENDED-RANGE SINGLE-PRECISION ARITHMETIC </a> </h3>
<ul>
<li><a href=xadd.f.html> xadd </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=xadj.f.html> xadj </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=xc210.f.html> xc210 </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=xcon.f.html> xcon </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=xred.f.html> xred </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
<li><a href=xset.f.html> xset </a>
<pre>
To provide single-precision floating-point arithmetic
with an extended exponent range.
</pre>
</ul>
<h3> <a name="EXTRAPOLATION"> EXTRAPOLATION </a> </h3>
<ul>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqelg.f.html> dqelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P.Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qelg.f.html> qelg </a>
<pre>
The routine determines the limit of a given sequence of
approximations, by means of the Epsilon algorithm of
P. Wynn. An estimate of the absolute error is also given.
The condensed Epsilon table is computed. Only those
elements needed for the computation of the next diagonal
are preserved.
</pre>
</ul>
<h3> <a name="FACTORIAL"> FACTORIAL </a> </h3>
<ul>
<li><a href=dfac.f.html> dfac </a>
<pre>
Compute the factorial function.
</pre>
<li><a href=fac.f.html> fac </a>
<pre>
Compute the factorial function.
</pre>
</ul>
<h3> <a name="FAST_FOURIER_TRANSFORM"> FAST FOURIER TRANSFORM </a> </h3>
<ul>
<li><a href=dqcheb.f.html> dqcheb </a>
<pre>
This routine computes the CHEBYSHEV series expansion
of degrees 12 and 24 of a function using A
FAST FOURIER TRANSFORM METHOD
F(X) = SUM(K=1,..,13) (CHEB12(K)*T(K-1,X)),
F(X) = SUM(K=1,..,25) (CHEB24(K)*T(K-1,X)),
Where T(K,X) is the CHEBYSHEV POLYNOMIAL OF DEGREE K.
</pre>
<li><a href=fftdoc.f.html> fftdoc </a>
<pre>
Documentation for FFTPACK, a collection of Fast Fourier
Transform routines.
</pre>
<li><a href=qcheb.f.html> qcheb </a>
<pre>
This routine computes the CHEBYSHEV series expansion
of degrees 12 and 24 of a function using A
FAST FOURIER TRANSFORM METHOD
F(X) = SUM(K=1,..,13) (CHEB12(K)*T(K-1,X)),
F(X) = SUM(K=1,..,25) (CHEB24(K)*T(K-1,X)),
Where T(K,X) is the CHEBYSHEV POLYNOMIAL OF DEGREE K.
</pre>
</ul>
<h3> <a name="FFT"> FFT </a> </h3>
<ul>
<li><a href=fftdoc.f.html> fftdoc </a>
<pre>
Documentation for FFTPACK, a collection of Fast Fourier
Transform routines.
</pre>
</ul>
<h3> <a name="FFTPACK"> FFTPACK </a> </h3>
<ul>
<li><a href=cfftb.f.html> cfftb </a>
<pre>
Compute the unnormalized inverse of CFFTF.
</pre>
<li><a href=cfftb1.f.html> cfftb1 </a>
<pre>
Compute the unnormalized inverse of CFFTF1.
</pre>
<li><a href=cfftf.f.html> cfftf </a>
<pre>
Compute the forward transform of a complex, periodic
sequence.
</pre>
<li><a href=cfftf1.f.html> cfftf1 </a>
<pre>
Compute the forward transform of a complex, periodic
sequence.
</pre>
<li><a href=cffti.f.html> cffti </a>
<pre>
Initialize a work array for CFFTF and CFFTB.
</pre>
<li><a href=cffti1.f.html> cffti1 </a>
<pre>
Initialize a real and an integer work array for CFFTF1 and
CFFTB1.
</pre>
<li><a href=cosqb.f.html> cosqb </a>
<pre>
Compute the unnormalized inverse cosine transform.
</pre>
<li><a href=cosqb1.f.html> cosqb1 </a>
<pre>
Compute the unnormalized inverse of COSQF1.
</pre>
<li><a href=cosqf.f.html> cosqf </a>
<pre>
Compute the forward cosine transform with odd wave numbers.
</pre>
<li><a href=cosqf1.f.html> cosqf1 </a>
<pre>
Compute the forward cosine transform with odd wave numbers.
</pre>
<li><a href=cosqi.f.html> cosqi </a>
<pre>
Initialize a work array for COSQF and COSQB.
</pre>
<li><a href=cost.f.html> cost </a>
<pre>
Compute the cosine transform of a real, even sequence.
</pre>
<li><a href=costi.f.html> costi </a>
<pre>
Initialize a work array for COST.
</pre>
<li><a href=ezfftb.f.html> ezfftb </a>
<pre>
A simplified real, periodic, backward fast Fourier
transform.
</pre>
<li><a href=ezfftf.f.html> ezfftf </a>
<pre>
Compute a simplified real, periodic, fast Fourier forward
transform.
</pre>
<li><a href=ezffti.f.html> ezffti </a>
<pre>
Initialize a work array for EZFFTF and EZFFTB.
</pre>
<li><a href=rfftb.f.html> rfftb </a>
<pre>
Compute the backward fast Fourier transform of a real
coefficient array.
</pre>
<li><a href=rfftb1.f.html> rfftb1 </a>
<pre>
Compute the backward fast Fourier transform of a real
coefficient array.
</pre>
<li><a href=rfftf.f.html> rfftf </a>
<pre>
Compute the forward transform of a real, periodic sequence.
</pre>
<li><a href=rfftf1.f.html> rfftf1 </a>
<pre>
Compute the forward transform of a real, periodic sequence.
</pre>
<li><a href=rffti.f.html> rffti </a>
<pre>
Initialize a work array for RFFTF and RFFTB.
</pre>
<li><a href=rffti1.f.html> rffti1 </a>
<pre>
Initialize a real and an integer work array for RFFTF1 and
RFFTB1.
</pre>
<li><a href=sinqb.f.html> sinqb </a>
<pre>
Compute the unnormalized inverse of SINQF.
</pre>
<li><a href=sinqf.f.html> sinqf </a>
<pre>
Compute the forward sine transform with odd wave numbers.
</pre>
<li><a href=sinqi.f.html> sinqi </a>
<pre>
Initialize a work array for SINQF and SINQB.
</pre>
<li><a href=sint.f.html> sint </a>
<pre>
Compute the sine transform of a real, odd sequence.
</pre>
<li><a href=sinti.f.html> sinti </a>
<pre>
Initialize a work array for SINT.
</pre>
</ul>
<h3> <a name="FIRST_KIND"> FIRST KIND </a> </h3>
<ul>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besj0.f.html> besj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=besj1.f.html> besj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesj0.f.html> dbesj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=dbesj1.f.html> dbesj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
</ul>
<h3> <a name="FIRST_ORDER"> FIRST ORDER </a> </h3>
<ul>
<li><a href=cexprl.f.html> cexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=d9atn1.f.html> d9atn1 </a>
<pre>
Evaluate DATAN(X) from first order relative accuracy so
that DATAN(X) = X + X**3*D9ATN1(X).
</pre>
<li><a href=dexprl.f.html> dexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=dpoch1.f.html> dpoch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=exprel.f.html> exprel </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=poch1.f.html> poch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=r9atn1.f.html> r9atn1 </a>
<pre>
Evaluate ATAN(X) from first order relative accuracy so that
ATAN(X) = X + X**3*R9ATN1(X).
</pre>
</ul>
<h3> <a name="FISHPACK"> FISHPACK </a> </h3>
<ul>
<li><a href=blktri.f.html> blktri </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cblktr.f.html> cblktr </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cmgnbn.f.html> cmgnbn </a>
<pre>
Solve a complex block tridiagonal linear system of
equations by a cyclic reduction algorithm.
</pre>
<li><a href=genbun.f.html> genbun </a>
<pre>
Solve by a cyclic reduction algorithm the linear system
of equations that results from a finite difference
approximation to certain 2-d elliptic PDE's on a centered
grid .
</pre>
<li><a href=hstcrt.f.html> hstcrt </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in Cartesian coordinates.
</pre>
<li><a href=hstcsp.f.html> hstcsp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified Helmholtz
equation in spherical coordinates assuming axisymmetry
(no dependence on longitude).
</pre>
<li><a href=hstcyl.f.html> hstcyl </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified
Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hstplr.f.html> hstplr </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in polar coordinates.
</pre>
<li><a href=hstssp.f.html> hstssp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz
equation in spherical coordinates and on the surface of
the unit sphere (radius of 1).
</pre>
<li><a href=hw3crt.f.html> hw3crt </a>
<pre>
Solve the standard seven-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscrt.f.html> hwscrt </a>
<pre>
Solves the standard five-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscsp.f.html> hwscsp </a>
<pre>
Solve a finite difference approximation to the modified
Helmholtz equation in spherical coordinates assuming
axisymmetry  (no dependence on longitude).
</pre>
<li><a href=hwscyl.f.html> hwscyl </a>
<pre>
Solve a standard finite difference approximation
to the Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hwsplr.f.html> hwsplr </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in polar coordinates.
</pre>
<li><a href=hwsssp.f.html> hwsssp </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in spherical coordinates and on the surface of the
unit sphere (radius of 1).
</pre>
<li><a href=pois3d.f.html> pois3d </a>
<pre>
Solve a three-dimensional block tridiagonal linear system
which arises from a finite difference approximation to a
three-dimensional Poisson equation using the Fourier
transform package FFTPAK written by Paul Swarztrauber.
</pre>
<li><a href=poistg.f.html> poistg </a>
<pre>
Solve a block tridiagonal system of linear equations
that results from a staggered grid finite difference
approximation to 2-D elliptic PDE's.
</pre>
<li><a href=sepeli.f.html> sepeli </a>
<pre>
Discretize and solve a second and, optionally, a fourth
order finite difference approximation on a uniform grid to
the general separable elliptic partial differential
equation on a rectangle with any combination of periodic or
mixed boundary conditions.
</pre>
<li><a href=sepx4.f.html> sepx4 </a>
<pre>
Solve for either the second or fourth order finite
difference approximation to the solution of a separable
elliptic partial differential equation on a rectangle.
Any combination of periodic or mixed boundary conditions is
allowed.
</pre>
</ul>
<h3> <a name="FNLIB"> FNLIB </a> </h3>
<ul>
<li><a href=acosh.f.html> acosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=ai.f.html> ai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=aie.f.html> aie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
<li><a href=albeta.f.html> albeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=algams.f.html> algams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=ali.f.html> ali </a>
<pre>
Compute the logarithmic integral.
</pre>
<li><a href=alngam.f.html> alngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=alnrel.f.html> alnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=asinh.f.html> asinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=atanh.f.html> atanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besj0.f.html> besj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=besj1.f.html> besj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=besy0.f.html> besy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=besy1.f.html> besy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=beta.f.html> beta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=betai.f.html> betai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
<li><a href=bi.f.html> bi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=bie.f.html> bie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=binom.f.html> binom </a>
<pre>
Compute the binomial coefficients.
</pre>
<li><a href=c0lgmc.f.html> c0lgmc </a>
<pre>
Evaluate (Z+0.5)*LOG((Z+1.)/Z) - 1.0 with relative
accuracy.
</pre>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=c9ln2r.f.html> c9ln2r </a>
<pre>
Evaluate LOG(1+Z) from second order relative accuracy so
that  LOG(1+Z) = Z - Z**2/2 + Z**3*C9LN2R(Z).
</pre>
<li><a href=cacos.f.html> cacos </a>
<pre>
Compute the complex arc cosine.
</pre>
<li><a href=cacosh.f.html> cacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=carg.f.html> carg </a>
<pre>
Compute the argument of a complex number.
</pre>
<li><a href=casin.f.html> casin </a>
<pre>
Compute the complex arc sine.
</pre>
<li><a href=casinh.f.html> casinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=catan.f.html> catan </a>
<pre>
Compute the complex arc tangent.
</pre>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
<li><a href=catanh.f.html> catanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=cbeta.f.html> cbeta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=cbrt.f.html> cbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccbrt.f.html> ccbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccosh.f.html> ccosh </a>
<pre>
Compute the complex hyperbolic cosine.
</pre>
<li><a href=ccot.f.html> ccot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=cexprl.f.html> cexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=cgamma.f.html> cgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=cgamr.f.html> cgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=chu.f.html> chu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=clbeta.f.html> clbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=clngam.f.html> clngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=clnrel.f.html> clnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=clog10.f.html> clog10 </a>
<pre>
Compute the principal value of the complex base 10
logarithm.
</pre>
<li><a href=cosdg.f.html> cosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=cot.f.html> cot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=cpsi.f.html> cpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=csevl.f.html> csevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
<li><a href=csinh.f.html> csinh </a>
<pre>
Compute the complex hyperbolic sine.
</pre>
<li><a href=ctan.f.html> ctan </a>
<pre>
Compute the complex tangent.
</pre>
<li><a href=ctanh.f.html> ctanh </a>
<pre>
Compute the complex hyperbolic tangent.
</pre>
<li><a href=d9aimp.f.html> d9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=d9atn1.f.html> d9atn1 </a>
<pre>
Evaluate DATAN(X) from first order relative accuracy so
that DATAN(X) = X + X**3*D9ATN1(X).
</pre>
<li><a href=d9b0mp.f.html> d9b0mp </a>
<pre>
Evaluate the modulus and phase for the J0 and Y0 Bessel
functions.
</pre>
<li><a href=d9b1mp.f.html> d9b1mp </a>
<pre>
Evaluate the modulus and phase for the J1 and Y1 Bessel
functions.
</pre>
<li><a href=d9chu.f.html> d9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
<li><a href=d9gmic.f.html> d9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and X small.
</pre>
<li><a href=d9gmit.f.html> d9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=d9knus.f.html> d9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
<li><a href=d9lgic.f.html> d9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=d9ln2r.f.html> d9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*D9LN2R(X)
</pre>
<li><a href=d9pak.f.html> d9pak </a>
<pre>
Pack a base 2 exponent into a floating point number.
</pre>
<li><a href=d9upak.f.html> d9upak </a>
<pre>
Unpack a floating point number X so that X = Y*2**N.
</pre>
<li><a href=dai.f.html> dai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=dacosh.f.html> dacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=daie.f.html> daie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
<li><a href=dasinh.f.html> dasinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=datanh.f.html> datanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=daws.f.html> daws </a>
<pre>
Compute Dawson's function.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesj0.f.html> dbesj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=dbesj1.f.html> dbesj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesy0.f.html> dbesy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbesy1.f.html> dbesy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=dbeta.f.html> dbeta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=dbetai.f.html> dbetai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
<li><a href=dbi.f.html> dbi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=dbie.f.html> dbie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=dbinom.f.html> dbinom </a>
<pre>
Compute the binomial coefficients.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=dcbrt.f.html> dcbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=dchu.f.html> dchu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=dcosdg.f.html> dcosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dcot.f.html> dcot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=dcsevl.f.html> dcsevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
<li><a href=ddaws.f.html> ddaws </a>
<pre>
Compute Dawson's function.
</pre>
<li><a href=de1.f.html> de1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=dei.f.html> dei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=derf.f.html> derf </a>
<pre>
Compute the error function.
</pre>
<li><a href=derfc.f.html> derfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=dexprl.f.html> dexprl </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=dfac.f.html> dfac </a>
<pre>
Compute the factorial function.
</pre>
<li><a href=dgami.f.html> dgami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=dgamic.f.html> dgamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=dgamit.f.html> dgamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=dgamlm.f.html> dgamlm </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=dgamma.f.html> dgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=dgamr.f.html> dgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=dlbeta.f.html> dlbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=dlgams.f.html> dlgams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dli.f.html> dli </a>
<pre>
Compute the logarithmic integral.
</pre>
<li><a href=dlngam.f.html> dlngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dlnrel.f.html> dlnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=dpoch.f.html> dpoch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=dpoch1.f.html> dpoch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=dpsi.f.html> dpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=dsindg.f.html> dsindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=dspenc.f.html> dspenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
<li><a href=e1.f.html> e1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=ei.f.html> ei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=erf.f.html> erf </a>
<pre>
Compute the error function.
</pre>
<li><a href=erfc.f.html> erfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=exprel.f.html> exprel </a>
<pre>
Calculate the relative error exponential (EXP(X)-1)/X.
</pre>
<li><a href=fac.f.html> fac </a>
<pre>
Compute the factorial function.
</pre>
<li><a href=gami.f.html> gami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=gamic.f.html> gamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=gamit.f.html> gamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=gamlim.f.html> gamlim </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=gamma.f.html> gamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=gamr.f.html> gamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=psi.f.html> psi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=poch.f.html> poch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=poch1.f.html> poch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=r9aimp.f.html> r9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=r9atn1.f.html> r9atn1 </a>
<pre>
Evaluate ATAN(X) from first order relative accuracy so that
ATAN(X) = X + X**3*R9ATN1(X).
</pre>
<li><a href=r9chu.f.html> r9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
<li><a href=r9gmic.f.html> r9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and for small X.
</pre>
<li><a href=r9gmit.f.html> r9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=rand.f.html> rand </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=r9knus.f.html> r9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
<li><a href=r9lgic.f.html> r9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
<li><a href=r9ln2r.f.html> r9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*R9LN2R(X).
</pre>
<li><a href=r9pak.f.html> r9pak </a>
<pre>
Pack a base 2 exponent into a floating point number.
</pre>
<li><a href=r9upak.f.html> r9upak </a>
<pre>
Unpack a floating point number X so that X = Y*2**N.
</pre>
<li><a href=rgauss.f.html> rgauss </a>
<pre>
Generate a normally distributed (Gaussian) random number.
</pre>
<li><a href=runif.f.html> runif </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=sindg.f.html> sindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=spenc.f.html> spenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
</ul>
<h3> <a name="FOURIER_INTEGRALS"> FOURIER INTEGRALS </a> </h3>
<ul>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
</ul>
<h3> <a name="FOURIER_TRANSFORM"> FOURIER TRANSFORM </a> </h3>
<ul>
<li><a href=cfftb.f.html> cfftb </a>
<pre>
Compute the unnormalized inverse of CFFTF.
</pre>
<li><a href=cfftb1.f.html> cfftb1 </a>
<pre>
Compute the unnormalized inverse of CFFTF1.
</pre>
<li><a href=cfftf.f.html> cfftf </a>
<pre>
Compute the forward transform of a complex, periodic
sequence.
</pre>
<li><a href=cfftf1.f.html> cfftf1 </a>
<pre>
Compute the forward transform of a complex, periodic
sequence.
</pre>
<li><a href=cffti.f.html> cffti </a>
<pre>
Initialize a work array for CFFTF and CFFTB.
</pre>
<li><a href=cffti1.f.html> cffti1 </a>
<pre>
Initialize a real and an integer work array for CFFTF1 and
CFFTB1.
</pre>
<li><a href=cosqb1.f.html> cosqb1 </a>
<pre>
Compute the unnormalized inverse of COSQF1.
</pre>
<li><a href=cosqf1.f.html> cosqf1 </a>
<pre>
Compute the forward cosine transform with odd wave numbers.
</pre>
<li><a href=ezfftb.f.html> ezfftb </a>
<pre>
A simplified real, periodic, backward fast Fourier
transform.
</pre>
<li><a href=ezfftf.f.html> ezfftf </a>
<pre>
Compute a simplified real, periodic, fast Fourier forward
transform.
</pre>
<li><a href=ezffti.f.html> ezffti </a>
<pre>
Initialize a work array for EZFFTF and EZFFTB.
</pre>
<li><a href=rfftb.f.html> rfftb </a>
<pre>
Compute the backward fast Fourier transform of a real
coefficient array.
</pre>
<li><a href=rfftb1.f.html> rfftb1 </a>
<pre>
Compute the backward fast Fourier transform of a real
coefficient array.
</pre>
<li><a href=rfftf.f.html> rfftf </a>
<pre>
Compute the forward transform of a real, periodic sequence.
</pre>
<li><a href=rfftf1.f.html> rfftf1 </a>
<pre>
Compute the forward transform of a real, periodic sequence.
</pre>
<li><a href=rffti.f.html> rffti </a>
<pre>
Initialize a work array for RFFTF and RFFTB.
</pre>
<li><a href=rffti1.f.html> rffti1 </a>
<pre>
Initialize a real and an integer work array for RFFTF1 and
RFFTB1.
</pre>
<li><a href=sinqb.f.html> sinqb </a>
<pre>
Compute the unnormalized inverse of SINQF.
</pre>
<li><a href=sinqf.f.html> sinqf </a>
<pre>
Compute the forward sine transform with odd wave numbers.
</pre>
<li><a href=sinqi.f.html> sinqi </a>
<pre>
Initialize a work array for SINQF and SINQB.
</pre>
<li><a href=sint.f.html> sint </a>
<pre>
Compute the sine transform of a real, odd sequence.
</pre>
<li><a href=sinti.f.html> sinti </a>
<pre>
Initialize a work array for SINT.
</pre>
</ul>
<h3> <a name="FRACTIONAL_ORDER"> FRACTIONAL ORDER </a> </h3>
<ul>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
</ul>
<h3> <a name="GAMMA_FUNCTION"> GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=c0lgmc.f.html> c0lgmc </a>
<pre>
Evaluate (Z+0.5)*LOG((Z+1.)/Z) - 1.0 with relative
accuracy.
</pre>
</ul>
<h3> <a name="GAUSS_QUADRATURE"> GAUSS QUADRATURE </a> </h3>
<ul>
<li><a href=dgaus8.f.html> dgaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=gaus8.f.html> gaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
</ul>
<h3> <a name="GAUSS-KRONROD_RULES"> GAUSS-KRONROD RULES </a> </h3>
<ul>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqc25f.f.html> dqc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) or W(X)=SIN(OMEGA*X) and to
compute J = Integral of ABS(F) over (A,B). For small value
of OMEGA or small intervals (A,B) the 15-point GAUSS-KRONRO
Rule is used. Otherwise a generalized CLENSHAW-CURTIS
method is used.
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qc25f.f.html> qc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) Or (WX)=SIN(OMEGA*X)
and to compute J=Integral of ABS(F) over (A,B). For small
value of OMEGA or small intervals (A,B) 15-point GAUSS-
KRONROD Rule used. Otherwise generalized CLENSHAW-CURTIS us
</pre>
</ul>
<h3> <a name="GAUSS-KRONROD(PATTERSON)_RULES"> GAUSS-KRONROD(PATTERSON) RULES </a> </h3>
<ul>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="GAUSSIAN"> GAUSSIAN </a> </h3>
<ul>
<li><a href=rgauss.f.html> rgauss </a>
<pre>
Generate a normally distributed (Gaussian) random number.
</pre>
</ul>
<h3> <a name="GEAR'S_METHOD"> GEAR'S METHOD </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
</ul>
<h3> <a name="GENERAL_MATRIX"> GENERAL MATRIX </a> </h3>
<ul>
<li><a href=cgeco.f.html> cgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=cgeev.f.html> cgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex general matrix.
</pre>
<li><a href=cgefa.f.html> cgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=cgefs.f.html> cgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=cgeir.f.html> cgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
<li><a href=dgeco.f.html> dgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=dgefa.f.html> dgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=dgefs.f.html> dgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgeco.f.html> sgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=sgeev.f.html> sgeev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real general matrix.
</pre>
<li><a href=sgefa.f.html> sgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=sgefs.f.html> sgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgeir.f.html> sgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
</ul>
<h3> <a name="GENERAL_SYSTEM_OF_LINEAR_EQUATIONS"> GENERAL SYSTEM OF LINEAR EQUATIONS </a> </h3>
<ul>
<li><a href=cgefs.f.html> cgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=cgeir.f.html> cgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
<li><a href=dgefs.f.html> dgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgefs.f.html> sgefs </a>
<pre>
Solve a general system of linear equations.
</pre>
<li><a href=sgeir.f.html> sgeir </a>
<pre>
Solve a general system of linear equations.  Iterative
refinement is used to obtain an error estimate.
</pre>
</ul>
<h3> <a name="GENERAL-PURPOSE"> GENERAL-PURPOSE </a> </h3>
<ul>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="GENERALIZED_MINIMUM_RESIDUAL"> GENERALIZED MINIMUM RESIDUAL </a> </h3>
<ul>
<li><a href=dgmres.f.html> dgmres </a>
<pre>
Preconditioned GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dhels.f.html> dhels </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dheqr.f.html> dheqr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=dorth.f.html> dorth </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dpigmr.f.html> dpigmr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=drlcal.f.html> drlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dsdgmr.f.html> dsdgmr </a>
<pre>
Diagonally scaled GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dslugm.f.html> dslugm </a>
<pre>
Incomplete LU GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=dxlcal.f.html> dxlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=sgmres.f.html> sgmres </a>
<pre>
Preconditioned GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=shels.f.html> shels </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sheqr.f.html> sheqr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=sorth.f.html> sorth </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=spigmr.f.html> spigmr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=srlcal.f.html> srlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=ssdgmr.f.html> ssdgmr </a>
<pre>
Diagonally Scaled GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=sslugm.f.html> sslugm </a>
<pre>
Incomplete LU GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=sxlcal.f.html> sxlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
</ul>
<h3> <a name="GIVENS_ROTATION"> GIVENS ROTATION </a> </h3>
<ul>
<li><a href=crotg.f.html> crotg </a>
<pre>
Construct a Givens transformation.
</pre>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drotg.f.html> drotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srotg.f.html> srotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
</ul>
<h3> <a name="GIVENS_TRANSFORMATION"> GIVENS TRANSFORMATION </a> </h3>
<ul>
<li><a href=crotg.f.html> crotg </a>
<pre>
Construct a Givens transformation.
</pre>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drotg.f.html> drotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srotg.f.html> srotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
</ul>
<h3> <a name="GLOBALLY_ADAPTIVE"> GLOBALLY ADAPTIVE </a> </h3>
<ul>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="GMRES"> GMRES </a> </h3>
<ul>
<li><a href=isdgmr.f.html> isdgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=issgmr.f.html> issgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
</ul>
<h3> <a name="GRADIENTS"> GRADIENTS </a> </h3>
<ul>
<li><a href=chkder.f.html> chkder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
<li><a href=dckder.f.html> dckder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
</ul>
<h3> <a name="GUIDELINES_FOR_SELECTION"> GUIDELINES FOR SELECTION </a> </h3>
<ul>
<li><a href=qpdoc.f.html> qpdoc </a>
<pre>
Documentation for QUADPACK, a package of subprograms for
automatic evaluation of one-dimensional definite integrals.
</pre>
</ul>
<h3> <a name="H_BESSEL_FUNCTIONS"> H BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesh.f.html> cbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
<li><a href=zbesh.f.html> zbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
</ul>
<h3> <a name="HANKEL_FUNCTIONS"> HANKEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesh.f.html> cbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
<li><a href=zbesh.f.html> zbesh </a>
<pre>
Compute a sequence of the Hankel functions H(m,a,z)
for superscript m=1 or 2, real nonnegative orders a=b,
b+1,... where b>0, and nonzero complex argument z.  A
scaling option is available to help avoid overflow.
</pre>
</ul>
<h3> <a name="HELMHOLTZ"> HELMHOLTZ </a> </h3>
<ul>
<li><a href=hstcrt.f.html> hstcrt </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in Cartesian coordinates.
</pre>
<li><a href=hstcsp.f.html> hstcsp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified Helmholtz
equation in spherical coordinates assuming axisymmetry
(no dependence on longitude).
</pre>
<li><a href=hstcyl.f.html> hstcyl </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified
Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hstplr.f.html> hstplr </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in polar coordinates.
</pre>
<li><a href=hstssp.f.html> hstssp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz
equation in spherical coordinates and on the surface of
the unit sphere (radius of 1).
</pre>
<li><a href=hw3crt.f.html> hw3crt </a>
<pre>
Solve the standard seven-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscrt.f.html> hwscrt </a>
<pre>
Solves the standard five-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscsp.f.html> hwscsp </a>
<pre>
Solve a finite difference approximation to the modified
Helmholtz equation in spherical coordinates assuming
axisymmetry  (no dependence on longitude).
</pre>
<li><a href=hwscyl.f.html> hwscyl </a>
<pre>
Solve a standard finite difference approximation
to the Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hwsplr.f.html> hwsplr </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in polar coordinates.
</pre>
<li><a href=hwsssp.f.html> hwsssp </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in spherical coordinates and on the surface of the
unit sphere (radius of 1).
</pre>
<li><a href=pois3d.f.html> pois3d </a>
<pre>
Solve a three-dimensional block tridiagonal linear system
which arises from a finite difference approximation to a
three-dimensional Poisson equation using the Fourier
transform package FFTPAK written by Paul Swarztrauber.
</pre>
<li><a href=poistg.f.html> poistg </a>
<pre>
Solve a block tridiagonal system of linear equations
that results from a staggered grid finite difference
approximation to 2-D elliptic PDE's.
</pre>
<li><a href=sepeli.f.html> sepeli </a>
<pre>
Discretize and solve a second and, optionally, a fourth
order finite difference approximation on a uniform grid to
the general separable elliptic partial differential
equation on a rectangle with any combination of periodic or
mixed boundary conditions.
</pre>
<li><a href=sepx4.f.html> sepx4 </a>
<pre>
Solve for either the second or fourth order finite
difference approximation to the solution of a separable
elliptic partial differential equation on a rectangle.
Any combination of periodic or mixed boundary conditions is
allowed.
</pre>
</ul>
<h3> <a name="HERMITE_INTERPOLATION"> HERMITE INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchfd.f.html> dpchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for DPCHIM
or DPCHIC. If only function values are required, use
DPCHFE instead.
</pre>
<li><a href=dpchfe.f.html> dpchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for DPCHIM or DPCHIC.
</pre>
<li><a href=pchfd.f.html> pchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for PCHIM
or PCHIC.  If only function values are required, use
PCHFE instead.
</pre>
<li><a href=pchfe.f.html> pchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for PCHIM or PCHIC.
</pre>
</ul>
<h3> <a name="HERMITIAN"> HERMITIAN </a> </h3>
<ul>
<li><a href=chico.f.html> chico </a>
<pre>
Factor a complex Hermitian matrix by elimination with sym-
metric pivoting and estimate the condition of the matrix.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chifa.f.html> chifa </a>
<pre>
Factor a complex Hermitian matrix by elimination
(symmetric pivoting).
</pre>
<li><a href=chisl.f.html> chisl </a>
<pre>
Solve the complex Hermitian system using factors obtained
from CHIFA.
</pre>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=chpfa.f.html> chpfa </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cpofs.f.html> cpofs </a>
<pre>
Solve a positive definite symmetric complex system of
linear equations.
</pre>
<li><a href=cpoir.f.html> cpoir </a>
<pre>
Solve a positive definite Hermitian system of linear
equations.  Iterative refinement is used to obtain an
error estimate.
</pre>
<li><a href=dpofs.f.html> dpofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=spofs.f.html> spofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=spoir.f.html> spoir </a>
<pre>
Solve a positive definite symmetric system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
</ul>
<h3> <a name="HYPERBOLIC_BESSEL_FUNCTION"> HYPERBOLIC BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
</ul>
<h3> <a name="HYPERBOLIC_COSINE"> HYPERBOLIC COSINE </a> </h3>
<ul>
<li><a href=ccosh.f.html> ccosh </a>
<pre>
Compute the complex hyperbolic cosine.
</pre>
</ul>
<h3> <a name="HYPERBOLIC_SINE"> HYPERBOLIC SINE </a> </h3>
<ul>
<li><a href=csinh.f.html> csinh </a>
<pre>
Compute the complex hyperbolic sine.
</pre>
</ul>
<h3> <a name="HYPERBOLIC_TANGENT"> HYPERBOLIC TANGENT </a> </h3>
<ul>
<li><a href=ctanh.f.html> ctanh </a>
<pre>
Compute the complex hyperbolic tangent.
</pre>
</ul>
<h3> <a name="I_BESSEL_FUNCTION"> I BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besi.f.html> besi </a>
<pre>
Compute an N member sequence of I Bessel functions
I/SUB(ALPHA+K-1)/(X), K=1,...,N or scaled Bessel functions
EXP(-X)*I/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative
ALPHA and X.
</pre>
<li><a href=dbesi.f.html> dbesi </a>
<pre>
Compute an N member sequence of I Bessel functions
I/SUB(ALPHA+K-1)/(X), K=1,...,N or scaled Bessel functions
EXP(-X)*I/SUB(ALPHA+K-1)/(X), K=1,...,N for nonnegative
ALPHA and X.
</pre>
</ul>
<h3> <a name="I_BESSEL_FUNCTIONS"> I BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesi.f.html> cbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesi.f.html> zbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="IMPLICIT_DIFFERENTIAL_SYSTEMS"> IMPLICIT DIFFERENTIAL SYSTEMS </a> </h3>
<ul>
<li><a href=ddassl.f.html> ddassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
<li><a href=sdassl.f.html> sdassl </a>
<pre>
This code solves a system of differential/algebraic
equations of the form G(T,Y,YPRIME) = 0.
</pre>
</ul>
<h3> <a name="INCOMPLETE_BETA_FUNCTION"> INCOMPLETE BETA FUNCTION </a> </h3>
<ul>
<li><a href=betai.f.html> betai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
<li><a href=dbetai.f.html> dbetai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
</ul>
<h3> <a name="INCOMPLETE_CHOLESKY"> INCOMPLETE CHOLESKY </a> </h3>
<ul>
<li><a href=dsiccg.f.html> dsiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=ssiccg.f.html> ssiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
</ul>
<h3> <a name="INCOMPLETE_CHOLESKY_FACTORIZATION"> INCOMPLETE CHOLESKY FACTORIZATION </a> </h3>
<ul>
<li><a href=dsics.f.html> dsics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=ssics.f.html> ssics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
</ul>
<h3> <a name="INCOMPLETE_ELLIPTIC_INTEGRAL"> INCOMPLETE ELLIPTIC INTEGRAL </a> </h3>
<ul>
<li><a href=drd.f.html> drd </a>
<pre>
Compute the incomplete or complete elliptic integral of
the 2nd kind. For X and Y nonnegative, X+Y and Z positive,
DRD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=drf.f.html> drf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=drj.f.html> drj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                  -1/2     -1/2     -1/2     -1
        (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
<li><a href=rd.f.html> rd </a>
<pre>
Compute the incomplete or complete elliptic integral of the
2nd kind.  For X and Y nonnegative, X+Y and Z positive,
 RD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=rf.f.html> rf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=rj.f.html> rj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                      -1/2     -1/2     -1/2     -1
            (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
</ul>
<h3> <a name="INCOMPLETE_FACTORIZATION"> INCOMPLETE FACTORIZATION </a> </h3>
<ul>
<li><a href=dllti2.f.html> dllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=sllti2.f.html> sllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
</ul>
<h3> <a name="INCOMPLETE_GAMMA_FUNCTION"> INCOMPLETE GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=dgami.f.html> dgami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=gami.f.html> gami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
</ul>
<h3> <a name="INCOMPLETE_LU_FACTORIZATION"> INCOMPLETE LU FACTORIZATION </a> </h3>
<ul>
<li><a href=dsilus.f.html> dsilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=ssilus.f.html> ssilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
</ul>
<h3> <a name="INEQUALITY"> INEQUALITY </a> </h3>
<ul>
<li><a href=dbocls.f.html> dbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=dbols.f.html> dbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
<li><a href=sbocls.f.html> sbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=sbols.f.html> sbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
</ul>
<h3> <a name="INEQUALITY_CONSTRAINTS"> INEQUALITY CONSTRAINTS </a> </h3>
<ul>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="INFINITE_INTERVALS"> INFINITE INTERVALS </a> </h3>
<ul>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
</ul>
<h3> <a name="INITIAL_VALUE_PROBLEMS"> INITIAL VALUE PROBLEMS </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="INITIALIZE"> INITIALIZE </a> </h3>
<ul>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
</ul>
<h3> <a name="INNER_PRODUCT"> INNER PRODUCT </a> </h3>
<ul>
<li><a href=cdcdot.f.html> cdcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=cdotc.f.html> cdotc </a>
<pre>
Dot product of two complex vectors using the complex
conjugate of the first vector.
</pre>
<li><a href=cdotu.f.html> cdotu </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=ddot.f.html> ddot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=dqdota.f.html> dqdota </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dqdoti.f.html> dqdoti </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=sdot.f.html> sdot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=sdsdot.f.html> sdsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
</ul>
<h3> <a name="INTEGRAL_OF_B-SPLINE"> INTEGRAL OF B-SPLINE </a> </h3>
<ul>
<li><a href=bfqad.f.html> bfqad </a>
<pre>
Compute the integral of a product of a function and a
derivative of a B-spline.
</pre>
<li><a href=dbfqad.f.html> dbfqad </a>
<pre>
Compute the integral of a product of a function and a
derivative of a K-th order B-spline.
</pre>
</ul>
<h3> <a name="INTEGRAL_OF_B-SPLINES"> INTEGRAL OF B-SPLINES </a> </h3>
<ul>
<li><a href=bsqad.f.html> bsqad </a>
<pre>
Compute the integral of a K-th order B-spline using the
B-representation.
</pre>
<li><a href=dbsqad.f.html> dbsqad </a>
<pre>
Compute the integral of a K-th order B-spline using the
B-representation.
</pre>
</ul>
<h3> <a name="INTEGRAL_OF_THE_FIRST_KIND"> INTEGRAL OF THE FIRST KIND </a> </h3>
<ul>
<li><a href=drf.f.html> drf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=rf.f.html> rf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
</ul>
<h3> <a name="INTEGRAL_OF_THE_SECOND_KIND"> INTEGRAL OF THE SECOND KIND </a> </h3>
<ul>
<li><a href=drd.f.html> drd </a>
<pre>
Compute the incomplete or complete elliptic integral of
the 2nd kind. For X and Y nonnegative, X+Y and Z positive,
DRD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=rd.f.html> rd </a>
<pre>
Compute the incomplete or complete elliptic integral of the
2nd kind.  For X and Y nonnegative, X+Y and Z positive,
 RD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
</ul>
<h3> <a name="INTEGRAL_OF_THE_THIRD_KIND"> INTEGRAL OF THE THIRD KIND </a> </h3>
<ul>
<li><a href=drj.f.html> drj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                  -1/2     -1/2     -1/2     -1
        (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
<li><a href=rj.f.html> rj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                      -1/2     -1/2     -1/2     -1
            (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
</ul>
<h3> <a name="INTEGRALS_OF_BESSEL_FUNCTIONS"> INTEGRALS OF BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=bskin.f.html> bskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
<li><a href=dbskin.f.html> dbskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
</ul>
<h3> <a name="INTEGRAND_EXAMINATOR"> INTEGRAND EXAMINATOR </a> </h3>
<ul>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="INTEGRAND_WITH_OSCILLATORY_COS_OR_SIN_FACTOR"> INTEGRAND WITH OSCILLATORY COS OR SIN FACTOR </a> </h3>
<ul>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="INTEGRATION"> INTEGRATION </a> </h3>
<ul>
<li><a href=avint.f.html> avint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
<li><a href=davint.f.html> davint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
<li><a href=dqnc79.f.html> dqnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
<li><a href=qnc79.f.html> qnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
</ul>
<h3> <a name="INTEGRATION_BETWEEN_ZEROS"> INTEGRATION BETWEEN ZEROS </a> </h3>
<ul>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
</ul>
<h3> <a name="INTEGRATION_RULES_FOR_FUNCTIONS_WITH_COS_OR_SIN_FACTOR"> INTEGRATION RULES FOR FUNCTIONS WITH COS OR SIN FACTOR </a> </h3>
<ul>
<li><a href=dqc25f.f.html> dqc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) or W(X)=SIN(OMEGA*X) and to
compute J = Integral of ABS(F) over (A,B). For small value
of OMEGA or small intervals (A,B) the 15-point GAUSS-KRONRO
Rule is used. Otherwise a generalized CLENSHAW-CURTIS
method is used.
</pre>
<li><a href=qc25f.f.html> qc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) Or (WX)=SIN(OMEGA*X)
and to compute J=Integral of ABS(F) over (A,B). For small
value of OMEGA or small intervals (A,B) 15-point GAUSS-
KRONROD Rule used. Otherwise generalized CLENSHAW-CURTIS us
</pre>
</ul>
<h3> <a name="INTERCHANGE"> INTERCHANGE </a> </h3>
<ul>
<li><a href=cswap.f.html> cswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=dswap.f.html> dswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=iswap.f.html> iswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=sswap.f.html> sswap </a>
<pre>
Interchange two vectors.
</pre>
</ul>
<h3> <a name="INTERPOLATION"> INTERPOLATION </a> </h3>
<ul>
<li><a href=bint4.f.html> bint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=bintk.f.html> bintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=bspdr.f.html> bspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=bspev.f.html> bspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dbint4.f.html> dbint4 </a>
<pre>
Compute the B-representation of a cubic spline
which interpolates given data.
</pre>
<li><a href=dbintk.f.html> dbintk </a>
<pre>
Compute the B-representation of a spline which interpolates
given data.
</pre>
<li><a href=dbspdr.f.html> dbspdr </a>
<pre>
Use the B-representation to construct a divided difference
table preparatory to a (right) derivative calculation.
</pre>
<li><a href=dbspev.f.html> dbspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dintrv.f.html> dintrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision of
the X interval.
</pre>
<li><a href=dpfqad.f.html> dpfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a
function F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=dppqad.f.html> dppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=dppval.f.html> dppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
<li><a href=intrv.f.html> intrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision
of the X interval.
</pre>
<li><a href=pfqad.f.html> pfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a function
F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=ppqad.f.html> ppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=ppval.f.html> ppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
</ul>
<h3> <a name="INVERSE"> INVERSE </a> </h3>
<ul>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgedi.f.html> cgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=ctrdi.f.html> ctrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgedi.f.html> dgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dtrdi.f.html> dtrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgedi.f.html> sgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by SGECO or SGEFA.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
</ul>
<h3> <a name="INVERSE_COSINE_FOURIER_TRANSFORM"> INVERSE COSINE FOURIER TRANSFORM </a> </h3>
<ul>
<li><a href=cosqb.f.html> cosqb </a>
<pre>
Compute the unnormalized inverse cosine transform.
</pre>
</ul>
<h3> <a name="INVERSE_HYPERBOLIC_COSINE"> INVERSE HYPERBOLIC COSINE </a> </h3>
<ul>
<li><a href=acosh.f.html> acosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=cacosh.f.html> cacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
<li><a href=dacosh.f.html> dacosh </a>
<pre>
Compute the arc hyperbolic cosine.
</pre>
</ul>
<h3> <a name="INVERSE_HYPERBOLIC_SINE"> INVERSE HYPERBOLIC SINE </a> </h3>
<ul>
<li><a href=asinh.f.html> asinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=casinh.f.html> casinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
<li><a href=dasinh.f.html> dasinh </a>
<pre>
Compute the arc hyperbolic sine.
</pre>
</ul>
<h3> <a name="INVERSE_HYPERBOLIC_TANGENT"> INVERSE HYPERBOLIC TANGENT </a> </h3>
<ul>
<li><a href=atanh.f.html> atanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=catanh.f.html> catanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
<li><a href=datanh.f.html> datanh </a>
<pre>
Compute the arc hyperbolic tangent.
</pre>
</ul>
<h3> <a name="ITERATIVE_IMPROVEMENT"> ITERATIVE IMPROVEMENT </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="ITERATIVE_INCOMPLETE_LU_PRECONDITION"> ITERATIVE INCOMPLETE LU PRECONDITION </a> </h3>
<ul>
<li><a href=dslubc.f.html> dslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslucn.f.html> dslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=dslucs.f.html> dslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dsluom.f.html> dsluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=sslubc.f.html> sslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslucn.f.html> sslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=sslucs.f.html> sslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=ssluom.f.html> ssluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
</ul>
<h3> <a name="ITERATIVE_PRECONDITION"> ITERATIVE PRECONDITION </a> </h3>
<ul>
<li><a href=dbcg.f.html> dbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=dcg.f.html> dcg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=dcgn.f.html> dcgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=dcgs.f.html> dcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=dgmres.f.html> dgmres </a>
<pre>
Preconditioned GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dhels.f.html> dhels </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dheqr.f.html> dheqr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dir.f.html> dir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=dllti2.f.html> dllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=domn.f.html> domn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=dorth.f.html> dorth </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dpigmr.f.html> dpigmr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=drlcal.f.html> drlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dsdbcg.f.html> dsdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=dsdcg.f.html> dsdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=dsdcgn.f.html> dsdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=dsdcgs.f.html> dsdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=dsdgmr.f.html> dsdgmr </a>
<pre>
Diagonally scaled GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dsdi.f.html> dsdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=dsdomn.f.html> dsdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=dsgs.f.html> dsgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=dsiccg.f.html> dsiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=dsics.f.html> dsics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=dsilur.f.html> dsilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=dsilus.f.html> dsilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=dsjac.f.html> dsjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=dsli.f.html> dsli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=dsli2.f.html> dsli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=dsllti.f.html> dsllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=dslugm.f.html> dslugm </a>
<pre>
Incomplete LU GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=dslui.f.html> dslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=dslui2.f.html> dslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=dslui4.f.html> dslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsluti.f.html> dsluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=dsmmi2.f.html> dsmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsmmti.f.html> dsmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=dxlcal.f.html> dxlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=isdbcg.f.html> isdbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcgn.f.html> isdcgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isdcgs.f.html> isdcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issbcg.f.html> issbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscgn.f.html> isscgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isscgs.f.html> isscgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=sbcg.f.html> sbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=scg.f.html> scg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=scgn.f.html> scgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=scgs.f.html> scgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=sir.f.html> sir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=sgmres.f.html> sgmres </a>
<pre>
Preconditioned GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=shels.f.html> shels </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sheqr.f.html> sheqr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sllti2.f.html> sllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=somn.f.html> somn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=sorth.f.html> sorth </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=spigmr.f.html> spigmr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=srlcal.f.html> srlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=ssdbcg.f.html> ssdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=ssdcg.f.html> ssdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=ssdcgn.f.html> ssdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=ssdcgs.f.html> ssdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=ssdgmr.f.html> ssdgmr </a>
<pre>
Diagonally Scaled GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=ssdi.f.html> ssdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=ssdomn.f.html> ssdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=ssgs.f.html> ssgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=ssiccg.f.html> ssiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=ssics.f.html> ssics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=ssilur.f.html> ssilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=ssilus.f.html> ssilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=ssjac.f.html> ssjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=ssli.f.html> ssli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=ssli2.f.html> ssli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=ssllti.f.html> ssllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=sslugm.f.html> sslugm </a>
<pre>
Incomplete LU GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=sslui.f.html> sslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=sslui2.f.html> sslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=sslui4.f.html> sslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssluti.f.html> ssluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=ssmmi2.f.html> ssmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssmmti.f.html> ssmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=sxlcal.f.html> sxlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
</ul>
<h3> <a name="J_BESSEL_FUNCTION"> J BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besj.f.html> besj </a>
<pre>
Compute an N member sequence of J Bessel functions
J/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative ALPHA
and X.
</pre>
<li><a href=dbesj.f.html> dbesj </a>
<pre>
Compute an N member sequence of J Bessel functions
J/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative ALPHA
and X.
</pre>
</ul>
<h3> <a name="J_BESSEL_FUNCTIONS"> J BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesj.f.html> cbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesj.f.html> zbesj </a>
<pre>
Compute a sequence of the Bessel functions J(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="JACOBIAN"> JACOBIAN </a> </h3>
<ul>
<li><a href=chkder.f.html> chkder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
<li><a href=dckder.f.html> dckder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
</ul>
<h3> <a name="K_BESSEL_FUNCTION"> K BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besk.f.html> besk </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions K/SUB(FNU+I-1)/(X), or scaled Bessel functions
EXP(X)*K/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=dbesk.f.html> dbesk </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions K/SUB(FNU+I-1)/(X), or scaled Bessel functions
EXP(X)*K/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
</ul>
<h3> <a name="K_BESSEL_FUNCTIONS"> K BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesk.f.html> cbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesk.f.html> zbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="K-ZERO_BESSEL_FUNCTION"> K-ZERO BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=bskin.f.html> bskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
<li><a href=dbskin.f.html> dbskin </a>
<pre>
Compute repeated integrals of the K-zero Bessel function.
</pre>
</ul>
<h3> <a name="L2"> L2 </a> </h3>
<ul>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
</ul>
<h3> <a name="LARGE_X"> LARGE X </a> </h3>
<ul>
<li><a href=d9lgic.f.html> d9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=r9lgic.f.html> r9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
</ul>
<h3> <a name="LEAST_SQUARES"> LEAST SQUARES </a> </h3>
<ul>
<li><a href=bndacc.f.html> bndacc </a>
<pre>
Compute the LU factorization of a banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=bndsol.f.html> bndsol </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbndac.f.html> dbndac </a>
<pre>
Compute the LU factorization of a  banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbndsl.f.html> dbndsl </a>
<pre>
Solve the least squares problem for a banded matrix using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dbocls.f.html> dbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=dbols.f.html> dbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
<li><a href=dhfti.f.html> dhfti </a>
<pre>
Solve a least squares problem for banded matrices using
sequential accumulation of rows of the data matrix.
Exactly one right-hand side vector is permitted.
</pre>
<li><a href=dp1vlu.f.html> dp1vlu </a>
<pre>
Use the coefficients generated by DPOLFT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
<li><a href=dpcoef.f.html> dpcoef </a>
<pre>
Convert the DPOLFT coefficients to Taylor series form.
</pre>
<li><a href=dpolft.f.html> dpolft </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=pcoef.f.html> pcoef </a>
<pre>
Convert the POLFIT coefficients to Taylor series form.
</pre>
<li><a href=polfit.f.html> polfit </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=pvalue.f.html> pvalue </a>
<pre>
Use the coefficients generated by POLFIT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
<li><a href=sbocls.f.html> sbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=sbols.f.html> sbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
</ul>
<h3> <a name="LEGENDRE_FUNCTIONS"> LEGENDRE FUNCTIONS </a> </h3>
<ul>
<li><a href=dxlegf.f.html> dxlegf </a>
<pre>
Compute normalized Legendre polynomials and associated
Legendre functions.
</pre>
<li><a href=dxnrmp.f.html> dxnrmp </a>
<pre>
Compute normalized Legendre polynomials.
</pre>
<li><a href=dxpmu.f.html> dxpmu </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
Method: backward mu-wise recurrence for P(-MU,NU,X) for
fixed nu to obtain P(-MU2,NU1,X), P(-(MU2-1),NU1,X), ...,
P(-MU1,NU1,X) and store in ascending mu order.
</pre>
<li><a href=dxpmup.f.html> dxpmup </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
This subroutine transforms an array of Legendre functions
of the first kind of negative order stored in array PQA
into Legendre functions of the first kind of positive
order stored in array PQA. The original array is destroyed.
</pre>
<li><a href=dxpnrm.f.html> dxpnrm </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
This subroutine transforms an array of Legendre functions
of the first kind of negative order stored in array PQA
into normalized Legendre polynomials stored in array PQA.
The original array is destroyed.
</pre>
<li><a href=dxpqnu.f.html> dxpqnu </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
This subroutine calculates initial values of P or Q using
power series, then performs forward nu-wise recurrence to
obtain P(-MU,NU,X), Q(0,NU,X), or Q(1,NU,X). The nu-wise
recurrence is stable for P for all mu and for Q for mu=0,1.
</pre>
<li><a href=dxqmu.f.html> dxqmu </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
Method: forward mu-wise recurrence for Q(MU,NU,X) for fixed
nu to obtain Q(MU1,NU,X), Q(MU1+1,NU,X), ..., Q(MU2,NU,X).
</pre>
<li><a href=dxqnu.f.html> dxqnu </a>
<pre>
To compute the values of Legendre functions for DXLEGF.
Method: backward nu-wise recurrence for Q(MU,NU,X) for
fixed mu to obtain Q(MU1,NU1,X), Q(MU1,NU1+1,X), ...,
Q(MU1,NU2,X).
</pre>
<li><a href=xlegf.f.html> xlegf </a>
<pre>
Compute normalized Legendre polynomials and associated
Legendre functions.
</pre>
<li><a href=xnrmp.f.html> xnrmp </a>
<pre>
Compute normalized Legendre polynomials.
</pre>
<li><a href=xpmu.f.html> xpmu </a>
<pre>
To compute the values of Legendre functions for XLEGF.
Method: backward mu-wise recurrence for P(-MU,NU,X) for
fixed nu to obtain P(-MU2,NU1,X), P(-(MU2-1),NU1,X), ...,
P(-MU1,NU1,X) and store in ascending mu order.
</pre>
<li><a href=xpmup.f.html> xpmup </a>
<pre>
To compute the values of Legendre functions for XLEGF.
This subroutine transforms an array of Legendre functions
of the first kind of negative order stored in array PQA
into Legendre functions of the first kind of positive
order stored in array PQA. The original array is destroyed.
</pre>
<li><a href=xpnrm.f.html> xpnrm </a>
<pre>
To compute the values of Legendre functions for XLEGF.
This subroutine transforms an array of Legendre functions
of the first kind of negative order stored in array PQA
into normalized Legendre polynomials stored in array PQA.
The original array is destroyed.
</pre>
<li><a href=xpqnu.f.html> xpqnu </a>
<pre>
To compute the values of Legendre functions for XLEGF.
This subroutine calculates initial values of P or Q using
power series, then performs forward nu-wise recurrence to
obtain P(-MU,NU,X), Q(0,NU,X), or Q(1,NU,X). The nu-wise
recurrence is stable for P for all mu and for Q for mu=0,1.
</pre>
<li><a href=xqmu.f.html> xqmu </a>
<pre>
To compute the values of Legendre functions for XLEGF.
Method: forward mu-wise recurrence for Q(MU,NU,X) for fixed
nu to obtain Q(MU1,NU,X), Q(MU1+1,NU,X), ..., Q(MU2,NU,X).
</pre>
<li><a href=xqnu.f.html> xqnu </a>
<pre>
To compute the values of Legendre functions for XLEGF.
Method: backward nu-wise recurrence for Q(MU,NU,X) for
fixed mu to obtain Q(MU1,NU1,X), Q(MU1,NU1+1,X), ...,
Q(MU1,NU2,X).
</pre>
</ul>
<h3> <a name="LEVEL_2_BLAS"> LEVEL 2 BLAS </a> </h3>
<ul>
<li><a href=cgbmv.f.html> cgbmv </a>
<pre>
Multiply a complex vector by a complex general band matrix.
</pre>
<li><a href=cgemv.f.html> cgemv </a>
<pre>
Multiply a complex vector by a complex general matrix.
</pre>
<li><a href=cgerc.f.html> cgerc </a>
<pre>
Perform conjugated rank 1 update of a complex general
matrix.
</pre>
<li><a href=cgeru.f.html> cgeru </a>
<pre>
Perform unconjugated rank 1 update of a complex general
matrix.
</pre>
<li><a href=chbmv.f.html> chbmv </a>
<pre>
Multiply a complex vector by a complex Hermitian band
matrix.
</pre>
<li><a href=chemv.f.html> chemv </a>
<pre>
Multiply a complex vector by a complex Hermitian matrix.
</pre>
<li><a href=cher.f.html> cher </a>
<pre>
Perform Hermitian rank 1 update of a complex Hermitian
matrix.
</pre>
<li><a href=cher2.f.html> cher2 </a>
<pre>
Perform Hermitian rank 2 update of a complex Hermitian
matrix.
</pre>
<li><a href=chpmv.f.html> chpmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=chpr.f.html> chpr </a>
<pre>
Perform the hermitian rank 1 operation.
</pre>
<li><a href=chpr2.f.html> chpr2 </a>
<pre>
Perform the hermitian rank 2 operation.
</pre>
<li><a href=ctbmv.f.html> ctbmv </a>
<pre>
Multiply a complex vector by a complex triangular band
matrix.
</pre>
<li><a href=ctbsv.f.html> ctbsv </a>
<pre>
Solve a complex triangular banded system of equations.
</pre>
<li><a href=ctpmv.f.html> ctpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=ctpsv.f.html> ctpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=ctrmv.f.html> ctrmv </a>
<pre>
Multiply a complex vector by a complex triangular matrix.
</pre>
<li><a href=ctrsv.f.html> ctrsv </a>
<pre>
Solve a complex triangular system of equations.
</pre>
<li><a href=dgbmv.f.html> dgbmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dgemv.f.html> dgemv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dger.f.html> dger </a>
<pre>
Perform the rank 1 operation.
</pre>
<li><a href=dsbmv.f.html> dsbmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dspmv.f.html> dspmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dspr.f.html> dspr </a>
<pre>
Perform the symmetric rank 1 operation.
</pre>
<li><a href=dspr2.f.html> dspr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=dsymv.f.html> dsymv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dsyr.f.html> dsyr </a>
<pre>
Perform the symmetric rank 1 operation.
</pre>
<li><a href=dsyr2.f.html> dsyr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=dtbmv.f.html> dtbmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtbsv.f.html> dtbsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=dtpmv.f.html> dtpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtpsv.f.html> dtpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=dtrmv.f.html> dtrmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtrsv.f.html> dtrsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=lsame.f.html> lsame </a>
<pre>
Test two characters to determine if they are the same
letter, except for case.
</pre>
<li><a href=sgbmv.f.html> sgbmv </a>
<pre>
Multiply a real vector by a real general band matrix.
</pre>
<li><a href=sgemv.f.html> sgemv </a>
<pre>
Multiply a real vector by a real general matrix.
</pre>
<li><a href=sger.f.html> sger </a>
<pre>
Perform rank 1 update of a real general matrix.
</pre>
<li><a href=ssbmv.f.html> ssbmv </a>
<pre>
Multiply a real vector by a real symmetric band matrix.
</pre>
<li><a href=sspmv.f.html> sspmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=sspr.f.html> sspr </a>
<pre>
Performs the symmetric rank 1 operation.
</pre>
<li><a href=sspr2.f.html> sspr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=ssymv.f.html> ssymv </a>
<pre>
Multiply a real vector by a real symmetric matrix.
</pre>
<li><a href=ssyr.f.html> ssyr </a>
<pre>
Perform symmetric rank 1 update of a real symmetric matrix.
</pre>
<li><a href=ssyr2.f.html> ssyr2 </a>
<pre>
Perform symmetric rank 2 update of a real symmetric matrix.
</pre>
<li><a href=stbmv.f.html> stbmv </a>
<pre>
Multiply a real vector by a real triangular band matrix.
</pre>
<li><a href=stbsv.f.html> stbsv </a>
<pre>
Solve a real triangular banded system of linear equations.
</pre>
<li><a href=stpmv.f.html> stpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=stpsv.f.html> stpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=strmv.f.html> strmv </a>
<pre>
Multiply a real vector by a real triangular matrix.
</pre>
<li><a href=strsv.f.html> strsv </a>
<pre>
Solve a real triangular system of linear equations.
</pre>
</ul>
<h3> <a name="LEVEL_3_BLAS"> LEVEL 3 BLAS </a> </h3>
<ul>
<li><a href=cgemm.f.html> cgemm </a>
<pre>
Multiply a complex general matrix by a complex general
matrix.
</pre>
<li><a href=chemm.f.html> chemm </a>
<pre>
Multiply a complex general matrix by a complex Hermitian
matrix.
</pre>
<li><a href=cher2k.f.html> cher2k </a>
<pre>
Perform Hermitian rank 2k update of a complex.
</pre>
<li><a href=cherk.f.html> cherk </a>
<pre>
Perform Hermitian rank k update of a complex Hermitian
matrix.
</pre>
<li><a href=csymm.f.html> csymm </a>
<pre>
Multiply a complex general matrix by a complex symmetric
matrix.
</pre>
<li><a href=csyr2k.f.html> csyr2k </a>
<pre>
Perform symmetric rank 2k update of a complex symmetric
matrix.
</pre>
<li><a href=csyrk.f.html> csyrk </a>
<pre>
Perform symmetric rank k update of a complex symmetric
matrix.
</pre>
<li><a href=ctrmm.f.html> ctrmm </a>
<pre>
Multiply a complex general matrix by a complex triangular
matrix.
</pre>
<li><a href=ctrsm.f.html> ctrsm </a>
<pre>
Solve a complex triangular system of equations with
multiple right-hand sides.
</pre>
<li><a href=dgemm.f.html> dgemm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dsymm.f.html> dsymm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dsyr2k.f.html> dsyr2k </a>
<pre>
Perform one of the symmetric rank 2k operations.
</pre>
<li><a href=dsyrk.f.html> dsyrk </a>
<pre>
Perform one of the symmetric rank k operations.
</pre>
<li><a href=dtrmm.f.html> dtrmm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dtrsm.f.html> dtrsm </a>
<pre>
Solve one of the matrix equations.
</pre>
<li><a href=lsame.f.html> lsame </a>
<pre>
Test two characters to determine if they are the same
letter, except for case.
</pre>
<li><a href=sgemm.f.html> sgemm </a>
<pre>
Multiply a real general matrix by a real general matrix.
</pre>
<li><a href=ssymm.f.html> ssymm </a>
<pre>
Multiply a real general matrix by a real symmetric matrix.
</pre>
<li><a href=ssyr2k.f.html> ssyr2k </a>
<pre>
Perform symmetric rank 2k update of a real symmetric matrix
</pre>
<li><a href=ssyrk.f.html> ssyrk </a>
<pre>
Perform symmetric rank k update of a real symmetric matrix.
</pre>
<li><a href=strmm.f.html> strmm </a>
<pre>
Multiply a real general matrix by a real triangular matrix.
</pre>
<li><a href=strsm.f.html> strsm </a>
<pre>
Solve a real triangular system of equations with multiple
right-hand sides.
</pre>
</ul>
<h3> <a name="LEVENBERG-MARQUARDT"> LEVENBERG-MARQUARDT </a> </h3>
<ul>
<li><a href=dnls1.f.html> dnls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=dnls1e.f.html> dnls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
<li><a href=snls1.f.html> snls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=snls1e.f.html> snls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
</ul>
<h3> <a name="LIMITS"> LIMITS </a> </h3>
<ul>
<li><a href=dgamlm.f.html> dgamlm </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=gamlim.f.html> gamlim </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
</ul>
<h3> <a name="LINEAR"> LINEAR </a> </h3>
<ul>
<li><a href=dbocls.f.html> dbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=dbols.f.html> dbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
<li><a href=sbocls.f.html> sbocls </a>
<pre>
Solve the bounded and constrained least squares
problem consisting of solving the equation
          E*X = F  (in the least squares sense)
 subject to the linear constraints
                C*X = Y.
</pre>
<li><a href=sbols.f.html> sbols </a>
<pre>
Solve the problem
     E*X = F (in the least  squares  sense)
with bounds on selected X values.
</pre>
</ul>
<h3> <a name="LINEAR_ALGEBRA"> LINEAR ALGEBRA </a> </h3>
<ul>
<li><a href=caxpy.f.html> caxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=cchdc.f.html> cchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=cchdd.f.html> cchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=cchud.f.html> cchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=ccopy.f.html> ccopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=cdcdot.f.html> cdcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=cdotc.f.html> cdotc </a>
<pre>
Dot product of two complex vectors using the complex
conjugate of the first vector.
</pre>
<li><a href=cdotu.f.html> cdotu </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=cgbco.f.html> cgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgbfa.f.html> cgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=cgbmv.f.html> cgbmv </a>
<pre>
Multiply a complex vector by a complex general band matrix.
</pre>
<li><a href=cgbsl.f.html> cgbsl </a>
<pre>
Solve the complex band system A*X=B or CTRANS(A)*X=B using
the factors computed by CGBCO or CGBFA.
</pre>
<li><a href=cgeco.f.html> cgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=cgedi.f.html> cgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgefa.f.html> cgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=cgemm.f.html> cgemm </a>
<pre>
Multiply a complex general matrix by a complex general
matrix.
</pre>
<li><a href=cgemv.f.html> cgemv </a>
<pre>
Multiply a complex vector by a complex general matrix.
</pre>
<li><a href=cgerc.f.html> cgerc </a>
<pre>
Perform conjugated rank 1 update of a complex general
matrix.
</pre>
<li><a href=cgeru.f.html> cgeru </a>
<pre>
Perform unconjugated rank 1 update of a complex general
matrix.
</pre>
<li><a href=cgesl.f.html> cgesl </a>
<pre>
Solve the complex system A*X=B or CTRANS(A)*X=B using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgtsl.f.html> cgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=chbmv.f.html> chbmv </a>
<pre>
Multiply a complex vector by a complex Hermitian band
matrix.
</pre>
<li><a href=chemm.f.html> chemm </a>
<pre>
Multiply a complex general matrix by a complex Hermitian
matrix.
</pre>
<li><a href=chemv.f.html> chemv </a>
<pre>
Multiply a complex vector by a complex Hermitian matrix.
</pre>
<li><a href=cher.f.html> cher </a>
<pre>
Perform Hermitian rank 1 update of a complex Hermitian
matrix.
</pre>
<li><a href=cher2.f.html> cher2 </a>
<pre>
Perform Hermitian rank 2 update of a complex Hermitian
matrix.
</pre>
<li><a href=cher2k.f.html> cher2k </a>
<pre>
Perform Hermitian rank 2k update of a complex.
</pre>
<li><a href=cherk.f.html> cherk </a>
<pre>
Perform Hermitian rank k update of a complex Hermitian
matrix.
</pre>
<li><a href=chico.f.html> chico </a>
<pre>
Factor a complex Hermitian matrix by elimination with sym-
metric pivoting and estimate the condition of the matrix.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chifa.f.html> chifa </a>
<pre>
Factor a complex Hermitian matrix by elimination
(symmetric pivoting).
</pre>
<li><a href=chisl.f.html> chisl </a>
<pre>
Solve the complex Hermitian system using factors obtained
from CHIFA.
</pre>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=chpfa.f.html> chpfa </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=chpmv.f.html> chpmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=chpr.f.html> chpr </a>
<pre>
Perform the hermitian rank 1 operation.
</pre>
<li><a href=chpr2.f.html> chpr2 </a>
<pre>
Perform the hermitian rank 2 operation.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpbfa.f.html> cpbfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=cpoco.f.html> cpoco </a>
<pre>
Factor a complex Hermitian positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cpofa.f.html> cpofa </a>
<pre>
Factor a complex Hermitian positive definite matrix.
</pre>
<li><a href=cposl.f.html> cposl </a>
<pre>
Solve the complex Hermitian positive definite linear system
using the factors computed by CPOCO or CPOFA.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=cppfa.f.html> cppfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=cqrdc.f.html> cqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=cqrsl.f.html> cqrsl </a>
<pre>
Apply the output of CQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=crotg.f.html> crotg </a>
<pre>
Construct a Givens transformation.
</pre>
<li><a href=cscal.f.html> cscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=csico.f.html> csico </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting and estimate the condition number of the
matrix.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=csifa.f.html> csifa </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=csisl.f.html> csisl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSIFA.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=cspfa.f.html> cspfa </a>
<pre>
Factor a complex symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=csscal.f.html> csscal </a>
<pre>
Scale a complex vector.
</pre>
<li><a href=csvdc.f.html> csvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=cswap.f.html> cswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=csymm.f.html> csymm </a>
<pre>
Multiply a complex general matrix by a complex symmetric
matrix.
</pre>
<li><a href=csyr2k.f.html> csyr2k </a>
<pre>
Perform symmetric rank 2k update of a complex symmetric
matrix.
</pre>
<li><a href=csyrk.f.html> csyrk </a>
<pre>
Perform symmetric rank k update of a complex symmetric
matrix.
</pre>
<li><a href=ctbmv.f.html> ctbmv </a>
<pre>
Multiply a complex vector by a complex triangular band
matrix.
</pre>
<li><a href=ctbsv.f.html> ctbsv </a>
<pre>
Solve a complex triangular banded system of equations.
</pre>
<li><a href=ctpmv.f.html> ctpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=ctpsv.f.html> ctpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=ctrco.f.html> ctrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=ctrdi.f.html> ctrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=ctrmm.f.html> ctrmm </a>
<pre>
Multiply a complex general matrix by a complex triangular
matrix.
</pre>
<li><a href=ctrmv.f.html> ctrmv </a>
<pre>
Multiply a complex vector by a complex triangular matrix.
</pre>
<li><a href=ctrsl.f.html> ctrsl </a>
<pre>
Solve a system of the form  T*X=B or CTRANS(T)*X=B, where
T is a triangular matrix.  Here CTRANS(T) is the conjugate
transpose.
</pre>
<li><a href=ctrsm.f.html> ctrsm </a>
<pre>
Solve a complex triangular system of equations with
multiple right-hand sides.
</pre>
<li><a href=ctrsv.f.html> ctrsv </a>
<pre>
Solve a complex triangular system of equations.
</pre>
<li><a href=dasum.f.html> dasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=daxpy.f.html> daxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dchdc.f.html> dchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=dchdd.f.html> dchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dchud.f.html> dchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=dcopy.f.html> dcopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=ddot.f.html> ddot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=dgbco.f.html> dgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgbfa.f.html> dgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=dgbmv.f.html> dgbmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dgbsl.f.html> dgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by DGBCO or DGBFA.
</pre>
<li><a href=dgeco.f.html> dgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=dgedi.f.html> dgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgefa.f.html> dgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=dgemm.f.html> dgemm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dgemv.f.html> dgemv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dger.f.html> dger </a>
<pre>
Perform the rank 1 operation.
</pre>
<li><a href=dgesl.f.html> dgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgtsl.f.html> dgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpbfa.f.html> dpbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
in band form.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpoco.f.html> dpoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition of the matrix.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dpofa.f.html> dpofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=dposl.f.html> dposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by DPOCO or DPOFA.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dppfa.f.html> dppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dqrdc.f.html> dqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=dqrsl.f.html> dqrsl </a>
<pre>
Apply the output of DQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drotg.f.html> drotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=drotm.f.html> drotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=drotmg.f.html> drotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=dsbmv.f.html> dsbmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dscal.f.html> dscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dsico.f.html> dsico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dsifa.f.html> dsifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=dsisl.f.html> dsisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dspfa.f.html> dspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=dspmv.f.html> dspmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dspr.f.html> dspr </a>
<pre>
Perform the symmetric rank 1 operation.
</pre>
<li><a href=dspr2.f.html> dspr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=dsvdc.f.html> dsvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=dswap.f.html> dswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=dsymm.f.html> dsymm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dsymv.f.html> dsymv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=dsyr.f.html> dsyr </a>
<pre>
Perform the symmetric rank 1 operation.
</pre>
<li><a href=dsyr2.f.html> dsyr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=dsyr2k.f.html> dsyr2k </a>
<pre>
Perform one of the symmetric rank 2k operations.
</pre>
<li><a href=dsyrk.f.html> dsyrk </a>
<pre>
Perform one of the symmetric rank k operations.
</pre>
<li><a href=dtbmv.f.html> dtbmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtbsv.f.html> dtbsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=dtpmv.f.html> dtpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtpsv.f.html> dtpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=dtrco.f.html> dtrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=dtrdi.f.html> dtrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=dtrmm.f.html> dtrmm </a>
<pre>
Perform one of the matrix-matrix operations.
</pre>
<li><a href=dtrmv.f.html> dtrmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=dtrsl.f.html> dtrsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
<li><a href=dtrsm.f.html> dtrsm </a>
<pre>
Solve one of the matrix equations.
</pre>
<li><a href=dtrsv.f.html> dtrsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=icamax.f.html> icamax </a>
<pre>
Find the smallest index of the component of a complex
vector having the maximum sum of magnitudes of real
and imaginary parts.
</pre>
<li><a href=icopy.f.html> icopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=idamax.f.html> idamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=isamax.f.html> isamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=iswap.f.html> iswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=sasum.f.html> sasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=saxpy.f.html> saxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=scasum.f.html> scasum </a>
<pre>
Compute the sum of the magnitudes of the real and
imaginary elements of a complex vector.
</pre>
<li><a href=schdc.f.html> schdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=schdd.f.html> schdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=schud.f.html> schud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=scopy.f.html> scopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=sdot.f.html> sdot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=sdsdot.f.html> sdsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=sgbco.f.html> sgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgbfa.f.html> sgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=sgbmv.f.html> sgbmv </a>
<pre>
Multiply a real vector by a real general band matrix.
</pre>
<li><a href=sgbsl.f.html> sgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by SGBCO or SGBFA.
</pre>
<li><a href=sgeco.f.html> sgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=sgedi.f.html> sgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by SGECO or SGEFA.
</pre>
<li><a href=sgefa.f.html> sgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=sgemm.f.html> sgemm </a>
<pre>
Multiply a real general matrix by a real general matrix.
</pre>
<li><a href=sgemv.f.html> sgemv </a>
<pre>
Multiply a real vector by a real general matrix.
</pre>
<li><a href=sger.f.html> sger </a>
<pre>
Perform rank 1 update of a real general matrix.
</pre>
<li><a href=sgesl.f.html> sgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors of SGECO or SGEFA.
</pre>
<li><a href=sgtsl.f.html> sgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spbfa.f.html> spbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spoco.f.html> spoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=spofa.f.html> spofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=sposl.f.html> sposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by SPOCO or SPOFA.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=sppfa.f.html> sppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=sqrdc.f.html> sqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=sqrsl.f.html> sqrsl </a>
<pre>
Apply the output of SQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srotg.f.html> srotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=srotm.f.html> srotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=srotmg.f.html> srotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=ssbmv.f.html> ssbmv </a>
<pre>
Multiply a real vector by a real symmetric band matrix.
</pre>
<li><a href=sscal.f.html> sscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=ssico.f.html> ssico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=ssifa.f.html> ssifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=ssisl.f.html> ssisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=sspfa.f.html> sspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=sspmv.f.html> sspmv </a>
<pre>
Perform the matrix-vector operation.
</pre>
<li><a href=sspr.f.html> sspr </a>
<pre>
Performs the symmetric rank 1 operation.
</pre>
<li><a href=sspr2.f.html> sspr2 </a>
<pre>
Perform the symmetric rank 2 operation.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
<li><a href=ssvdc.f.html> ssvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=sswap.f.html> sswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=ssymm.f.html> ssymm </a>
<pre>
Multiply a real general matrix by a real symmetric matrix.
</pre>
<li><a href=ssymv.f.html> ssymv </a>
<pre>
Multiply a real vector by a real symmetric matrix.
</pre>
<li><a href=ssyr.f.html> ssyr </a>
<pre>
Perform symmetric rank 1 update of a real symmetric matrix.
</pre>
<li><a href=ssyr2.f.html> ssyr2 </a>
<pre>
Perform symmetric rank 2 update of a real symmetric matrix.
</pre>
<li><a href=ssyr2k.f.html> ssyr2k </a>
<pre>
Perform symmetric rank 2k update of a real symmetric matrix
</pre>
<li><a href=ssyrk.f.html> ssyrk </a>
<pre>
Perform symmetric rank k update of a real symmetric matrix.
</pre>
<li><a href=stbmv.f.html> stbmv </a>
<pre>
Multiply a real vector by a real triangular band matrix.
</pre>
<li><a href=stbsv.f.html> stbsv </a>
<pre>
Solve a real triangular banded system of linear equations.
</pre>
<li><a href=stpmv.f.html> stpmv </a>
<pre>
Perform one of the matrix-vector operations.
</pre>
<li><a href=stpsv.f.html> stpsv </a>
<pre>
Solve one of the systems of equations.
</pre>
<li><a href=strco.f.html> strco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=strmm.f.html> strmm </a>
<pre>
Multiply a real general matrix by a real triangular matrix.
</pre>
<li><a href=strmv.f.html> strmv </a>
<pre>
Multiply a real vector by a real triangular matrix.
</pre>
<li><a href=strsl.f.html> strsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
<li><a href=strsm.f.html> strsm </a>
<pre>
Solve a real triangular system of equations with multiple
right-hand sides.
</pre>
<li><a href=strsv.f.html> strsv </a>
<pre>
Solve a real triangular system of linear equations.
</pre>
</ul>
<h3> <a name="LINEAR_CONSTRAINTS"> LINEAR CONSTRAINTS </a> </h3>
<ul>
<li><a href=dsplp.f.html> dsplp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
<li><a href=splp.f.html> splp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
</ul>
<h3> <a name="LINEAR_EQUATIONS"> LINEAR EQUATIONS </a> </h3>
<ul>
<li><a href=cnbco.f.html> cnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=cnbdi.f.html> cnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by CNBCO or CNBFA.
</pre>
<li><a href=cnbfa.f.html> cnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=cnbfs.f.html> cnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=cnbir.f.html> cnbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=cnbsl.f.html> cnbsl </a>
<pre>
Solve a complex band system using the factors computed by
CNBCO or CNBFA.
</pre>
<li><a href=cpofs.f.html> cpofs </a>
<pre>
Solve a positive definite symmetric complex system of
linear equations.
</pre>
<li><a href=cpoir.f.html> cpoir </a>
<pre>
Solve a positive definite Hermitian system of linear
equations.  Iterative refinement is used to obtain an
error estimate.
</pre>
<li><a href=dnbco.f.html> dnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=dnbdi.f.html> dnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DNBCO or DNBFA.
</pre>
<li><a href=dnbfa.f.html> dnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=dnbfs.f.html> dnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=dnbsl.f.html> dnbsl </a>
<pre>
Solve a real band system using the factors computed by
DNBCO or DNBFA.
</pre>
<li><a href=dpofs.f.html> dpofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=snbco.f.html> snbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=snbdi.f.html> snbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SNBCO or SNBFA.
</pre>
<li><a href=snbfa.f.html> snbfa </a>
<pre>
Factor a real band matrix by elimination.
</pre>
<li><a href=snbfs.f.html> snbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=snbir.f.html> snbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=snbsl.f.html> snbsl </a>
<pre>
Solve a real band system using the factors computed by
SNBCO or SNBFA.
</pre>
<li><a href=spofs.f.html> spofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=spoir.f.html> spoir </a>
<pre>
Solve a positive definite symmetric system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
</ul>
<h3> <a name="LINEAR_LEAST_SQUARES"> LINEAR LEAST SQUARES </a> </h3>
<ul>
<li><a href=dglss.f.html> dglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=dllsia.f.html> dllsia </a>
<pre>
Solve linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=dulsia.f.html> dulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
<li><a href=hfti.f.html> hfti </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.
</pre>
<li><a href=llsia.f.html> llsia </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=sglss.f.html> sglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=ulsia.f.html> ulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
</ul>
<h3> <a name="LINEAR_OPTIMIZATION"> LINEAR OPTIMIZATION </a> </h3>
<ul>
<li><a href=dsplp.f.html> dsplp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
<li><a href=splp.f.html> splp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
</ul>
<h3> <a name="LINEAR_PROGRAMMING"> LINEAR PROGRAMMING </a> </h3>
<ul>
<li><a href=dsplp.f.html> dsplp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
<li><a href=splp.f.html> splp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
</ul>
<h3> <a name="LINEAR_SYSTEM"> LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=dbhin.f.html> dbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
<li><a href=dcpplt.f.html> dcpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=dir.f.html> dir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=ds2lt.f.html> ds2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
<li><a href=ds2y.f.html> ds2y </a>
<pre>
SLAP Triad to SLAP Column Format Converter.
Routine to convert from the SLAP Triad to SLAP Column
format.
</pre>
<li><a href=dsgs.f.html> dsgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=dsics.f.html> dsics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=dsilur.f.html> dsilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=dsjac.f.html> dsjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=dsmmi2.f.html> dsmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dtin.f.html> dtin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=dtout.f.html> dtout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=isdcg.f.html> isdcg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdgmr.f.html> isdgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=isdir.f.html> isdir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscg.f.html> isscg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=issgmr.f.html> issgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=issir.f.html> issir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=sbhin.f.html> sbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
<li><a href=sir.f.html> sir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=scpplt.f.html> scpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=ss2lt.f.html> ss2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
<li><a href=ss2y.f.html> ss2y </a>
<pre>
SLAP Triad to SLAP Column Format Converter.
Routine to convert from the SLAP Triad to SLAP Column
format.
</pre>
<li><a href=ssgs.f.html> ssgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=ssics.f.html> ssics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=ssilur.f.html> ssilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=ssjac.f.html> ssjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=ssmmi2.f.html> ssmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=stin.f.html> stin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=stout.f.html> stout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
</ul>
<h3> <a name="LINEAR_SYSTEM_SOLVE"> LINEAR SYSTEM SOLVE </a> </h3>
<ul>
<li><a href=dsdi.f.html> dsdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=dsli.f.html> dsli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=dsli2.f.html> dsli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=dsllti.f.html> dsllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=dsluti.f.html> dsluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=dsmmti.f.html> dsmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=ssdi.f.html> ssdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=ssli.f.html> ssli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=ssli2.f.html> ssli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=ssllti.f.html> ssllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=ssluti.f.html> ssluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=ssmmti.f.html> ssmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
</ul>
<h3> <a name="LINPACK"> LINPACK </a> </h3>
<ul>
<li><a href=cchdc.f.html> cchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=cchdd.f.html> cchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=cchud.f.html> cchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=cgbco.f.html> cgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgbfa.f.html> cgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=cgbsl.f.html> cgbsl </a>
<pre>
Solve the complex band system A*X=B or CTRANS(A)*X=B using
the factors computed by CGBCO or CGBFA.
</pre>
<li><a href=cgeco.f.html> cgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=cgedi.f.html> cgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgefa.f.html> cgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=cgesl.f.html> cgesl </a>
<pre>
Solve the complex system A*X=B or CTRANS(A)*X=B using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgtsl.f.html> cgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=chico.f.html> chico </a>
<pre>
Factor a complex Hermitian matrix by elimination with sym-
metric pivoting and estimate the condition of the matrix.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chifa.f.html> chifa </a>
<pre>
Factor a complex Hermitian matrix by elimination
(symmetric pivoting).
</pre>
<li><a href=chisl.f.html> chisl </a>
<pre>
Solve the complex Hermitian system using factors obtained
from CHIFA.
</pre>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=chpfa.f.html> chpfa </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpbfa.f.html> cpbfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=cpoco.f.html> cpoco </a>
<pre>
Factor a complex Hermitian positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cpofa.f.html> cpofa </a>
<pre>
Factor a complex Hermitian positive definite matrix.
</pre>
<li><a href=cposl.f.html> cposl </a>
<pre>
Solve the complex Hermitian positive definite linear system
using the factors computed by CPOCO or CPOFA.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=cppfa.f.html> cppfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=cqrdc.f.html> cqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=cqrsl.f.html> cqrsl </a>
<pre>
Apply the output of CQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=csico.f.html> csico </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting and estimate the condition number of the
matrix.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=csifa.f.html> csifa </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=csisl.f.html> csisl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSIFA.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=cspfa.f.html> cspfa </a>
<pre>
Factor a complex symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=csvdc.f.html> csvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=ctrco.f.html> ctrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=ctrdi.f.html> ctrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=ctrsl.f.html> ctrsl </a>
<pre>
Solve a system of the form  T*X=B or CTRANS(T)*X=B, where
T is a triangular matrix.  Here CTRANS(T) is the conjugate
transpose.
</pre>
<li><a href=dchdc.f.html> dchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=dchdd.f.html> dchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dchud.f.html> dchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=dgbco.f.html> dgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgbfa.f.html> dgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=dgbsl.f.html> dgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by DGBCO or DGBFA.
</pre>
<li><a href=dgeco.f.html> dgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=dgedi.f.html> dgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgefa.f.html> dgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=dgesl.f.html> dgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgtsl.f.html> dgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpbfa.f.html> dpbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
in band form.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpoco.f.html> dpoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition of the matrix.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dpofa.f.html> dpofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=dposl.f.html> dposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by DPOCO or DPOFA.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dppfa.f.html> dppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dqrdc.f.html> dqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=dqrsl.f.html> dqrsl </a>
<pre>
Apply the output of DQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=dsico.f.html> dsico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dsifa.f.html> dsifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=dsisl.f.html> dsisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dspfa.f.html> dspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=dsvdc.f.html> dsvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=dtrco.f.html> dtrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=dtrdi.f.html> dtrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=dtrsl.f.html> dtrsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
<li><a href=schdc.f.html> schdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=schdd.f.html> schdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=schud.f.html> schud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=sgbco.f.html> sgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgbfa.f.html> sgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=sgbsl.f.html> sgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by SGBCO or SGBFA.
</pre>
<li><a href=sgeco.f.html> sgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=sgedi.f.html> sgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by SGECO or SGEFA.
</pre>
<li><a href=sgefa.f.html> sgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=sgesl.f.html> sgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors of SGECO or SGEFA.
</pre>
<li><a href=sgtsl.f.html> sgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spbfa.f.html> spbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spoco.f.html> spoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=spofa.f.html> spofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=sposl.f.html> sposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by SPOCO or SPOFA.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=sppfa.f.html> sppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=sqrdc.f.html> sqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=sqrsl.f.html> sqrsl </a>
<pre>
Apply the output of SQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=ssico.f.html> ssico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=ssifa.f.html> ssifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=ssisl.f.html> ssisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=sspfa.f.html> sspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
<li><a href=ssvdc.f.html> ssvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=strco.f.html> strco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=strsl.f.html> strsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
</ul>
<h3> <a name="LOG_GAMMA"> LOG GAMMA </a> </h3>
<ul>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
</ul>
<h3> <a name="LOGARITHM"> LOGARITHM </a> </h3>
<ul>
<li><a href=alngam.f.html> alngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=alnrel.f.html> alnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=c9ln2r.f.html> c9ln2r </a>
<pre>
Evaluate LOG(1+Z) from second order relative accuracy so
that  LOG(1+Z) = Z - Z**2/2 + Z**3*C9LN2R(Z).
</pre>
<li><a href=clngam.f.html> clngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=clnrel.f.html> clnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=d9lgic.f.html> d9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=d9ln2r.f.html> d9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*D9LN2R(X)
</pre>
<li><a href=dlngam.f.html> dlngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dlnrel.f.html> dlnrel </a>
<pre>
Evaluate ln(1+X) accurate in the sense of relative error.
</pre>
<li><a href=r9lgic.f.html> r9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
<li><a href=r9ln2r.f.html> r9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*R9LN2R(X).
</pre>
</ul>
<h3> <a name="LOGARITHM_OF_GAMMA_FUNCTION"> LOGARITHM OF GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=dgamln.f.html> dgamln </a>
<pre>
Compute the logarithm of the Gamma function
</pre>
<li><a href=gamln.f.html> gamln </a>
<pre>
Compute the logarithm of the Gamma function
</pre>
</ul>
<h3> <a name="LOGARITHM_OF_THE_COMPLETE_BETA_FUNCTION"> LOGARITHM OF THE COMPLETE BETA FUNCTION </a> </h3>
<ul>
<li><a href=albeta.f.html> albeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=clbeta.f.html> clbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=dlbeta.f.html> dlbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
</ul>
<h3> <a name="LOGARITHMIC_CONFLUENT_HYPERGEOMETRIC_FUNCTION"> LOGARITHMIC CONFLUENT HYPERGEOMETRIC FUNCTION </a> </h3>
<ul>
<li><a href=chu.f.html> chu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=d9chu.f.html> d9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
<li><a href=dchu.f.html> dchu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=r9chu.f.html> r9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
</ul>
<h3> <a name="LOGARITHMIC_INTEGRAL"> LOGARITHMIC INTEGRAL </a> </h3>
<ul>
<li><a href=ali.f.html> ali </a>
<pre>
Compute the logarithmic integral.
</pre>
<li><a href=dli.f.html> dli </a>
<pre>
Compute the logarithmic integral.
</pre>
</ul>
<h3> <a name="LOWER_TRIANGLE"> LOWER TRIANGLE </a> </h3>
<ul>
<li><a href=ds2lt.f.html> ds2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
<li><a href=ss2lt.f.html> ss2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
</ul>
<h3> <a name="LP"> LP </a> </h3>
<ul>
<li><a href=dsplp.f.html> dsplp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
<li><a href=splp.f.html> splp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
</ul>
<h3> <a name="LQ_FACTORIZATION"> LQ FACTORIZATION </a> </h3>
<ul>
<li><a href=dglss.f.html> dglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=dulsia.f.html> dulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
<li><a href=sglss.f.html> sglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=ulsia.f.html> ulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
</ul>
<h3> <a name="LR_METHOD"> LR METHOD </a> </h3>
<ul>
<li><a href=comlr.f.html> comlr </a>
<pre>
Compute the eigenvalues of a complex upper Hessenberg
matrix using the modified LR method.
</pre>
<li><a href=comlr2.f.html> comlr2 </a>
<pre>
Compute the eigenvalues and eigenvectors of a complex upper
Hessenberg matrix using the modified LR method.
</pre>
</ul>
<h3> <a name="MACHINE_CONSTANTS"> MACHINE CONSTANTS </a> </h3>
<ul>
<li><a href=d1mach_IRIX.f.html> d1mach_IRIX </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=i1mach_IRIX.f.html> i1mach_IRIX </a>
<pre>
Return integer machine dependent constants.
</pre>
<li><a href=d1mach_GENERIC.f.html> d1mach_GENERIC </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=d1mach_IRIX6.f.html> d1mach_IRIX6 </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=d1mach_Linux.f.html> d1mach_Linux </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=d1mach_OSF1.f.html> d1mach_OSF1 </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=i1mach_GENERIC.f.html> i1mach_GENERIC </a>
<pre>
Return integer machine dependent constants.
</pre>
<li><a href=i1mach_IRIX6.f.html> i1mach_IRIX6 </a>
<pre>
Return integer machine dependent constants.
</pre>
<li><a href=i1mach_Linux.f.html> i1mach_Linux </a>
<pre>
Return integer machine dependent constants.
</pre>
<li><a href=i1mach_OSF1.f.html> i1mach_OSF1 </a>
<pre>
Return integer machine dependent constants.
</pre>
<li><a href=r1mach_IRIX.f.html> r1mach_IRIX </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=r1mach_GENERIC.f.html> r1mach_GENERIC </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=r1mach_IRIX6.f.html> r1mach_IRIX6 </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=r1mach_Linux.f.html> r1mach_Linux </a>
<pre>
Return floating point machine dependent constants.
</pre>
<li><a href=r1mach_OSF1.f.html> r1mach_OSF1 </a>
<pre>
Return floating point machine dependent constants.
</pre>
</ul>
<h3> <a name="MATRIX"> MATRIX </a> </h3>
<ul>
<li><a href=cchdc.f.html> cchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=cchdd.f.html> cchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=cchud.f.html> cchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=cgbdi.f.html> cgbdi </a>
<pre>
Compute the determinant of a complex band matrix using the
factors from CGBCO or CGBFA.
</pre>
<li><a href=cgbsl.f.html> cgbsl </a>
<pre>
Solve the complex band system A*X=B or CTRANS(A)*X=B using
the factors computed by CGBCO or CGBFA.
</pre>
<li><a href=cgedi.f.html> cgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgesl.f.html> cgesl </a>
<pre>
Solve the complex system A*X=B or CTRANS(A)*X=B using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgtsl.f.html> cgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=chidi.f.html> chidi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix using the factors obtained from CHIFA.
</pre>
<li><a href=chiev.f.html> chiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=chisl.f.html> chisl </a>
<pre>
Solve the complex Hermitian system using factors obtained
from CHIFA.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cposl.f.html> cposl </a>
<pre>
Solve the complex Hermitian positive definite linear system
using the factors computed by CPOCO or CPOFA.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=cqrdc.f.html> cqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=cqrsl.f.html> cqrsl </a>
<pre>
Apply the output of CQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=csisl.f.html> csisl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSIFA.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=csvdc.f.html> csvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=dchdc.f.html> dchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=dchdd.f.html> dchdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dchud.f.html> dchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=dgbdi.f.html> dgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DGBCO or DGBFA.
</pre>
<li><a href=dgbsl.f.html> dgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by DGBCO or DGBFA.
</pre>
<li><a href=dgedi.f.html> dgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgesl.f.html> dgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgtsl.f.html> dgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dposl.f.html> dposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by DPOCO or DPOFA.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dqrdc.f.html> dqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=dqrsl.f.html> dqrsl </a>
<pre>
Apply the output of DQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dsisl.f.html> dsisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=dsvdc.f.html> dsvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=schdc.f.html> schdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=schdd.f.html> schdd </a>
<pre>
Downdate an augmented Cholesky decomposition or the
triangular factor of an augmented QR decomposition.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=schud.f.html> schud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=sgbdi.f.html> sgbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SGBCO or SGBFA.
</pre>
<li><a href=sgbsl.f.html> sgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by SGBCO or SGBFA.
</pre>
<li><a href=sgedi.f.html> sgedi </a>
<pre>
Compute the determinant and inverse of a matrix using the
factors computed by SGECO or SGEFA.
</pre>
<li><a href=sgesl.f.html> sgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors of SGECO or SGEFA.
</pre>
<li><a href=sgtsl.f.html> sgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=sposl.f.html> sposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by SPOCO or SPOFA.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=sqrdc.f.html> sqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=sqrsl.f.html> sqrsl </a>
<pre>
Apply the output of SQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=ssiev.f.html> ssiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=ssisl.f.html> ssisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
<li><a href=ssvdc.f.html> ssvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
</ul>
<h3> <a name="MATRIX_FACTORIZATION"> MATRIX FACTORIZATION </a> </h3>
<ul>
<li><a href=cgbco.f.html> cgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=cgbfa.f.html> cgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=cgeco.f.html> cgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=cgefa.f.html> cgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=chico.f.html> chico </a>
<pre>
Factor a complex Hermitian matrix by elimination with sym-
metric pivoting and estimate the condition of the matrix.
</pre>
<li><a href=chifa.f.html> chifa </a>
<pre>
Factor a complex Hermitian matrix by elimination
(symmetric pivoting).
</pre>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=chpfa.f.html> chpfa </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=cnbco.f.html> cnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=cnbfa.f.html> cnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpbfa.f.html> cpbfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form.
</pre>
<li><a href=cpoco.f.html> cpoco </a>
<pre>
Factor a complex Hermitian positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=cpofa.f.html> cpofa </a>
<pre>
Factor a complex Hermitian positive definite matrix.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=cppfa.f.html> cppfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form.
</pre>
<li><a href=csico.f.html> csico </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting and estimate the condition number of the
matrix.
</pre>
<li><a href=csifa.f.html> csifa </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cspfa.f.html> cspfa </a>
<pre>
Factor a complex symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=dgbco.f.html> dgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=dgbfa.f.html> dgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=dgeco.f.html> dgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=dgefa.f.html> dgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=dnbco.f.html> dnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=dnbfa.f.html> dnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpbfa.f.html> dpbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
in band form.
</pre>
<li><a href=dpoco.f.html> dpoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition of the matrix.
</pre>
<li><a href=dpofa.f.html> dpofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dppfa.f.html> dppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=dsico.f.html> dsico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=dsifa.f.html> dsifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dspfa.f.html> dspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=sgbco.f.html> sgbco </a>
<pre>
Factor a band matrix by Gaussian elimination and
estimate the condition number of the matrix.
</pre>
<li><a href=sgbfa.f.html> sgbfa </a>
<pre>
Factor a band matrix using Gaussian elimination.
</pre>
<li><a href=sgeco.f.html> sgeco </a>
<pre>
Factor a matrix using Gaussian elimination and estimate
the condition number of the matrix.
</pre>
<li><a href=sgefa.f.html> sgefa </a>
<pre>
Factor a matrix using Gaussian elimination.
</pre>
<li><a href=snbco.f.html> snbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=snbfa.f.html> snbfa </a>
<pre>
Factor a real band matrix by elimination.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spbfa.f.html> spbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form.
</pre>
<li><a href=spoco.f.html> spoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=spofa.f.html> spofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=sppfa.f.html> sppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=ssico.f.html> ssico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=ssifa.f.html> ssifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=sspfa.f.html> sspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
</ul>
<h3> <a name="MATRIX_READ"> MATRIX READ </a> </h3>
<ul>
<li><a href=dbhin.f.html> dbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
<li><a href=sbhin.f.html> sbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
</ul>
<h3> <a name="MATRIX_TRANSPOSE_VECTOR_MULTIPLY"> MATRIX TRANSPOSE VECTOR MULTIPLY </a> </h3>
<ul>
<li><a href=dsmtv.f.html> dsmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
<li><a href=ssmtv.f.html> ssmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
</ul>
<h3> <a name="MATRIX_VECTOR_MULTIPLY"> MATRIX VECTOR MULTIPLY </a> </h3>
<ul>
<li><a href=dsmv.f.html> dsmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
<li><a href=ssmv.f.html> ssmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
</ul>
<h3> <a name="MAXIMUM_COMPONENT"> MAXIMUM COMPONENT </a> </h3>
<ul>
<li><a href=icamax.f.html> icamax </a>
<pre>
Find the smallest index of the component of a complex
vector having the maximum sum of magnitudes of real
and imaginary parts.
</pre>
<li><a href=idamax.f.html> idamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=isamax.f.html> isamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
</ul>
<h3> <a name="MINPACK"> MINPACK </a> </h3>
<ul>
<li><a href=chkder.f.html> chkder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
<li><a href=dckder.f.html> dckder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
</ul>
<h3> <a name="MODIFIED_BESSEL_FUNCTION"> MODIFIED BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
</ul>
<h3> <a name="MODIFIED_BESSEL_FUNCTIONS"> MODIFIED BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesi.f.html> cbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=cbesk.f.html> cbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesi.f.html> zbesi </a>
<pre>
Compute a sequence of the Bessel functions I(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesk.f.html> zbesk </a>
<pre>
Compute a sequence of the Bessel functions K(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="MODIFIED_CHEBYSHEV_MOMENTS"> MODIFIED CHEBYSHEV MOMENTS </a> </h3>
<ul>
<li><a href=dqmomo.f.html> dqmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
<li><a href=qmomo.f.html> qmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
</ul>
<h3> <a name="MODIFIED_GIVENS_ROTATION"> MODIFIED GIVENS ROTATION </a> </h3>
<ul>
<li><a href=drotm.f.html> drotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=drotmg.f.html> drotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=srotm.f.html> srotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=srotmg.f.html> srotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
</ul>
<h3> <a name="MODULUS"> MODULUS </a> </h3>
<ul>
<li><a href=d9aimp.f.html> d9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=d9b0mp.f.html> d9b0mp </a>
<pre>
Evaluate the modulus and phase for the J0 and Y0 Bessel
functions.
</pre>
<li><a href=d9b1mp.f.html> d9b1mp </a>
<pre>
Evaluate the modulus and phase for the J1 and Y1 Bessel
functions.
</pre>
<li><a href=r9aimp.f.html> r9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
</ul>
<h3> <a name="MONOTONE_INTERPOLATION"> MONOTONE INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchcm.f.html> dpchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=dpchic.f.html> dpchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=dpchim.f.html> dpchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See DPCHIC if user control
is desired over boundary or switch conditions.)
</pre>
<li><a href=pchcm.f.html> pchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=pchdoc.f.html> pchdoc </a>
<pre>
Documentation for PCHIP, a Fortran package for piecewise
cubic Hermite interpolation of data.
</pre>
<li><a href=pchic.f.html> pchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=pchim.f.html> pchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See PCHIC if user control is
desired over boundary or switch conditions.)
</pre>
</ul>
<h3> <a name="NEWTON'S_METHOD"> NEWTON'S METHOD </a> </h3>
<ul>
<li><a href=dsos.f.html> dsos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
<li><a href=sos.f.html> sos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
</ul>
<h3> <a name="NEWTON-COTES"> NEWTON-COTES </a> </h3>
<ul>
<li><a href=dqnc79.f.html> dqnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
<li><a href=qnc79.f.html> qnc79 </a>
<pre>
Integrate a function using a 7-point adaptive Newton-Cotes
quadrature rule.
</pre>
</ul>
<h3> <a name="NON-SYMMETRIC_LINEAR_SYSTEM"> NON-SYMMETRIC LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=dbcg.f.html> dbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=dcgs.f.html> dcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=dgmres.f.html> dgmres </a>
<pre>
Preconditioned GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dhels.f.html> dhels </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dheqr.f.html> dheqr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=domn.f.html> domn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=dorth.f.html> dorth </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dpigmr.f.html> dpigmr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=drlcal.f.html> drlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dsdbcg.f.html> dsdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=dsdcgs.f.html> dsdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=dsdgmr.f.html> dsdgmr </a>
<pre>
Diagonally scaled GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dsilus.f.html> dsilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=dslubc.f.html> dslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslucn.f.html> dslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=dslucs.f.html> dslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslugm.f.html> dslugm </a>
<pre>
Incomplete LU GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=dsluom.f.html> dsluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=dxlcal.f.html> dxlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=isdbcg.f.html> isdbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcgn.f.html> isdcgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isdcgs.f.html> isdcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issbcg.f.html> issbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscgn.f.html> isscgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isscgs.f.html> isscgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=sbcg.f.html> sbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=scgs.f.html> scgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=sgmres.f.html> sgmres </a>
<pre>
Preconditioned GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=shels.f.html> shels </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sheqr.f.html> sheqr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=somn.f.html> somn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=sorth.f.html> sorth </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=spigmr.f.html> spigmr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=srlcal.f.html> srlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=ssdbcg.f.html> ssdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=ssdcgs.f.html> ssdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=ssdgmr.f.html> ssdgmr </a>
<pre>
Diagonally Scaled GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=ssilus.f.html> ssilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=sslubc.f.html> sslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslucn.f.html> sslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=sslucs.f.html> sslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslugm.f.html> sslugm </a>
<pre>
Incomplete LU GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=ssluom.f.html> ssluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=sxlcal.f.html> sxlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
</ul>
<h3> <a name="NON-SYMMETRIC_LINEAR_SYSTEM_SOLVE"> NON-SYMMETRIC LINEAR SYSTEM SOLVE </a> </h3>
<ul>
<li><a href=dcgn.f.html> dcgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=dsdcgn.f.html> dsdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=dsdomn.f.html> dsdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=dslui.f.html> dslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=dslui2.f.html> dslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=dslui4.f.html> dslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=scgn.f.html> scgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=ssdcgn.f.html> ssdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=ssdomn.f.html> ssdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=sslui.f.html> sslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=sslui2.f.html> sslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=sslui4.f.html> sslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
</ul>
<h3> <a name="NONADAPTIVE"> NONADAPTIVE </a> </h3>
<ul>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="NONLINEAR"> NONLINEAR </a> </h3>
<ul>
<li><a href=chkder.f.html> chkder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
<li><a href=dckder.f.html> dckder </a>
<pre>
Check the gradients of M nonlinear functions in N
variables, evaluated at a point X, for consistency
with the functions themselves.
</pre>
<li><a href=dfzero.f.html> dfzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
</ul>
<h3> <a name="NONLINEAR_DATA_FITTING"> NONLINEAR DATA FITTING </a> </h3>
<ul>
<li><a href=dcov.f.html> dcov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either DNLS1 or DNLS1E.
</pre>
<li><a href=dnls1.f.html> dnls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=dnls1e.f.html> dnls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
<li><a href=scov.f.html> scov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either SNLS1 or SNLS1E.
</pre>
<li><a href=snls1.f.html> snls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=snls1e.f.html> snls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
</ul>
<h3> <a name="NONLINEAR_EQUATIONS"> NONLINEAR EQUATIONS </a> </h3>
<ul>
<li><a href=dsos.f.html> dsos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
<li><a href=fzero.f.html> fzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=sos.f.html> sos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
</ul>
<h3> <a name="NONLINEAR_LEAST_SQUARES"> NONLINEAR LEAST SQUARES </a> </h3>
<ul>
<li><a href=dcov.f.html> dcov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either DNLS1 or DNLS1E.
</pre>
<li><a href=dnls1.f.html> dnls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=dnls1e.f.html> dnls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
<li><a href=scov.f.html> scov </a>
<pre>
Calculate the covariance matrix for a nonlinear data
fitting problem.  It is intended to be used after a
successful return from either SNLS1 or SNLS1E.
</pre>
<li><a href=snls1.f.html> snls1 </a>
<pre>
Minimize the sum of the squares of M nonlinear functions
in N variables by a modification of the Levenberg-Marquardt
algorithm.
</pre>
<li><a href=snls1e.f.html> snls1e </a>
<pre>
An easy-to-use code which minimizes the sum of the squares
of M nonlinear functions in N variables by a modification
of the Levenberg-Marquardt algorithm.
</pre>
</ul>
<h3> <a name="NONLINEAR_SQUARE_SYSTEM"> NONLINEAR SQUARE SYSTEM </a> </h3>
<ul>
<li><a href=dnsq.f.html> dnsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=dnsqe.f.html> dnsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
<li><a href=snsq.f.html> snsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=snsqe.f.html> snsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
</ul>
<h3> <a name="NONNEGATIVITY_CONSTRAINTS"> NONNEGATIVITY CONSTRAINTS </a> </h3>
<ul>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="NONSYMMETRIC"> NONSYMMETRIC </a> </h3>
<ul>
<li><a href=cnbco.f.html> cnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=cnbdi.f.html> cnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by CNBCO or CNBFA.
</pre>
<li><a href=cnbfa.f.html> cnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=cnbfs.f.html> cnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=cnbir.f.html> cnbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=cnbsl.f.html> cnbsl </a>
<pre>
Solve a complex band system using the factors computed by
CNBCO or CNBFA.
</pre>
<li><a href=dnbco.f.html> dnbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=dnbdi.f.html> dnbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by DNBCO or DNBFA.
</pre>
<li><a href=dnbfa.f.html> dnbfa </a>
<pre>
Factor a band matrix by elimination.
</pre>
<li><a href=dnbfs.f.html> dnbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=dnbsl.f.html> dnbsl </a>
<pre>
Solve a real band system using the factors computed by
DNBCO or DNBFA.
</pre>
<li><a href=snbco.f.html> snbco </a>
<pre>
Factor a band matrix using Gaussian elimination and
estimate the condition number.
</pre>
<li><a href=snbdi.f.html> snbdi </a>
<pre>
Compute the determinant of a band matrix using the factors
computed by SNBCO or SNBFA.
</pre>
<li><a href=snbfa.f.html> snbfa </a>
<pre>
Factor a real band matrix by elimination.
</pre>
<li><a href=snbfs.f.html> snbfs </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.
</pre>
<li><a href=snbir.f.html> snbir </a>
<pre>
Solve a general nonsymmetric banded system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=snbsl.f.html> snbsl </a>
<pre>
Solve a real band system using the factors computed by
SNBCO or SNBFA.
</pre>
</ul>
<h3> <a name="NORMAL"> NORMAL </a> </h3>
<ul>
<li><a href=rgauss.f.html> rgauss </a>
<pre>
Generate a normally distributed (Gaussian) random number.
</pre>
</ul>
<h3> <a name="NORMAL_EQUATIONS"> NORMAL EQUATIONS </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=isdcgn.f.html> isdcgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isscgn.f.html> isscgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="NORMAL_EQUATIONS."> NORMAL EQUATIONS. </a> </h3>
<ul>
<li><a href=dcgn.f.html> dcgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=scgn.f.html> scgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
</ul>
<h3> <a name="NUMBER_SORTING"> NUMBER SORTING </a> </h3>
<ul>
<li><a href=dpsort.f.html> dpsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=ipsort.f.html> ipsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=spsort.f.html> spsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
</ul>
<h3> <a name="NUMERICAL_INTEGRATION"> NUMERICAL INTEGRATION </a> </h3>
<ul>
<li><a href=dgaus8.f.html> dgaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=dpchia.f.html> dpchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=dpchid.f.html> dpchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=gaus8.f.html> gaus8 </a>
<pre>
Integrate a real function of one variable over a finite
interval using an adaptive 8-point Legendre-Gauss
algorithm.  Intended primarily for high accuracy
integration or integration of smooth functions.
</pre>
<li><a href=pchia.f.html> pchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=pchid.f.html> pchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
</ul>
<h3> <a name="ODE"> ODE </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="ORDER_ONE"> ORDER ONE </a> </h3>
<ul>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besj1.f.html> besj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=besy1.f.html> besy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesj1.f.html> dbesj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbesy1.f.html> dbesy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
</ul>
<h3> <a name="ORDER_ZERO"> ORDER ZERO </a> </h3>
<ul>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besj0.f.html> besj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besy0.f.html> besy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesj0.f.html> dbesj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesy0.f.html> dbesy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
</ul>
<h3> <a name="ORDINARY_DIFFERENTIAL_EQUATIONS"> ORDINARY DIFFERENTIAL EQUATIONS </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="ORTHOGONAL_POLYNOMIAL"> ORTHOGONAL POLYNOMIAL </a> </h3>
<ul>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
</ul>
<h3> <a name="ORTHOGONAL_SERIES"> ORTHOGONAL SERIES </a> </h3>
<ul>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
</ul>
<h3> <a name="ORTHOGONAL_TRIANGULAR"> ORTHOGONAL TRIANGULAR </a> </h3>
<ul>
<li><a href=cqrdc.f.html> cqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=cqrsl.f.html> cqrsl </a>
<pre>
Apply the output of CQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=dqrdc.f.html> dqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=dqrsl.f.html> dqrsl </a>
<pre>
Apply the output of DQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=sqrdc.f.html> sqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=sqrsl.f.html> sqrsl </a>
<pre>
Apply the output of SQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
</ul>
<h3> <a name="ORTHOMIN"> ORTHOMIN </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=domn.f.html> domn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=somn.f.html> somn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
</ul>
<h3> <a name="ORTHONORMALIZATION"> ORTHONORMALIZATION </a> </h3>
<ul>
<li><a href=bvsup.f.html> bvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
<li><a href=dbvsup.f.html> dbvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
</ul>
<h3> <a name="PACK"> PACK </a> </h3>
<ul>
<li><a href=d9pak.f.html> d9pak </a>
<pre>
Pack a base 2 exponent into a floating point number.
</pre>
<li><a href=r9pak.f.html> r9pak </a>
<pre>
Pack a base 2 exponent into a floating point number.
</pre>
</ul>
<h3> <a name="PACKED"> PACKED </a> </h3>
<ul>
<li><a href=chpco.f.html> chpco </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=chpdi.f.html> chpdi </a>
<pre>
Compute the determinant, inertia and inverse of a complex
Hermitian matrix stored in packed form using the factors
obtained from CHPFA.
</pre>
<li><a href=chpfa.f.html> chpfa </a>
<pre>
Factor a complex Hermitian matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=cppfa.f.html> cppfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=cspfa.f.html> cspfa </a>
<pre>
Factor a complex symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dppfa.f.html> dppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dspfa.f.html> dspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=sppfa.f.html> sppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=sspev.f.html> sspev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix stored in packed form.
</pre>
<li><a href=sspfa.f.html> sspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
</ul>
<h3> <a name="PASSIVE_SORTING"> PASSIVE SORTING </a> </h3>
<ul>
<li><a href=dpsort.f.html> dpsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=hpsort.f.html> hpsort </a>
<pre>
Return the permutation vector generated by sorting a
substring within a character array and, optionally,
rearrange the elements of the array.  The array may be
sorted in forward or reverse lexicographical order.  A
slightly modified quicksort algorithm is used.
</pre>
<li><a href=ipsort.f.html> ipsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=spsort.f.html> spsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
</ul>
<h3> <a name="PCHIP"> PCHIP </a> </h3>
<ul>
<li><a href=chfdv.f.html> chfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by PCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use CHFEV instead.
</pre>
<li><a href=chfev.f.html> chfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by PCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
<li><a href=dchfdv.f.html> dchfdv </a>
<pre>
Evaluate a cubic polynomial given in Hermite form and its
first derivative at an array of points.  While designed for
use by DPCHFD, it may be useful directly as an evaluator
for a piecewise cubic Hermite function in applications,
such as graphing, where the interval is known in advance.
If only function values are required, use DCHFEV instead.
</pre>
<li><a href=dchfev.f.html> dchfev </a>
<pre>
Evaluate a cubic polynomial given in Hermite form at an
array of points.  While designed for use by DPCHFE, it may
be useful directly as an evaluator for a piecewise cubic
Hermite function in applications, such as graphing, where
the interval is known in advance.
</pre>
<li><a href=dpchcm.f.html> dpchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=dpchfd.f.html> dpchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for DPCHIM
or DPCHIC. If only function values are required, use
DPCHFE instead.
</pre>
<li><a href=dpchfe.f.html> dpchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for DPCHIM or DPCHIC.
</pre>
<li><a href=dpchia.f.html> dpchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=dpchic.f.html> dpchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=dpchid.f.html> dpchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=dpchim.f.html> dpchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See DPCHIC if user control
is desired over boundary or switch conditions.)
</pre>
<li><a href=dpchsp.f.html> dpchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
<li><a href=pchcm.f.html> pchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=pchdoc.f.html> pchdoc </a>
<pre>
Documentation for PCHIP, a Fortran package for piecewise
cubic Hermite interpolation of data.
</pre>
<li><a href=pchfd.f.html> pchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for PCHIM
or PCHIC.  If only function values are required, use
PCHFE instead.
</pre>
<li><a href=pchfe.f.html> pchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for PCHIM or PCHIC.
</pre>
<li><a href=pchia.f.html> pchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=pchic.f.html> pchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=pchid.f.html> pchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=pchim.f.html> pchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See PCHIC if user control is
desired over boundary or switch conditions.)
</pre>
<li><a href=pchsp.f.html> pchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
</ul>
<h3> <a name="PDE"> PDE </a> </h3>
<ul>
<li><a href=genbun.f.html> genbun </a>
<pre>
Solve by a cyclic reduction algorithm the linear system
of equations that results from a finite difference
approximation to certain 2-d elliptic PDE's on a centered
grid .
</pre>
<li><a href=hstcrt.f.html> hstcrt </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in Cartesian coordinates.
</pre>
<li><a href=hstcsp.f.html> hstcsp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified Helmholtz
equation in spherical coordinates assuming axisymmetry
(no dependence on longitude).
</pre>
<li><a href=hstcyl.f.html> hstcyl </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified
Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hstplr.f.html> hstplr </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in polar coordinates.
</pre>
<li><a href=hstssp.f.html> hstssp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz
equation in spherical coordinates and on the surface of
the unit sphere (radius of 1).
</pre>
<li><a href=hw3crt.f.html> hw3crt </a>
<pre>
Solve the standard seven-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscrt.f.html> hwscrt </a>
<pre>
Solves the standard five-point finite difference
approximation to the Helmholtz equation in Cartesian
coordinates.
</pre>
<li><a href=hwscsp.f.html> hwscsp </a>
<pre>
Solve a finite difference approximation to the modified
Helmholtz equation in spherical coordinates assuming
axisymmetry  (no dependence on longitude).
</pre>
<li><a href=hwscyl.f.html> hwscyl </a>
<pre>
Solve a standard finite difference approximation
to the Helmholtz equation in cylindrical coordinates.
</pre>
<li><a href=hwsplr.f.html> hwsplr </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in polar coordinates.
</pre>
<li><a href=hwsssp.f.html> hwsssp </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in spherical coordinates and on the surface of the
unit sphere (radius of 1).
</pre>
<li><a href=poistg.f.html> poistg </a>
<pre>
Solve a block tridiagonal system of linear equations
that results from a staggered grid finite difference
approximation to 2-D elliptic PDE's.
</pre>
<li><a href=sepeli.f.html> sepeli </a>
<pre>
Discretize and solve a second and, optionally, a fourth
order finite difference approximation on a uniform grid to
the general separable elliptic partial differential
equation on a rectangle with any combination of periodic or
mixed boundary conditions.
</pre>
<li><a href=sepx4.f.html> sepx4 </a>
<pre>
Solve for either the second or fourth order finite
difference approximation to the solution of a separable
elliptic partial differential equation on a rectangle.
Any combination of periodic or mixed boundary conditions is
allowed.
</pre>
</ul>
<h3> <a name="PERMUTATION"> PERMUTATION </a> </h3>
<ul>
<li><a href=dpperm.f.html> dpperm </a>
<pre>
Rearrange a given array according to a prescribed
permutation vector.
</pre>
</ul>
<h3> <a name="PERRON'S_CONTINUED_FRACTION"> PERRON'S CONTINUED FRACTION </a> </h3>
<ul>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
</ul>
<h3> <a name="PHASE"> PHASE </a> </h3>
<ul>
<li><a href=d9aimp.f.html> d9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=d9b0mp.f.html> d9b0mp </a>
<pre>
Evaluate the modulus and phase for the J0 and Y0 Bessel
functions.
</pre>
<li><a href=d9b1mp.f.html> d9b1mp </a>
<pre>
Evaluate the modulus and phase for the J1 and Y1 Bessel
functions.
</pre>
<li><a href=r9aimp.f.html> r9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
</ul>
<h3> <a name="PIECEWISE_CUBIC_EVALUATION"> PIECEWISE CUBIC EVALUATION </a> </h3>
<ul>
<li><a href=dpchfd.f.html> dpchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for DPCHIM
or DPCHIC. If only function values are required, use
DPCHFE instead.
</pre>
<li><a href=dpchfe.f.html> dpchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for DPCHIM or DPCHIC.
</pre>
<li><a href=pchfd.f.html> pchfd </a>
<pre>
Evaluate a piecewise cubic Hermite function and its first
derivative at an array of points.  May be used by itself
for Hermite interpolation, or as an evaluator for PCHIM
or PCHIC.  If only function values are required, use
PCHFE instead.
</pre>
<li><a href=pchfe.f.html> pchfe </a>
<pre>
Evaluate a piecewise cubic Hermite function at an array of
points.  May be used by itself for Hermite interpolation,
or as an evaluator for PCHIM or PCHIC.
</pre>
</ul>
<h3> <a name="PIECEWISE_CUBIC_INTERPOLATION"> PIECEWISE CUBIC INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchbs.f.html> dpchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=dpchcm.f.html> dpchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=dpchic.f.html> dpchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=dpchim.f.html> dpchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See DPCHIC if user control
is desired over boundary or switch conditions.)
</pre>
<li><a href=dpchsp.f.html> dpchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
<li><a href=pchbs.f.html> pchbs </a>
<pre>
Piecewise Cubic Hermite to B-Spline converter.
</pre>
<li><a href=pchcm.f.html> pchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=pchdoc.f.html> pchdoc </a>
<pre>
Documentation for PCHIP, a Fortran package for piecewise
cubic Hermite interpolation of data.
</pre>
<li><a href=pchic.f.html> pchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=pchim.f.html> pchim </a>
<pre>
Set derivatives needed to determine a monotone piecewise
cubic Hermite interpolant to given data.  Boundary values
are provided which are compatible with monotonicity.  The
interpolant will have an extremum at each point where mono-
tonicity switches direction.  (See PCHIC if user control is
desired over boundary or switch conditions.)
</pre>
<li><a href=pchsp.f.html> pchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
</ul>
<h3> <a name="PIECEWISE_POLYNOMIAL"> PIECEWISE POLYNOMIAL </a> </h3>
<ul>
<li><a href=bsppp.f.html> bsppp </a>
<pre>
Convert the B-representation of a B-spline to the piecewise
polynomial (PP) form.
</pre>
<li><a href=dbsppp.f.html> dbsppp </a>
<pre>
Convert the B-representation of a B-spline to the piecewise
polynomial (PP) form.
</pre>
</ul>
<h3> <a name="PLANE_ROTATION"> PLANE ROTATION </a> </h3>
<ul>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
</ul>
<h3> <a name="POCHHAMMER"> POCHHAMMER </a> </h3>
<ul>
<li><a href=dpoch.f.html> dpoch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=dpoch1.f.html> dpoch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=poch.f.html> poch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=poch1.f.html> poch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
</ul>
<h3> <a name="POISSON"> POISSON </a> </h3>
<ul>
<li><a href=pois3d.f.html> pois3d </a>
<pre>
Solve a three-dimensional block tridiagonal linear system
which arises from a finite difference approximation to a
three-dimensional Poisson equation using the Fourier
transform package FFTPAK written by Paul Swarztrauber.
</pre>
</ul>
<h3> <a name="POLAR"> POLAR </a> </h3>
<ul>
<li><a href=hstplr.f.html> hstplr </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz equation
in polar coordinates.
</pre>
<li><a href=hwsplr.f.html> hwsplr </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in polar coordinates.
</pre>
</ul>
<h3> <a name="POLAR_ANGEL"> POLAR ANGEL </a> </h3>
<ul>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
</ul>
<h3> <a name="POLYGAMMA_FUNCTION"> POLYGAMMA FUNCTION </a> </h3>
<ul>
<li><a href=dpsifn.f.html> dpsifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
<li><a href=psifn.f.html> psifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
</ul>
<h3> <a name="POLYNOMIAL"> POLYNOMIAL </a> </h3>
<ul>
<li><a href=dpolcf.f.html> dpolcf </a>
<pre>
Compute the coefficients of the polynomial fit (including
Hermite polynomial fits) produced by a previous call to
POLINT.
</pre>
<li><a href=polcof.f.html> polcof </a>
<pre>
Compute the coefficients of the polynomial fit (including
Hermite polynomial fits) produced by a previous call to
POLINT.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_APPROXIMATION"> POLYNOMIAL APPROXIMATION </a> </h3>
<ul>
<li><a href=dp1vlu.f.html> dp1vlu </a>
<pre>
Use the coefficients generated by DPOLFT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
<li><a href=pvalue.f.html> pvalue </a>
<pre>
Use the coefficients generated by POLFIT to evaluate the
polynomial fit of degree L, along with the first NDER of
its derivatives, at a specified point.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_EVALUATION"> POLYNOMIAL EVALUATION </a> </h3>
<ul>
<li><a href=dpolvl.f.html> dpolvl </a>
<pre>
Calculate the value of a polynomial and its first NDER
derivatives where the polynomial was produced by a previous
call to DPLINT.
</pre>
<li><a href=polyvl.f.html> polyvl </a>
<pre>
Calculate the value of a polynomial and its first NDER
derivatives where the polynomial was produced by a previous
call to POLINT.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_FIT"> POLYNOMIAL FIT </a> </h3>
<ul>
<li><a href=dpcoef.f.html> dpcoef </a>
<pre>
Convert the DPOLFT coefficients to Taylor series form.
</pre>
<li><a href=dpolft.f.html> dpolft </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
<li><a href=pcoef.f.html> pcoef </a>
<pre>
Convert the POLFIT coefficients to Taylor series form.
</pre>
<li><a href=polfit.f.html> polfit </a>
<pre>
Fit discrete data in a least squares sense by polynomials
in one variable.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_INTERPOLATION"> POLYNOMIAL INTERPOLATION </a> </h3>
<ul>
<li><a href=dplint.f.html> dplint </a>
<pre>
Produce the polynomial which interpolates a set of discrete
data points.
</pre>
<li><a href=polint.f.html> polint </a>
<pre>
Produce the polynomial which interpolates a set of discrete
data points.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_ROOTS"> POLYNOMIAL ROOTS </a> </h3>
<ul>
<li><a href=cpqr79.f.html> cpqr79 </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=cpzero.f.html> cpzero </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=rpqr79.f.html> rpqr79 </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
<li><a href=rpzero.f.html> rpzero </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
</ul>
<h3> <a name="POLYNOMIAL_ZEROS"> POLYNOMIAL ZEROS </a> </h3>
<ul>
<li><a href=cpqr79.f.html> cpqr79 </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=cpzero.f.html> cpzero </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=rpqr79.f.html> rpqr79 </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
<li><a href=rpzero.f.html> rpzero </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
</ul>
<h3> <a name="POSITIVE_DEFINITE"> POSITIVE DEFINITE </a> </h3>
<ul>
<li><a href=cchdc.f.html> cchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=cchex.f.html> cchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=cpbco.f.html> cpbco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form and estimate the condition number of the
matrix.
</pre>
<li><a href=cpbdi.f.html> cpbdi </a>
<pre>
Compute the determinant of a complex Hermitian positive
definite band matrix using the factors computed by CPBCO or
CPBFA.
</pre>
<li><a href=cpbfa.f.html> cpbfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in band form.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=cpoco.f.html> cpoco </a>
<pre>
Factor a complex Hermitian positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=cpodi.f.html> cpodi </a>
<pre>
Compute the determinant and inverse of a certain complex
Hermitian positive definite matrix using the factors
computed by CPOCO, CPOFA, or CQRDC.
</pre>
<li><a href=cpofa.f.html> cpofa </a>
<pre>
Factor a complex Hermitian positive definite matrix.
</pre>
<li><a href=cpofs.f.html> cpofs </a>
<pre>
Solve a positive definite symmetric complex system of
linear equations.
</pre>
<li><a href=cpoir.f.html> cpoir </a>
<pre>
Solve a positive definite Hermitian system of linear
equations.  Iterative refinement is used to obtain an
error estimate.
</pre>
<li><a href=cposl.f.html> cposl </a>
<pre>
Solve the complex Hermitian positive definite linear system
using the factors computed by CPOCO or CPOFA.
</pre>
<li><a href=cppco.f.html> cppco </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=cppdi.f.html> cppdi </a>
<pre>
Compute the determinant and inverse of a complex Hermitian
positive definite matrix using factors from CPPCO or CPPFA.
</pre>
<li><a href=cppfa.f.html> cppfa </a>
<pre>
Factor a complex Hermitian positive definite matrix stored
in packed form.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dchdc.f.html> dchdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=dchex.f.html> dchex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of a
positive definite matrix A of order P under diagonal
permutations of the form  TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=dpbco.f.html> dpbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=dpbdi.f.html> dpbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpbfa.f.html> dpbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
in band form.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dpoco.f.html> dpoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition of the matrix.
</pre>
<li><a href=dpodi.f.html> dpodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by DPOCO, DPOFA or DQRDC.
</pre>
<li><a href=dpofa.f.html> dpofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=dpofs.f.html> dpofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=dposl.f.html> dposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by DPOCO or DPOFA.
</pre>
<li><a href=dppco.f.html> dppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=dppdi.f.html> dppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from DPPCO or DPPFA.
</pre>
<li><a href=dppfa.f.html> dppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=schdc.f.html> schdc </a>
<pre>
Compute the Cholesky decomposition of a positive definite
matrix.  A pivoting option allows the user to estimate the
condition number of a positive definite matrix or determine
the rank of a positive semidefinite matrix.
</pre>
<li><a href=schex.f.html> schex </a>
<pre>
Update the Cholesky factorization  A=TRANS(R)*R  of A
positive definite matrix A of order P under diagonal
permutations of the form TRANS(E)*A*E, where E is a
permutation matrix.
</pre>
<li><a href=spbco.f.html> spbco </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form and estimate the condition number of the matrix.
</pre>
<li><a href=spbdi.f.html> spbdi </a>
<pre>
Compute the determinant of a symmetric positive definite
band matrix using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spbfa.f.html> spbfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
band form.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=spoco.f.html> spoco </a>
<pre>
Factor a real symmetric positive definite matrix
and estimate the condition number of the matrix.
</pre>
<li><a href=spodi.f.html> spodi </a>
<pre>
Compute the determinant and inverse of a certain real
symmetric positive definite matrix using the factors
computed by SPOCO, SPOFA or SQRDC.
</pre>
<li><a href=spofa.f.html> spofa </a>
<pre>
Factor a real symmetric positive definite matrix.
</pre>
<li><a href=spofs.f.html> spofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=spoir.f.html> spoir </a>
<pre>
Solve a positive definite symmetric system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=sposl.f.html> sposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by SPOCO or SPOFA.
</pre>
<li><a href=sppco.f.html> sppco </a>
<pre>
Factor a symmetric positive definite matrix stored in
packed form and estimate the condition number of the
matrix.
</pre>
<li><a href=sppdi.f.html> sppdi </a>
<pre>
Compute the determinant and inverse of a real symmetric
positive definite matrix using factors from SPPCO or SPPFA.
</pre>
<li><a href=sppfa.f.html> sppfa </a>
<pre>
Factor a real symmetric positive definite matrix stored in
packed form.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
</ul>
<h3> <a name="POWELL_HYBRID_METHOD"> POWELL HYBRID METHOD </a> </h3>
<ul>
<li><a href=dnsq.f.html> dnsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=dnsqe.f.html> dnsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
<li><a href=snsq.f.html> snsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=snsqe.f.html> snsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
</ul>
<h3> <a name="PRECONDITIONED_CONJUGATE_GRADIENT"> PRECONDITIONED CONJUGATE GRADIENT </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="PREDICTOR-CORRECTOR"> PREDICTOR-CORRECTOR </a> </h3>
<ul>
<li><a href=ddeabm.f.html> ddeabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=deabm.f.html> deabm </a>
<pre>
Solve an initial value problem in ordinary differential
equations using an Adams-Bashforth method.
</pre>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=dsteps.f.html> dsteps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
<li><a href=steps.f.html> steps </a>
<pre>
Integrate a system of first order ordinary differential
equations one step.
</pre>
</ul>
<h3> <a name="PRINTING"> PRINTING </a> </h3>
<ul>
<li><a href=xerprn.f.html> xerprn </a>
<pre>
Print error messages processed by XERMSG.
</pre>
</ul>
<h3> <a name="PSI_FUNCTION"> PSI FUNCTION </a> </h3>
<ul>
<li><a href=cpsi.f.html> cpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=dpsi.f.html> dpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=dpsifn.f.html> dpsifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
<li><a href=dxpsi.f.html> dxpsi </a>
<pre>
To compute values of the Psi function for DXLEGF.
</pre>
<li><a href=psifn.f.html> psifn </a>
<pre>
Compute derivatives of the Psi function.
</pre>
<li><a href=psi.f.html> psi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=xpsi.f.html> xpsi </a>
<pre>
To compute values of the Psi function for XLEGF.
</pre>
</ul>
<h3> <a name="QL_METHOD"> QL METHOD </a> </h3>
<ul>
<li><a href=tql1.f.html> tql1 </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix by
the QL method.
</pre>
<li><a href=tqlrat.f.html> tqlrat </a>
<pre>
Compute the eigenvalues of symmetric tridiagonal matrix
using a rational variant of the QL method.
</pre>
</ul>
<h3> <a name="QR_DECOMPOSITION"> QR DECOMPOSITION </a> </h3>
<ul>
<li><a href=cqrdc.f.html> cqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=dqrdc.f.html> dqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
<li><a href=sqrdc.f.html> sqrdc </a>
<pre>
Use Householder transformations to compute the QR
factorization of an N by P matrix.  Column pivoting is a
users option.
</pre>
</ul>
<h3> <a name="QR_FACTORIZATION"> QR FACTORIZATION </a> </h3>
<ul>
<li><a href=dglss.f.html> dglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=dllsia.f.html> dllsia </a>
<pre>
Solve linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=hfti.f.html> hfti </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.
</pre>
<li><a href=llsia.f.html> llsia </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=sglss.f.html> sglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
</ul>
<h3> <a name="QUADPACK"> QUADPACK </a> </h3>
<ul>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqc25c.f.html> dqc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=dqc25f.f.html> dqc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) or W(X)=SIN(OMEGA*X) and to
compute J = Integral of ABS(F) over (A,B). For small value
of OMEGA or small intervals (A,B) the 15-point GAUSS-KRONRO
Rule is used. Otherwise a generalized CLENSHAW-CURTIS
method is used.
</pre>
<li><a href=dqc25s.f.html> dqc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
<li><a href=dqk15.f.html> dqk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk15i.f.html> dqk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=dqk15w.f.html> dqk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
<li><a href=dqk21.f.html> dqk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk31.f.html> dqk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk41.f.html> dqk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk51.f.html> dqk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk61.f.html> dqk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqmomo.f.html> dqmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qc25c.f.html> qc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=qc25f.f.html> qc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) Or (WX)=SIN(OMEGA*X)
and to compute J=Integral of ABS(F) over (A,B). For small
value of OMEGA or small intervals (A,B) 15-point GAUSS-
KRONROD Rule used. Otherwise generalized CLENSHAW-CURTIS us
</pre>
<li><a href=qc25s.f.html> qc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
<li><a href=qk15.f.html> qk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=qk15i.f.html> qk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=qk15w.f.html> qk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
<li><a href=qk21.f.html> qk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk31.f.html> qk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk41.f.html> qk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk51.f.html> qk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk61.f.html> qk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qmomo.f.html> qmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qpdoc.f.html> qpdoc </a>
<pre>
Documentation for QUADPACK, a package of subprograms for
automatic evaluation of one-dimensional definite integrals.
</pre>
</ul>
<h3> <a name="QUADRANT"> QUADRANT </a> </h3>
<ul>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
</ul>
<h3> <a name="QUADRATIC_PROGRAMMING"> QUADRATIC PROGRAMMING </a> </h3>
<ul>
<li><a href=dlsei.f.html> dlsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=dwnnls.f.html> dwnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
<li><a href=lsei.f.html> lsei </a>
<pre>
Solve a linearly constrained least squares problem with
equality and inequality constraints, and optionally compute
a covariance matrix.
</pre>
<li><a href=wnnls.f.html> wnnls </a>
<pre>
Solve a linearly constrained least squares problem with
equality constraints and nonnegativity constraints on
selected variables.
</pre>
</ul>
<h3> <a name="QUADRATURE"> QUADRATURE </a> </h3>
<ul>
<li><a href=avint.f.html> avint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
<li><a href=bfqad.f.html> bfqad </a>
<pre>
Compute the integral of a product of a function and a
derivative of a B-spline.
</pre>
<li><a href=bsqad.f.html> bsqad </a>
<pre>
Compute the integral of a K-th order B-spline using the
B-representation.
</pre>
<li><a href=davint.f.html> davint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
<li><a href=dbfqad.f.html> dbfqad </a>
<pre>
Compute the integral of a product of a function and a
derivative of a K-th order B-spline.
</pre>
<li><a href=dbsqad.f.html> dbsqad </a>
<pre>
Compute the integral of a K-th order B-spline using the
B-representation.
</pre>
<li><a href=dpchia.f.html> dpchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=dpchid.f.html> dpchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=dpfqad.f.html> dpfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a
function F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=dppqad.f.html> dppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=dqag.f.html> dqag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqage.f.html> dqage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=dqags.f.html> dqags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagse.f.html> dqagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqc25c.f.html> dqc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=dqc25f.f.html> dqc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) or W(X)=SIN(OMEGA*X) and to
compute J = Integral of ABS(F) over (A,B). For small value
of OMEGA or small intervals (A,B) the 15-point GAUSS-KRONRO
Rule is used. Otherwise a generalized CLENSHAW-CURTIS
method is used.
</pre>
<li><a href=dqc25s.f.html> dqc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
<li><a href=dqk15.f.html> dqk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk15i.f.html> dqk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=dqk15w.f.html> dqk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
<li><a href=dqk21.f.html> dqk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk31.f.html> dqk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk41.f.html> dqk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk51.f.html> dqk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqk61.f.html> dqk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=dqmomo.f.html> dqmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=pchia.f.html> pchia </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an arbitrary interval.
</pre>
<li><a href=pchid.f.html> pchid </a>
<pre>
Evaluate the definite integral of a piecewise cubic
Hermite function over an interval whose endpoints are data
points.
</pre>
<li><a href=pfqad.f.html> pfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a function
F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=ppqad.f.html> ppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=qag.f.html> qag </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT)LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qage.f.html> qage </a>
<pre>
The routine calculates an approximation result to a given
definite integral   I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESLT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qags.f.html> qags </a>
<pre>
The routine calculates an approximation result to a given
Definite integral  I = Integral of F over (A,B),
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagse.f.html> qagse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qc25c.f.html> qc25c </a>
<pre>
To compute I = Integral of F*W over (A,B) with
error estimate, where W(X) = 1/(X-C)
</pre>
<li><a href=qc25f.f.html> qc25f </a>
<pre>
To compute the integral I=Integral of F(X) over (A,B)
Where W(X) = COS(OMEGA*X) Or (WX)=SIN(OMEGA*X)
and to compute J=Integral of ABS(F) over (A,B). For small
value of OMEGA or small intervals (A,B) 15-point GAUSS-
KRONROD Rule used. Otherwise generalized CLENSHAW-CURTIS us
</pre>
<li><a href=qc25s.f.html> qc25s </a>
<pre>
To compute I = Integral of F*W over (BL,BR), with error
estimate, where the weight function W has a singular
behaviour of ALGEBRAICO-LOGARITHMIC type at the points
A and/or B. (BL,BR) is a part of (A,B).
</pre>
<li><a href=qk15.f.html> qk15 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = integral of ABS(F) over (A,B)
</pre>
<li><a href=qk15i.f.html> qk15i </a>
<pre>
The original (infinite integration range is mapped
onto the interval (0,1) and (A,B) is a part of (0,1).
it is the purpose to compute
I = Integral of transformed integrand over (A,B),
J = Integral of ABS(Transformed Integrand) over (A,B).
</pre>
<li><a href=qk15w.f.html> qk15w </a>
<pre>
To compute I = Integral of F*W over (A,B), with error
               estimate
           J = Integral of ABS(F*W) over (A,B)
</pre>
<li><a href=qk21.f.html> qk21 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk31.f.html> qk31 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk41.f.html> qk41 </a>
<pre>
To compute I = Integral of F over (A,B), with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk51.f.html> qk51 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qk61.f.html> qk61 </a>
<pre>
To compute I = Integral of F over (A,B) with error
               estimate
           J = Integral of ABS(F) over (A,B)
</pre>
<li><a href=qmomo.f.html> qmomo </a>
<pre>
This routine computes modified Chebyshev moments.  The K-th
modified Chebyshev moment is defined as the integral over
(-1,1) of W(X)*T(K,X), where T(K,X) is the Chebyshev
polynomial of degree K.
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qpdoc.f.html> qpdoc </a>
<pre>
Documentation for QUADPACK, a package of subprograms for
automatic evaluation of one-dimensional definite integrals.
</pre>
</ul>
<h3> <a name="RACAH_COEFFICIENTS"> RACAH COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="RANDOM_NUMBER"> RANDOM NUMBER </a> </h3>
<ul>
<li><a href=rand.f.html> rand </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=rgauss.f.html> rgauss </a>
<pre>
Generate a normally distributed (Gaussian) random number.
</pre>
<li><a href=runif.f.html> runif </a>
<pre>
Generate a uniformly distributed random number.
</pre>
</ul>
<h3> <a name="REAL_ROOTS"> REAL ROOTS </a> </h3>
<ul>
<li><a href=cpzero.f.html> cpzero </a>
<pre>
Find the zeros of a polynomial with complex coefficients.
</pre>
<li><a href=rpzero.f.html> rpzero </a>
<pre>
Find the zeros of a polynomial with real coefficients.
</pre>
</ul>
<h3> <a name="REARRANGEMENT"> REARRANGEMENT </a> </h3>
<ul>
<li><a href=dpperm.f.html> dpperm </a>
<pre>
Rearrange a given array according to a prescribed
permutation vector.
</pre>
</ul>
<h3> <a name="RECALL"> RECALL </a> </h3>
<ul>
<li><a href=j4save.f.html> j4save </a>
<pre>
Save or recall global variables needed by error
handling routines.
</pre>
</ul>
<h3> <a name="RECIPROCAL_GAMMA_FUNCTION"> RECIPROCAL GAMMA FUNCTION </a> </h3>
<ul>
<li><a href=cgamr.f.html> cgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=dgamr.f.html> dgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=gamr.f.html> gamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
</ul>
<h3> <a name="RELATIVE_ADDRESS_DETERMINATION_FUNCTION"> RELATIVE ADDRESS DETERMINATION FUNCTION </a> </h3>
<ul>
<li><a href=idloc.f.html> idloc </a>
<pre>
Subsidiary to DSPLP
</pre>
<li><a href=iploc.f.html> iploc </a>
<pre>
Subsidiary to SPLP
</pre>
</ul>
<h3> <a name="RKF"> RKF </a> </h3>
<ul>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
</ul>
<h3> <a name="ROOTS"> ROOTS </a> </h3>
<ul>
<li><a href=cbrt.f.html> cbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=ccbrt.f.html> ccbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=dcbrt.f.html> dcbrt </a>
<pre>
Compute the cube root.
</pre>
<li><a href=dfzero.f.html> dfzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=dsos.f.html> dsos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
<li><a href=fzero.f.html> fzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=sos.f.html> sos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
</ul>
<h3> <a name="RUNGE-KUTTA-FEHLBERG_METHODS"> RUNGE-KUTTA-FEHLBERG METHODS </a> </h3>
<ul>
<li><a href=dderkf.f.html> dderkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
<li><a href=derkf.f.html> derkf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using a Runge-Kutta-Fehlberg scheme.
</pre>
</ul>
<h3> <a name="SAVE"> SAVE </a> </h3>
<ul>
<li><a href=j4save.f.html> j4save </a>
<pre>
Save or recall global variables needed by error
handling routines.
</pre>
</ul>
<h3> <a name="SCALE"> SCALE </a> </h3>
<ul>
<li><a href=cscal.f.html> cscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=csscal.f.html> csscal </a>
<pre>
Scale a complex vector.
</pre>
<li><a href=dscal.f.html> dscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=sscal.f.html> sscal </a>
<pre>
Multiply a vector by a constant.
</pre>
</ul>
<h3> <a name="SDRIVE"> SDRIVE </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
</ul>
<h3> <a name="SECOND_KIND"> SECOND KIND </a> </h3>
<ul>
<li><a href=besy0.f.html> besy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=besy1.f.html> besy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=dbesy0.f.html> dbesy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbesy1.f.html> dbesy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
</ul>
<h3> <a name="SECOND_ORDER"> SECOND ORDER </a> </h3>
<ul>
<li><a href=c9ln2r.f.html> c9ln2r </a>
<pre>
Evaluate LOG(1+Z) from second order relative accuracy so
that  LOG(1+Z) = Z - Z**2/2 + Z**3*C9LN2R(Z).
</pre>
<li><a href=d9ln2r.f.html> d9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*D9LN2R(X)
</pre>
<li><a href=r9ln2r.f.html> r9ln2r </a>
<pre>
Evaluate LOG(1+X) from second order relative accuracy so
that LOG(1+X) = X - X**2/2 + X**3*R9LN2R(X).
</pre>
</ul>
<h3> <a name="SEPARABLE"> SEPARABLE </a> </h3>
<ul>
<li><a href=sepeli.f.html> sepeli </a>
<pre>
Discretize and solve a second and, optionally, a fourth
order finite difference approximation on a uniform grid to
the general separable elliptic partial differential
equation on a rectangle with any combination of periodic or
mixed boundary conditions.
</pre>
<li><a href=sepx4.f.html> sepx4 </a>
<pre>
Solve for either the second or fourth order finite
difference approximation to the solution of a separable
elliptic partial differential equation on a rectangle.
Any combination of periodic or mixed boundary conditions is
allowed.
</pre>
</ul>
<h3> <a name="SEQUENCE_OF_BESSEL_FUNCTIONS"> SEQUENCE OF BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
</ul>
<h3> <a name="SEQUENTIAL_SORTING"> SEQUENTIAL SORTING </a> </h3>
<ul>
<li><a href=dqpsrt.f.html> dqpsrt </a>
<pre>
This routine maintains the descending ordering in the
list of the local error estimated resulting from the
interval subdivision process. At each call two error
estimates are inserted using the sequential search
method, top-down for the largest error estimate and
bottom-up for the smallest error estimate.
</pre>
<li><a href=qpsrt.f.html> qpsrt </a>
<pre>
Subsidiary to QAGE, QAGIE, QAGPE, QAGSE, QAWCE, QAWOE and
QAWSE
</pre>
</ul>
<h3> <a name="SHAPE-PRESERVING_INTERPOLATION"> SHAPE-PRESERVING INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchic.f.html> dpchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
<li><a href=pchic.f.html> pchic </a>
<pre>
Set derivatives needed to determine a piecewise monotone
piecewise cubic Hermite interpolant to given data.
User control is available over boundary conditions and/or
treatment of points where monotonicity switches direction.
</pre>
</ul>
<h3> <a name="SHOOTING"> SHOOTING </a> </h3>
<ul>
<li><a href=bvsup.f.html> bvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
<li><a href=dbvsup.f.html> dbvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
</ul>
<h3> <a name="SINE"> SINE </a> </h3>
<ul>
<li><a href=dsindg.f.html> dsindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=sindg.f.html> sindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
</ul>
<h3> <a name="SINGLE_PRECISION"> SINGLE PRECISION </a> </h3>
<ul>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
</ul>
<h3> <a name="SINGLETON_QUICKSORT"> SINGLETON QUICKSORT </a> </h3>
<ul>
<li><a href=dpsort.f.html> dpsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=dsort.f.html> dsort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=hpsort.f.html> hpsort </a>
<pre>
Return the permutation vector generated by sorting a
substring within a character array and, optionally,
rearrange the elements of the array.  The array may be
sorted in forward or reverse lexicographical order.  A
slightly modified quicksort algorithm is used.
</pre>
<li><a href=ipsort.f.html> ipsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=isort.f.html> isort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1d.f.html> qs2i1d </a>
<pre>
Sort an integer array, moving an integer and DP array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the double pre-
cision array A.  The array IA may be sorted in increasing
order or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1r.f.html> qs2i1r </a>
<pre>
Sort an integer array, moving an integer and real array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the real array A.
The array IA may be sorted in increasing order or decreas-
ing order.  A slightly modified QUICKSORT algorithm is
used.
</pre>
<li><a href=spsort.f.html> spsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=ssort.f.html> ssort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
</ul>
<h3> <a name="SINGULAR_VALUE_DECOMPOSITION"> SINGULAR VALUE DECOMPOSITION </a> </h3>
<ul>
<li><a href=csvdc.f.html> csvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=dsvdc.f.html> dsvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
<li><a href=ssvdc.f.html> ssvdc </a>
<pre>
Perform the singular value decomposition of a rectangular
matrix.
</pre>
</ul>
<h3> <a name="SINGULARITIES_AT_USER_SPECIFIED_POINTS"> SINGULARITIES AT USER SPECIFIED POINTS </a> </h3>
<ul>
<li><a href=dqagp.f.html> dqagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur (e.g.
SINGULARITIES, DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=dqagpe.f.html> dqagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
<li><a href=qagp.f.html> qagp </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F over (A,B),
hopefully satisfying following claim for accuracy
break points of the integration interval, where local
difficulties of the integrand may occur(e.g. SINGULARITIES,
DISCONTINUITIES), are provided by the user.
</pre>
<li><a href=qagpe.f.html> qagpe </a>
<pre>
Approximate a given definite integral I = Integral of F
over (A,B), hopefully satisfying the accuracy claim:
      ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
Break points of the integration interval, where local
difficulties of the integrand may occur (e.g. singularities
or discontinuities) are provided by the user.
</pre>
</ul>
<h3> <a name="SLAP"> SLAP </a> </h3>
<ul>
<li><a href=dbcg.f.html> dbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=dcg.f.html> dcg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=dcgn.f.html> dcgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=dcgs.f.html> dcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=dchkw.f.html> dchkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
<li><a href=dgmres.f.html> dgmres </a>
<pre>
Preconditioned GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dhels.f.html> dhels </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dheqr.f.html> dheqr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dir.f.html> dir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=dllti2.f.html> dllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=domn.f.html> domn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=dorth.f.html> dorth </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dpigmr.f.html> dpigmr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=drlcal.f.html> drlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dsdbcg.f.html> dsdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=dsdcg.f.html> dsdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=dsdcgn.f.html> dsdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=dsdcgs.f.html> dsdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=dsdgmr.f.html> dsdgmr </a>
<pre>
Diagonally scaled GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dsdi.f.html> dsdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=dsdomn.f.html> dsdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=dsgs.f.html> dsgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=dsiccg.f.html> dsiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=dsilur.f.html> dsilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=dsilus.f.html> dsilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=dsjac.f.html> dsjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=dsli.f.html> dsli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=dsli2.f.html> dsli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=dsllti.f.html> dsllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=dslubc.f.html> dslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslucn.f.html> dslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=dslucs.f.html> dslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslugm.f.html> dslugm </a>
<pre>
Incomplete LU GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=dslui.f.html> dslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=dslui2.f.html> dslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=dslui4.f.html> dslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsluom.f.html> dsluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=dsluti.f.html> dsluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=dsmmi2.f.html> dsmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsmmti.f.html> dsmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=dsmtv.f.html> dsmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
<li><a href=dsmv.f.html> dsmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
<li><a href=dxlcal.f.html> dxlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=isdbcg.f.html> isdbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcg.f.html> isdcg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcgn.f.html> isdcgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isdcgs.f.html> isdcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=isdgmr.f.html> isdgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=isdir.f.html> isdir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issbcg.f.html> issbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscg.f.html> isscg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscgn.f.html> isscgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isscgs.f.html> isscgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=issgmr.f.html> issgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=issir.f.html> issir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=qs2i1d.f.html> qs2i1d </a>
<pre>
Sort an integer array, moving an integer and DP array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the double pre-
cision array A.  The array IA may be sorted in increasing
order or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1r.f.html> qs2i1r </a>
<pre>
Sort an integer array, moving an integer and real array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the real array A.
The array IA may be sorted in increasing order or decreas-
ing order.  A slightly modified QUICKSORT algorithm is
used.
</pre>
<li><a href=sbcg.f.html> sbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=scg.f.html> scg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=scgn.f.html> scgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=scgs.f.html> scgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=schkw.f.html> schkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
<li><a href=sir.f.html> sir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=sgmres.f.html> sgmres </a>
<pre>
Preconditioned GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=shels.f.html> shels </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sheqr.f.html> sheqr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sllti2.f.html> sllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=somn.f.html> somn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=sorth.f.html> sorth </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=spigmr.f.html> spigmr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=srlcal.f.html> srlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=ssdbcg.f.html> ssdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=ssdcg.f.html> ssdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=ssdcgn.f.html> ssdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=ssdcgs.f.html> ssdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=ssdgmr.f.html> ssdgmr </a>
<pre>
Diagonally Scaled GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=ssdi.f.html> ssdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=ssdomn.f.html> ssdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=ssgs.f.html> ssgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=ssiccg.f.html> ssiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=ssilur.f.html> ssilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=ssilus.f.html> ssilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=ssjac.f.html> ssjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=ssli.f.html> ssli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=ssli2.f.html> ssli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=ssllti.f.html> ssllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=sslubc.f.html> sslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslucn.f.html> sslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=sslucs.f.html> sslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslugm.f.html> sslugm </a>
<pre>
Incomplete LU GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=sslui.f.html> sslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=sslui2.f.html> sslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=sslui4.f.html> sslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssluom.f.html> ssluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=ssluti.f.html> ssluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=ssmmi2.f.html> ssmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssmmti.f.html> ssmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=ssmtv.f.html> ssmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
<li><a href=ssmv.f.html> ssmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
<li><a href=sxlcal.f.html> sxlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
</ul>
<h3> <a name="SLAP_SPARSE"> SLAP SPARSE </a> </h3>
<ul>
<li><a href=dbhin.f.html> dbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
<li><a href=dcpplt.f.html> dcpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=ds2lt.f.html> ds2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
<li><a href=ds2y.f.html> ds2y </a>
<pre>
SLAP Triad to SLAP Column Format Converter.
Routine to convert from the SLAP Triad to SLAP Column
format.
</pre>
<li><a href=dsd2s.f.html> dsd2s </a>
<pre>
Diagonal Scaling Preconditioner SLAP Normal Eqns Set Up.
Routine to compute the inverse of the diagonal of the
matrix A*A', where A is stored in SLAP-Column format.
</pre>
<li><a href=dsds.f.html> dsds </a>
<pre>
Diagonal Scaling Preconditioner SLAP Set Up.
Routine to compute the inverse of the diagonal of a matrix
stored in the SLAP Column format.
</pre>
<li><a href=dsdscl.f.html> dsdscl </a>
<pre>
Diagonal Scaling of system Ax = b.
This routine scales (and unscales) the system  Ax = b
by symmetric diagonal scaling.
</pre>
<li><a href=dsics.f.html> dsics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=dtin.f.html> dtin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=dtout.f.html> dtout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=sbhin.f.html> sbhin </a>
<pre>
Read a Sparse Linear System in the Boeing/Harwell Format.
The matrix is read in and if the right hand side is also
present in the input file then it too is read in.  The
matrix is then modified to be in the SLAP Column format.
</pre>
<li><a href=scpplt.f.html> scpplt </a>
<pre>
Printer Plot of SLAP Column Format Matrix.
Routine to print out a SLAP Column format matrix in a
"printer plot" graphical representation.
</pre>
<li><a href=ss2lt.f.html> ss2lt </a>
<pre>
Lower Triangle Preconditioner SLAP Set Up.
Routine to store the lower triangle of a matrix stored
in the SLAP Column format.
</pre>
<li><a href=ss2y.f.html> ss2y </a>
<pre>
SLAP Triad to SLAP Column Format Converter.
Routine to convert from the SLAP Triad to SLAP Column
format.
</pre>
<li><a href=ssd2s.f.html> ssd2s </a>
<pre>
Diagonal Scaling Preconditioner SLAP Normal Eqns Set Up.
Routine to compute the inverse of the diagonal of the
matrix A*A', where A is stored in SLAP-Column format.
</pre>
<li><a href=ssds.f.html> ssds </a>
<pre>
Diagonal Scaling Preconditioner SLAP Set Up.
Routine to compute the inverse of the diagonal of a matrix
stored in the SLAP Column format.
</pre>
<li><a href=ssdscl.f.html> ssdscl </a>
<pre>
Diagonal Scaling of system Ax = b.
This routine scales (and unscales) the system  Ax = b
by symmetric diagonal scaling.
</pre>
<li><a href=ssics.f.html> ssics </a>
<pre>
Incompl. Cholesky Decomposition Preconditioner SLAP Set Up.
Routine to generate the Incomplete Cholesky decomposition,
L*D*L-trans, of a symmetric positive definite matrix, A,
which is stored in SLAP Column format.  The unit lower
triangular matrix L is stored by rows, and the inverse of
the diagonal matrix D is stored.
</pre>
<li><a href=stin.f.html> stin </a>
<pre>
Read in SLAP Triad Format Linear System.
Routine to read in a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
<li><a href=stout.f.html> stout </a>
<pre>
Write out SLAP Triad Format Linear System.
Routine to write out a SLAP Triad format matrix and right
hand side and solution to the system, if known.
</pre>
</ul>
<h3> <a name="SLATEC"> SLATEC </a> </h3>
<ul>
<li><a href=idloc.f.html> idloc </a>
<pre>
Subsidiary to DSPLP
</pre>
<li><a href=iploc.f.html> iploc </a>
<pre>
Subsidiary to SPLP
</pre>
</ul>
<h3> <a name="SMALL_X"> SMALL X </a> </h3>
<ul>
<li><a href=d9gmic.f.html> d9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and X small.
</pre>
<li><a href=d9gmit.f.html> d9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=r9gmic.f.html> r9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and for small X.
</pre>
<li><a href=r9gmit.f.html> r9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
</ul>
<h3> <a name="SMOOTH_INTEGRAND"> SMOOTH INTEGRAND </a> </h3>
<ul>
<li><a href=dqng.f.html> dqng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qng.f.html> qng </a>
<pre>
The routine calculates an approximation result to a
given definite integral I = integral of F over (A,B),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="SMOOTH_INTERPOLANT"> SMOOTH INTERPOLANT </a> </h3>
<ul>
<li><a href=dintp.f.html> dintp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in DSTEPS at XOUT.  Must be used in
conjunction with DSTEPS.
</pre>
<li><a href=sintrp.f.html> sintrp </a>
<pre>
Approximate the solution at XOUT by evaluating the
polynomial computed in STEPS at XOUT.  Must be used in
conjunction with STEPS.
</pre>
</ul>
<h3> <a name="SOLUTIONS"> SOLUTIONS </a> </h3>
<ul>
<li><a href=dsos.f.html> dsos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
<li><a href=sos.f.html> sos </a>
<pre>
Solve a square system of nonlinear equations.
</pre>
</ul>
<h3> <a name="SOLVE"> SOLVE </a> </h3>
<ul>
<li><a href=cgbsl.f.html> cgbsl </a>
<pre>
Solve the complex band system A*X=B or CTRANS(A)*X=B using
the factors computed by CGBCO or CGBFA.
</pre>
<li><a href=cgesl.f.html> cgesl </a>
<pre>
Solve the complex system A*X=B or CTRANS(A)*X=B using the
factors computed by CGECO or CGEFA.
</pre>
<li><a href=cgtsl.f.html> cgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=chisl.f.html> chisl </a>
<pre>
Solve the complex Hermitian system using factors obtained
from CHIFA.
</pre>
<li><a href=chpsl.f.html> chpsl </a>
<pre>
Solve a complex Hermitian system using factors obtained
from CHPFA.
</pre>
<li><a href=cnbsl.f.html> cnbsl </a>
<pre>
Solve a complex band system using the factors computed by
CNBCO or CNBFA.
</pre>
<li><a href=cpbsl.f.html> cpbsl </a>
<pre>
Solve the complex Hermitian positive definite band system
using the factors computed by CPBCO or CPBFA.
</pre>
<li><a href=cposl.f.html> cposl </a>
<pre>
Solve the complex Hermitian positive definite linear system
using the factors computed by CPOCO or CPOFA.
</pre>
<li><a href=cppsl.f.html> cppsl </a>
<pre>
Solve the complex Hermitian positive definite system using
the factors computed by CPPCO or CPPFA.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=cqrsl.f.html> cqrsl </a>
<pre>
Apply the output of CQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=csisl.f.html> csisl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSIFA.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=dgbsl.f.html> dgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by DGBCO or DGBFA.
</pre>
<li><a href=dgesl.f.html> dgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors computed by DGECO or DGEFA.
</pre>
<li><a href=dgtsl.f.html> dgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=dnbsl.f.html> dnbsl </a>
<pre>
Solve a real band system using the factors computed by
DNBCO or DNBFA.
</pre>
<li><a href=dpbsl.f.html> dpbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by DPBCO or DPBFA.
</pre>
<li><a href=dposl.f.html> dposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by DPOCO or DPOFA.
</pre>
<li><a href=dppsl.f.html> dppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by DPPCO or DPPFA.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dqrsl.f.html> dqrsl </a>
<pre>
Apply the output of DQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=dsisl.f.html> dsisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=sgbsl.f.html> sgbsl </a>
<pre>
Solve the real band system A*X=B or TRANS(A)*X=B using
the factors computed by SGBCO or SGBFA.
</pre>
<li><a href=sgesl.f.html> sgesl </a>
<pre>
Solve the real system A*X=B or TRANS(A)*X=B using the
factors of SGECO or SGEFA.
</pre>
<li><a href=sgtsl.f.html> sgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=snbsl.f.html> snbsl </a>
<pre>
Solve a real band system using the factors computed by
SNBCO or SNBFA.
</pre>
<li><a href=spbsl.f.html> spbsl </a>
<pre>
Solve a real symmetric positive definite band system
using the factors computed by SPBCO or SPBFA.
</pre>
<li><a href=sposl.f.html> sposl </a>
<pre>
Solve the real symmetric positive definite linear system
using the factors computed by SPOCO or SPOFA.
</pre>
<li><a href=sppsl.f.html> sppsl </a>
<pre>
Solve the real symmetric positive definite system using
the factors computed by SPPCO or SPPFA.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=sqrsl.f.html> sqrsl </a>
<pre>
Apply the output of SQRDC to compute coordinate transfor-
mations, projections, and least squares solutions.
</pre>
<li><a href=ssisl.f.html> ssisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
</ul>
<h3> <a name="SORT"> SORT </a> </h3>
<ul>
<li><a href=dpsort.f.html> dpsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=dsort.f.html> dsort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=hpsort.f.html> hpsort </a>
<pre>
Return the permutation vector generated by sorting a
substring within a character array and, optionally,
rearrange the elements of the array.  The array may be
sorted in forward or reverse lexicographical order.  A
slightly modified quicksort algorithm is used.
</pre>
<li><a href=ipsort.f.html> ipsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=isort.f.html> isort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1d.f.html> qs2i1d </a>
<pre>
Sort an integer array, moving an integer and DP array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the double pre-
cision array A.  The array IA may be sorted in increasing
order or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1r.f.html> qs2i1r </a>
<pre>
Sort an integer array, moving an integer and real array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the real array A.
The array IA may be sorted in increasing order or decreas-
ing order.  A slightly modified QUICKSORT algorithm is
used.
</pre>
<li><a href=spsort.f.html> spsort </a>
<pre>
Return the permutation vector generated by sorting a given
array and, optionally, rearrange the elements of the array.
The array may be sorted in increasing or decreasing order.
A slightly modified quicksort algorithm is used.
</pre>
<li><a href=ssort.f.html> ssort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
</ul>
<h3> <a name="SORTING"> SORTING </a> </h3>
<ul>
<li><a href=dsort.f.html> dsort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=isort.f.html> isort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1d.f.html> qs2i1d </a>
<pre>
Sort an integer array, moving an integer and DP array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the double pre-
cision array A.  The array IA may be sorted in increasing
order or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
<li><a href=qs2i1r.f.html> qs2i1r </a>
<pre>
Sort an integer array, moving an integer and real array.
This routine sorts the integer array IA and makes the same
interchanges in the integer array JA and the real array A.
The array IA may be sorted in increasing order or decreas-
ing order.  A slightly modified QUICKSORT algorithm is
used.
</pre>
<li><a href=ssort.f.html> ssort </a>
<pre>
Sort an array and optionally make the same interchanges in
an auxiliary array.  The array may be sorted in increasing
or decreasing order.  A slightly modified QUICKSORT
algorithm is used.
</pre>
</ul>
<h3> <a name="SPARSE"> SPARSE </a> </h3>
<ul>
<li><a href=dbcg.f.html> dbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=dcg.f.html> dcg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=dcgn.f.html> dcgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=dcgs.f.html> dcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=dgmres.f.html> dgmres </a>
<pre>
Preconditioned GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dhels.f.html> dhels </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dheqr.f.html> dheqr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dir.f.html> dir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=dllti2.f.html> dllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=domn.f.html> domn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=dorth.f.html> dorth </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dpigmr.f.html> dpigmr </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=drlcal.f.html> drlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=dsdbcg.f.html> dsdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=dsdcg.f.html> dsdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=dsdcgn.f.html> dsdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=dsdcgs.f.html> dsdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=dsdgmr.f.html> dsdgmr </a>
<pre>
Diagonally scaled GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=dsdi.f.html> dsdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=dsdomn.f.html> dsdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=dsgs.f.html> dsgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=dsiccg.f.html> dsiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=dsilur.f.html> dsilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=dsilus.f.html> dsilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=dsjac.f.html> dsjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=dsli.f.html> dsli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=dsli2.f.html> dsli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=dsllti.f.html> dsllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=dslubc.f.html> dslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslucn.f.html> dslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=dslucs.f.html> dslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=dslugm.f.html> dslugm </a>
<pre>
Incomplete LU GMRES iterative sparse Ax=b solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=dslui.f.html> dslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=dslui2.f.html> dslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=dslui4.f.html> dslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsluom.f.html> dsluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=dsluti.f.html> dsluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=dsmmi2.f.html> dsmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=dsmmti.f.html> dsmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=dsmtv.f.html> dsmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
<li><a href=dsmv.f.html> dsmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
<li><a href=dxlcal.f.html> dxlcal </a>
<pre>
Internal routine for DGMRES.
</pre>
<li><a href=isdbcg.f.html> isdbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcg.f.html> isdcg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcgn.f.html> isdcgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isdcgs.f.html> isdcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=isdgmr.f.html> isdgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=isdir.f.html> isdir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issbcg.f.html> issbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscg.f.html> isscg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscgn.f.html> isscgn </a>
<pre>
Preconditioned CG on Normal Equations Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme applied to the normal equations.
It returns a non-zero if the error estimate (the type of
which is determined by ITOL) is less than the user
specified tolerance TOL.
</pre>
<li><a href=isscgs.f.html> isscgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=issgmr.f.html> issgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=issir.f.html> issir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=sbcg.f.html> sbcg </a>
<pre>
Preconditioned BiConjugate Gradient Sparse Ax = b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient method.
</pre>
<li><a href=scg.f.html> scg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=scgn.f.html> scgn </a>
<pre>
Preconditioned CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
Preconditioned Conjugate Gradient method applied to the
normal equations  AA'y = b, x=A'y.
</pre>
<li><a href=scgs.f.html> scgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a Non-Symmetric linear system  Ax = b
using the Preconditioned BiConjugate Gradient Squared
method.
</pre>
<li><a href=sir.f.html> sir </a>
<pre>
Preconditioned Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
iterative refinement with a matrix splitting.
</pre>
<li><a href=sgmres.f.html> sgmres </a>
<pre>
Preconditioned GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with preconditioning to solve
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=shels.f.html> shels </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sheqr.f.html> sheqr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=sllti2.f.html> sllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=somn.f.html> somn </a>
<pre>
Preconditioned Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Preconditioned Orthomin method.
</pre>
<li><a href=sorth.f.html> sorth </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=spigmr.f.html> spigmr </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=srlcal.f.html> srlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
<li><a href=ssdbcg.f.html> ssdbcg </a>
<pre>
Diagonally Scaled BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with diagonal scaling.
</pre>
<li><a href=ssdcg.f.html> ssdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=ssdcgn.f.html> ssdcgn </a>
<pre>
Diagonally Scaled CG Sparse Ax=b Solver for Normal Eqn's.
Routine to solve a general linear system  Ax = b  using
diagonal scaling with the Conjugate Gradient method
applied to the the normal equations, viz.,  AA'y = b,
where  x = A'y.
</pre>
<li><a href=ssdcgs.f.html> ssdcgs </a>
<pre>
Diagonally Scaled CGS Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with diagonal scaling.
</pre>
<li><a href=ssdgmr.f.html> ssdgmr </a>
<pre>
Diagonally Scaled GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with diagonal scaling to solve possibly
non-symmetric linear systems of the form: Ax = b.
</pre>
<li><a href=ssdi.f.html> ssdi </a>
<pre>
Diagonal Matrix Vector Multiply.
Routine to calculate the product  X = DIAG*B, where DIAG
is a diagonal matrix.
</pre>
<li><a href=ssdomn.f.html> ssdomn </a>
<pre>
Diagonally Scaled Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with diagonal scaling.
</pre>
<li><a href=ssgs.f.html> ssgs </a>
<pre>
Gauss-Seidel Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Gauss-Seidel iteration.
</pre>
<li><a href=ssiccg.f.html> ssiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=ssilur.f.html> ssilur </a>
<pre>
Incomplete LU Iterative Refinement Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
the incomplete LU decomposition with iterative refinement.
</pre>
<li><a href=ssilus.f.html> ssilus </a>
<pre>
Incomplete LU Decomposition Preconditioner SLAP Set Up.
Routine to generate the incomplete LDU decomposition of a
matrix.  The unit lower triangular factor L is stored by
rows and the unit upper triangular factor U is stored by
columns.  The inverse of the diagonal matrix D is stored.
No fill in is allowed.
</pre>
<li><a href=ssjac.f.html> ssjac </a>
<pre>
Jacobi's Method Iterative Sparse Ax = b Solver.
Routine to solve a general linear system  Ax = b  using
Jacobi iteration.
</pre>
<li><a href=ssli.f.html> ssli </a>
<pre>
SLAP MSOLVE for Lower Triangle Matrix.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
          -1
computes L  B = X.
</pre>
<li><a href=ssli2.f.html> ssli2 </a>
<pre>
SLAP Lower Triangle Matrix Backsolve.
Routine to solve a system of the form  Lx = b , where L
is a lower triangular matrix.
</pre>
<li><a href=ssllti.f.html> ssllti </a>
<pre>
SLAP MSOLVE for LDL' (IC) Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes (LDL')  B = X.
</pre>
<li><a href=sslubc.f.html> sslubc </a>
<pre>
Incomplete LU BiConjugate Gradient Sparse Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslucn.f.html> sslucn </a>
<pre>
Incomplete LU CG Sparse Ax=b Solver for Normal Equations.
Routine to solve a general linear system  Ax = b  using the
incomplete LU decomposition with the Conjugate Gradient
method applied to the normal equations, viz.,  AA'y = b,
x = A'y.
</pre>
<li><a href=sslucs.f.html> sslucs </a>
<pre>
Incomplete LU BiConjugate Gradient Squared Ax=b Solver.
Routine to solve a linear system  Ax = b  using the
BiConjugate Gradient Squared method with Incomplete LU
decomposition preconditioning.
</pre>
<li><a href=sslugm.f.html> sslugm </a>
<pre>
Incomplete LU GMRES Iterative Sparse Ax=b Solver.
This routine uses the generalized minimum residual
(GMRES) method with incomplete LU factorization for
preconditioning to solve possibly non-symmetric linear
systems of the form: Ax = b.
</pre>
<li><a href=sslui.f.html> sslui </a>
<pre>
SLAP MSOLVE for LDU Factorization.
This routine acts as an interface between the SLAP generic
MSOLVE calling convention and the routine that actually
               -1
computes  (LDU)  B = X.
</pre>
<li><a href=sslui2.f.html> sslui2 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  L*D*U X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix.
</pre>
<li><a href=sslui4.f.html> sslui4 </a>
<pre>
SLAP Backsolve for LDU Factorization.
Routine to solve a system of the form  (L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssluom.f.html> ssluom </a>
<pre>
Incomplete LU Orthomin Sparse Iterative Ax=b Solver.
Routine to solve a general linear system  Ax = b  using
the Orthomin method with Incomplete LU decomposition.
</pre>
<li><a href=ssluti.f.html> ssluti </a>
<pre>
SLAP MTSOLV for LDU Factorization.
This routine acts as an interface between the SLAP generic
MTSOLV calling convention and the routine that actually
               -T
computes  (LDU)  B = X.
</pre>
<li><a href=ssmmi2.f.html> ssmmi2 </a>
<pre>
SLAP Backsolve for LDU Factorization of Normal Equations.
To solve a system of the form  (L*D*U)*(L*D*U)' X = B,
where L is a unit lower triangular matrix, D is a diagonal
matrix, and U is a unit upper triangular matrix and '
denotes transpose.
</pre>
<li><a href=ssmmti.f.html> ssmmti </a>
<pre>
SLAP MSOLVE for LDU Factorization of Normal Equations.
This routine acts as an interface between the SLAP generic
MMTSLV calling convention and the routine that actually
                        -1
computes  [(LDU)*(LDU)']  B = X.
</pre>
<li><a href=ssmtv.f.html> ssmtv </a>
<pre>
SLAP Column Format Sparse Matrix Transpose Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A'*X, where ' denotes transpose.
</pre>
<li><a href=ssmv.f.html> ssmv </a>
<pre>
SLAP Column Format Sparse Matrix Vector Product.
Routine to calculate the sparse matrix vector product:
Y = A*X.
</pre>
<li><a href=sxlcal.f.html> sxlcal </a>
<pre>
Internal routine for SGMRES.
</pre>
</ul>
<h3> <a name="SPARSE_CONSTRAINTS"> SPARSE CONSTRAINTS </a> </h3>
<ul>
<li><a href=dsplp.f.html> dsplp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
<li><a href=splp.f.html> splp </a>
<pre>
Solve linear programming problems involving at
most a few thousand constraints and variables.
Takes advantage of sparsity in the constraint matrix.
</pre>
</ul>
<h3> <a name="SPARSE_ITERATIVE_METHODS"> SPARSE ITERATIVE METHODS </a> </h3>
<ul>
<li><a href=dlpdoc.f.html> dlpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
<li><a href=slpdoc.f.html> slpdoc </a>
<pre>
Sparse Linear Algebra Package Version 2.0.2 Documentation.
Routines to solve large sparse symmetric and nonsymmetric
positive definite linear systems, Ax = b, using precondi-
tioned iterative methods.
</pre>
</ul>
<h3> <a name="SPECIAL_FUNCTIONS"> SPECIAL FUNCTIONS </a> </h3>
<ul>
<li><a href=ai.f.html> ai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=aie.f.html> aie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
<li><a href=albeta.f.html> albeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=algams.f.html> algams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=ali.f.html> ali </a>
<pre>
Compute the logarithmic integral.
</pre>
<li><a href=alngam.f.html> alngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=besi.f.html> besi </a>
<pre>
Compute an N member sequence of I Bessel functions
I/SUB(ALPHA+K-1)/(X), K=1,...,N or scaled Bessel functions
EXP(-X)*I/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative
ALPHA and X.
</pre>
<li><a href=besi0.f.html> besi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=besi0e.f.html> besi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=besi1.f.html> besi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=besi1e.f.html> besi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=besj.f.html> besj </a>
<pre>
Compute an N member sequence of J Bessel functions
J/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative ALPHA
and X.
</pre>
<li><a href=besj0.f.html> besj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=besj1.f.html> besj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=besk.f.html> besk </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions K/SUB(FNU+I-1)/(X), or scaled Bessel functions
EXP(X)*K/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=besy.f.html> besy </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions Y/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=besy0.f.html> besy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=besy1.f.html> besy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=beta.f.html> beta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=betai.f.html> betai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
<li><a href=bi.f.html> bi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=bie.f.html> bie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=binom.f.html> binom </a>
<pre>
Compute the binomial coefficients.
</pre>
<li><a href=c0lgmc.f.html> c0lgmc </a>
<pre>
Evaluate (Z+0.5)*LOG((Z+1.)/Z) - 1.0 with relative
accuracy.
</pre>
<li><a href=c9lgmc.f.html> c9lgmc </a>
<pre>
Compute the log gamma correction factor so that
LOG(CGAMMA(Z)) = 0.5*LOG(2.*PI) + (Z-0.5)*LOG(Z) - Z
+ C9LGMC(Z).
</pre>
<li><a href=cbeta.f.html> cbeta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=cgamma.f.html> cgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=cgamr.f.html> cgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=chu.f.html> chu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=clbeta.f.html> clbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=clngam.f.html> clngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=cpsi.f.html> cpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=csevl.f.html> csevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
<li><a href=d9aimp.f.html> d9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=d9b0mp.f.html> d9b0mp </a>
<pre>
Evaluate the modulus and phase for the J0 and Y0 Bessel
functions.
</pre>
<li><a href=d9b1mp.f.html> d9b1mp </a>
<pre>
Evaluate the modulus and phase for the J1 and Y1 Bessel
functions.
</pre>
<li><a href=d9chu.f.html> d9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
<li><a href=d9gmic.f.html> d9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and X small.
</pre>
<li><a href=d9gmit.f.html> d9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=d9knus.f.html> d9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
<li><a href=d9lgic.f.html> d9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=d9lgmc.f.html> d9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(DGAMMA(X)) = LOG(SQRT(2*PI)) + (X-5.)*LOG(X) - X
+ D9LGMC(X).
</pre>
<li><a href=dai.f.html> dai </a>
<pre>
Evaluate the Airy function.
</pre>
<li><a href=daie.f.html> daie </a>
<pre>
Calculate the Airy function for a negative argument and an
exponentially scaled Airy function for a non-negative
argument.
</pre>
<li><a href=daws.f.html> daws </a>
<pre>
Compute Dawson's function.
</pre>
<li><a href=dbesi.f.html> dbesi </a>
<pre>
Compute an N member sequence of I Bessel functions
I/SUB(ALPHA+K-1)/(X), K=1,...,N or scaled Bessel functions
EXP(-X)*I/SUB(ALPHA+K-1)/(X), K=1,...,N for nonnegative
ALPHA and X.
</pre>
<li><a href=dbesi0.f.html> dbesi0 </a>
<pre>
Compute the hyperbolic Bessel function of the first kind
of order zero.
</pre>
<li><a href=dbesi1.f.html> dbesi1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
first kind of order one.
</pre>
<li><a href=dbesj.f.html> dbesj </a>
<pre>
Compute an N member sequence of J Bessel functions
J/SUB(ALPHA+K-1)/(X), K=1,...,N for non-negative ALPHA
and X.
</pre>
<li><a href=dbesj0.f.html> dbesj0 </a>
<pre>
Compute the Bessel function of the first kind of order
zero.
</pre>
<li><a href=dbesj1.f.html> dbesj1 </a>
<pre>
Compute the Bessel function of the first kind of order one.
</pre>
<li><a href=dbesk.f.html> dbesk </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions K/SUB(FNU+I-1)/(X), or scaled Bessel functions
EXP(X)*K/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesy.f.html> dbesy </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions Y/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=dbesy0.f.html> dbesy0 </a>
<pre>
Compute the Bessel function of the second kind of order
zero.
</pre>
<li><a href=dbesy1.f.html> dbesy1 </a>
<pre>
Compute the Bessel function of the second kind of order
one.
</pre>
<li><a href=dbeta.f.html> dbeta </a>
<pre>
Compute the complete Beta function.
</pre>
<li><a href=dbetai.f.html> dbetai </a>
<pre>
Calculate the incomplete Beta function.
</pre>
<li><a href=dbi.f.html> dbi </a>
<pre>
Evaluate the Bairy function (the Airy function of the
second kind).
</pre>
<li><a href=dbie.f.html> dbie </a>
<pre>
Calculate the Bairy function for a negative argument and an
exponentially scaled Bairy function for a non-negative
argument.
</pre>
<li><a href=dbinom.f.html> dbinom </a>
<pre>
Compute the binomial coefficients.
</pre>
<li><a href=dbsi0e.f.html> dbsi0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order zero.
</pre>
<li><a href=dbsi1e.f.html> dbsi1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the first kind of order one.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=dchu.f.html> dchu </a>
<pre>
Compute the logarithmic confluent hypergeometric function.
</pre>
<li><a href=dcsevl.f.html> dcsevl </a>
<pre>
Evaluate a Chebyshev series.
</pre>
<li><a href=ddaws.f.html> ddaws </a>
<pre>
Compute Dawson's function.
</pre>
<li><a href=de1.f.html> de1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=dei.f.html> dei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=derf.f.html> derf </a>
<pre>
Compute the error function.
</pre>
<li><a href=derfc.f.html> derfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=dexint.f.html> dexint </a>
<pre>
Compute an M member sequence of exponential integrals
E(N+K,X), K=0,1,...,M-1 for N .GE. 1 and X .GE. 0.
</pre>
<li><a href=dfac.f.html> dfac </a>
<pre>
Compute the factorial function.
</pre>
<li><a href=dgami.f.html> dgami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=dgamic.f.html> dgamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=dgamit.f.html> dgamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=dgamlm.f.html> dgamlm </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=dgamma.f.html> dgamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=dgamr.f.html> dgamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=dlbeta.f.html> dlbeta </a>
<pre>
Compute the natural logarithm of the complete Beta
function.
</pre>
<li><a href=dlgams.f.html> dlgams </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dli.f.html> dli </a>
<pre>
Compute the logarithmic integral.
</pre>
<li><a href=dlngam.f.html> dlngam </a>
<pre>
Compute the logarithm of the absolute value of the Gamma
function.
</pre>
<li><a href=dpoch.f.html> dpoch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=dpoch1.f.html> dpoch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=dpsi.f.html> dpsi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=dspenc.f.html> dspenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
<li><a href=e1.f.html> e1 </a>
<pre>
Compute the exponential integral E1(X).
</pre>
<li><a href=ei.f.html> ei </a>
<pre>
Compute the exponential integral Ei(X).
</pre>
<li><a href=erf.f.html> erf </a>
<pre>
Compute the error function.
</pre>
<li><a href=erfc.f.html> erfc </a>
<pre>
Compute the complementary error function.
</pre>
<li><a href=exint.f.html> exint </a>
<pre>
Compute an M member sequence of exponential integrals
E(N+K,X), K=0,1,...,M-1 for N .GE. 1 and X .GE. 0.
</pre>
<li><a href=fac.f.html> fac </a>
<pre>
Compute the factorial function.
</pre>
<li><a href=fundoc.f.html> fundoc </a>
<pre>
Documentation for FNLIB, a collection of routines for
evaluating elementary and special functions.
</pre>
<li><a href=gami.f.html> gami </a>
<pre>
Evaluate the incomplete Gamma function.
</pre>
<li><a href=gamic.f.html> gamic </a>
<pre>
Calculate the complementary incomplete Gamma function.
</pre>
<li><a href=gamit.f.html> gamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=gamlim.f.html> gamlim </a>
<pre>
Compute the minimum and maximum bounds for the argument in
the Gamma function.
</pre>
<li><a href=gamma.f.html> gamma </a>
<pre>
Compute the complete Gamma function.
</pre>
<li><a href=gamr.f.html> gamr </a>
<pre>
Compute the reciprocal of the Gamma function.
</pre>
<li><a href=initds.f.html> initds </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=inits.f.html> inits </a>
<pre>
Determine the number of terms needed in an orthogonal
polynomial series so that it meets a specified accuracy.
</pre>
<li><a href=psi.f.html> psi </a>
<pre>
Compute the Psi (or Digamma) function.
</pre>
<li><a href=poch.f.html> poch </a>
<pre>
Evaluate a generalization of Pochhammer's symbol.
</pre>
<li><a href=poch1.f.html> poch1 </a>
<pre>
Calculate a generalization of Pochhammer's symbol starting
from first order.
</pre>
<li><a href=r9aimp.f.html> r9aimp </a>
<pre>
Evaluate the Airy modulus and phase.
</pre>
<li><a href=r9chu.f.html> r9chu </a>
<pre>
Evaluate for large Z  Z**A * U(A,B,Z) where U is the
logarithmic confluent hypergeometric function.
</pre>
<li><a href=r9gmic.f.html> r9gmic </a>
<pre>
Compute the complementary incomplete Gamma function for A
near a negative integer and for small X.
</pre>
<li><a href=r9gmit.f.html> r9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=rand.f.html> rand </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=r9knus.f.html> r9knus </a>
<pre>
Compute Bessel functions EXP(X)*K-SUB-XNU(X) and EXP(X)*
K-SUB-XNU+1(X) for 0.0 .LE. XNU .LT. 1.0.
</pre>
<li><a href=r9lgic.f.html> r9lgic </a>
<pre>
Compute the log complementary incomplete Gamma function
for large X and for A .LE. X.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=r9lgmc.f.html> r9lgmc </a>
<pre>
Compute the log Gamma correction factor so that
LOG(GAMMA(X)) = LOG(SQRT(2*PI)) + (X-.5)*LOG(X) - X
+ R9LGMC(X).
</pre>
<li><a href=rgauss.f.html> rgauss </a>
<pre>
Generate a normally distributed (Gaussian) random number.
</pre>
<li><a href=runif.f.html> runif </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=spenc.f.html> spenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
</ul>
<h3> <a name="SPECIAL-PURPOSE"> SPECIAL-PURPOSE </a> </h3>
<ul>
<li><a href=dqawc.f.html> dqawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=dqawce.f.html> dqawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=dqawo.f.html> dqawo </a>
<pre>
Calculate an approximation to a given definite integral
I= Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
   or  W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawoe.f.html> dqawoe </a>
<pre>
Calculate an approximation to a given definite integral
I = Integral of F(X)*W(X) over (A,B), where
         W(X) = COS(OMEGA*X)
     or  W(X)=SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
     ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqaws.f.html> dqaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqawse.f.html> dqawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawc.f.html> qawc </a>
<pre>
The routine calculates an approximation result to a
Cauchy principal value I = INTEGRAL of F*W over (A,B)
(W(X) = 1/((X-C), C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABE,EPSREL*ABS(I)).
</pre>
<li><a href=qawce.f.html> qawce </a>
<pre>
The routine calculates an approximation result to a
CAUCHY PRINCIPAL VALUE I = Integral of F*W over (A,B)
(W(X) = 1/(X-C), (C.NE.A, C.NE.B), hopefully satisfying
following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qawo.f.html> qawo </a>
<pre>
Calculate an approximation to a given definite integral
 I = Integral of F(X)*W(X) over (A,B), where
       W(X) = COS(OMEGA*X)
    or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
    ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawoe.f.html> qawoe </a>
<pre>
Calculate an approximation to a given definite integral
   I = Integral of F(X)*W(X) over (A,B), where
      W(X) = COS(OMEGA*X)
   or W(X) = SIN(OMEGA*X),
hopefully satisfying the following claim for accuracy
   ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qaws.f.html> qaws </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qawse.f.html> qawse </a>
<pre>
The routine calculates an approximation result to a given
definite integral I = Integral of F*W over (A,B),
(where W shows a singular behaviour at the end points,
see parameter INTEGR).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
</ul>
<h3> <a name="SPECIAL-PURPOSE_INTEGRAL"> SPECIAL-PURPOSE INTEGRAL </a> </h3>
<ul>
<li><a href=dqawf.f.html> dqawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral I=Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=dqawfe.f.html> dqawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X)=COS(OMEGA*X) or W(X)=SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawf.f.html> qawf </a>
<pre>
The routine calculates an approximation result to a given
Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X).
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
<li><a href=qawfe.f.html> qawfe </a>
<pre>
The routine calculates an approximation result to a
given Fourier integral
I = Integral of F(X)*W(X) over (A,INFINITY)
 where W(X) = COS(OMEGA*X) or W(X) = SIN(OMEGA*X),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.EPSABS.
</pre>
</ul>
<h3> <a name="SPENCE'S_INTEGRAL"> SPENCE'S INTEGRAL </a> </h3>
<ul>
<li><a href=dspenc.f.html> dspenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
<li><a href=spenc.f.html> spenc </a>
<pre>
Compute a form of Spence's integral due to K. Mitchell.
</pre>
</ul>
<h3> <a name="SPHERICAL"> SPHERICAL </a> </h3>
<ul>
<li><a href=hstcsp.f.html> hstcsp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the modified Helmholtz
equation in spherical coordinates assuming axisymmetry
(no dependence on longitude).
</pre>
<li><a href=hstssp.f.html> hstssp </a>
<pre>
Solve the standard five-point finite difference
approximation on a staggered grid to the Helmholtz
equation in spherical coordinates and on the surface of
the unit sphere (radius of 1).
</pre>
<li><a href=hwscsp.f.html> hwscsp </a>
<pre>
Solve a finite difference approximation to the modified
Helmholtz equation in spherical coordinates assuming
axisymmetry  (no dependence on longitude).
</pre>
<li><a href=hwsssp.f.html> hwsssp </a>
<pre>
Solve a finite difference approximation to the Helmholtz
equation in spherical coordinates and on the surface of the
unit sphere (radius of 1).
</pre>
</ul>
<h3> <a name="SPLINE_INTERPOLATION"> SPLINE INTERPOLATION </a> </h3>
<ul>
<li><a href=dpchsp.f.html> dpchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
<li><a href=pchsp.f.html> pchsp </a>
<pre>
Set derivatives needed to determine the Hermite represen-
tation of the cubic spline interpolant to given data, with
specified boundary conditions.
</pre>
</ul>
<h3> <a name="SPLINES"> SPLINES </a> </h3>
<ul>
<li><a href=bspdoc.f.html> bspdoc </a>
<pre>
Documentation for BSPLINE, a package of subprograms for
working with piecewise polynomial functions
in B-representation.
</pre>
<li><a href=bspev.f.html> bspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dbspev.f.html> dbspev </a>
<pre>
Calculate the value of the spline and its derivatives from
the B-representation.
</pre>
<li><a href=dintrv.f.html> dintrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision of
the X interval.
</pre>
<li><a href=dpfqad.f.html> dpfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a
function F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=dppqad.f.html> dppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=dppval.f.html> dppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
<li><a href=intrv.f.html> intrv </a>
<pre>
Compute the largest integer ILEFT in 1 .LE. ILEFT .LE. LXT
such that XT(ILEFT) .LE. X where XT(*) is a subdivision
of the X interval.
</pre>
<li><a href=pfqad.f.html> pfqad </a>
<pre>
Compute the integral on (X1,X2) of a product of a function
F and the ID-th derivative of a B-spline,
(PP-representation).
</pre>
<li><a href=ppqad.f.html> ppqad </a>
<pre>
Compute the integral on (X1,X2) of a K-th order B-spline
using the piecewise polynomial (PP) representation.
</pre>
<li><a href=ppval.f.html> ppval </a>
<pre>
Calculate the value of the IDERIV-th derivative of the
B-spline from the PP-representation.
</pre>
</ul>
<h3> <a name="STIFF"> STIFF </a> </h3>
<ul>
<li><a href=cdriv1.f.html> cdriv1 </a>
<pre>
The function of CDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  CDRIV1 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv2.f.html> cdriv2 </a>
<pre>
The function of CDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  CDRIV2 allows complex-valued differential
equations.
</pre>
<li><a href=cdriv3.f.html> cdriv3 </a>
<pre>
The function of CDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  CDRIV3
allows complex-valued differential equations.
</pre>
<li><a href=ddebdf.f.html> ddebdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=ddriv1.f.html> ddriv1 </a>
<pre>
The function of DDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  DDRIV1 uses double precision arithmetic.
</pre>
<li><a href=ddriv2.f.html> ddriv2 </a>
<pre>
The function of DDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  DDRIV2 uses double precision arithmetic.
</pre>
<li><a href=ddriv3.f.html> ddriv3 </a>
<pre>
The function of DDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  DDRIV3
uses double precision arithmetic.
</pre>
<li><a href=debdf.f.html> debdf </a>
<pre>
Solve an initial value problem in ordinary differential
equations using backward differentiation formulas.  It is
intended primarily for stiff problems.
</pre>
<li><a href=sdriv1.f.html> sdriv1 </a>
<pre>
The function of SDRIV1 is to solve N (200 or fewer)
ordinary differential equations of the form
dY(I)/dT = F(Y(I),T), given the initial conditions
Y(I) = YI.  SDRIV1 uses single precision arithmetic.
</pre>
<li><a href=sdriv2.f.html> sdriv2 </a>
<pre>
The function of SDRIV2 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  SDRIV2 uses single precision arithmetic.
</pre>
<li><a href=sdriv3.f.html> sdriv3 </a>
<pre>
The function of SDRIV3 is to solve N ordinary differential
equations of the form dY(I)/dT = F(Y(I),T), given the
initial conditions Y(I) = YI.  The program has options to
allow the solution of both stiff and non-stiff differential
equations.  Other important options are available.  SDRIV3
uses single precision arithmetic.
</pre>
</ul>
<h3> <a name="STOP_TEST"> STOP TEST </a> </h3>
<ul>
<li><a href=isdbcg.f.html> isdbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcg.f.html> isdcg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdcgs.f.html> isdcgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=isdgmr.f.html> isdgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=isdir.f.html> isdir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isdomn.f.html> isdomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
<li><a href=issbcg.f.html> issbcg </a>
<pre>
Preconditioned BiConjugate Gradient Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscg.f.html> isscg </a>
<pre>
Preconditioned Conjugate Gradient Stop Test.
This routine calculates the stop test for the Conjugate
Gradient iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=isscgs.f.html> isscgs </a>
<pre>
Preconditioned BiConjugate Gradient Squared Stop Test.
This routine calculates the stop test for the BiConjugate
Gradient Squared iteration scheme.  It returns a non-zero
if the error estimate (the type of which is determined by
ITOL) is less than the user specified tolerance TOL.
</pre>
<li><a href=issgmr.f.html> issgmr </a>
<pre>
Generalized Minimum Residual Stop Test.
This routine calculates the stop test for the Generalized
Minimum RESidual (GMRES) iteration scheme.  It returns a
non-zero if the error estimate (the type of which is
determined by ITOL) is less than the user specified
tolerance TOL.
</pre>
<li><a href=issir.f.html> issir </a>
<pre>
Preconditioned Iterative Refinement Stop Test.
This routine calculates the stop test for the iterative
refinement iteration scheme.  It returns a non-zero if the
error estimate (the type of which is determined by ITOL)
is less than the user specified tolerance TOL.
</pre>
<li><a href=issomn.f.html> issomn </a>
<pre>
Preconditioned Orthomin Stop Test.
This routine calculates the stop test for the Orthomin
iteration scheme.  It returns a non-zero if the error
estimate (the type of which is determined by ITOL) is
less than the user specified tolerance TOL.
</pre>
</ul>
<h3> <a name="STRING_SORTING"> STRING SORTING </a> </h3>
<ul>
<li><a href=hpsort.f.html> hpsort </a>
<pre>
Return the permutation vector generated by sorting a
substring within a character array and, optionally,
rearrange the elements of the array.  The array may be
sorted in forward or reverse lexicographical order.  A
slightly modified quicksort algorithm is used.
</pre>
</ul>
<h3> <a name="SUM_OF_MAGNITUDES_OF_A_VECTOR"> SUM OF MAGNITUDES OF A VECTOR </a> </h3>
<ul>
<li><a href=dasum.f.html> dasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=sasum.f.html> sasum </a>
<pre>
Compute the sum of the magnitudes of the elements of a
vector.
</pre>
<li><a href=scasum.f.html> scasum </a>
<pre>
Compute the sum of the magnitudes of the real and
imaginary elements of a complex vector.
</pre>
</ul>
<h3> <a name="SURVEY_OF_INTEGRATORS"> SURVEY OF INTEGRATORS </a> </h3>
<ul>
<li><a href=qpdoc.f.html> qpdoc </a>
<pre>
Documentation for QUADPACK, a package of subprograms for
automatic evaluation of one-dimensional definite integrals.
</pre>
</ul>
<h3> <a name="SYMMETRIC"> SYMMETRIC </a> </h3>
<ul>
<li><a href=chiev.f.html> chiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a complex Hermitian matrix.
</pre>
<li><a href=cpofs.f.html> cpofs </a>
<pre>
Solve a positive definite symmetric complex system of
linear equations.
</pre>
<li><a href=cpoir.f.html> cpoir </a>
<pre>
Solve a positive definite Hermitian system of linear
equations.  Iterative refinement is used to obtain an
error estimate.
</pre>
<li><a href=csico.f.html> csico </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting and estimate the condition number of the
matrix.
</pre>
<li><a href=csidi.f.html> csidi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix using the factors from CSIFA.
</pre>
<li><a href=csifa.f.html> csifa </a>
<pre>
Factor a complex symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=csisl.f.html> csisl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSIFA.
</pre>
<li><a href=cspco.f.html> cspco </a>
<pre>
Factor a complex symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=cspdi.f.html> cspdi </a>
<pre>
Compute the determinant and inverse of a complex symmetric
matrix stored in packed form using the factors from CSPFA.
</pre>
<li><a href=cspfa.f.html> cspfa </a>
<pre>
Factor a complex symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=cspsl.f.html> cspsl </a>
<pre>
Solve a complex symmetric system using the factors obtained
from CSPFA.
</pre>
<li><a href=dpofs.f.html> dpofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=dsico.f.html> dsico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=dsidi.f.html> dsidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from DSIFA.
</pre>
<li><a href=dsifa.f.html> dsifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=dsisl.f.html> dsisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=dspco.f.html> dspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=dspdi.f.html> dspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from DSPFA.
</pre>
<li><a href=dspfa.f.html> dspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=dspsl.f.html> dspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from DSPFA.
</pre>
<li><a href=spofs.f.html> spofs </a>
<pre>
Solve a positive definite symmetric system of linear
equations.
</pre>
<li><a href=spoir.f.html> spoir </a>
<pre>
Solve a positive definite symmetric system of linear
equations.  Iterative refinement is used to obtain an error
estimate.
</pre>
<li><a href=ssico.f.html> ssico </a>
<pre>
Factor a symmetric matrix by elimination with symmetric
pivoting and estimate the condition number of the matrix.
</pre>
<li><a href=ssidi.f.html> ssidi </a>
<pre>
Compute the determinant, inertia and inverse of a real
symmetric matrix using the factors from SSIFA.
</pre>
<li><a href=ssiev.f.html> ssiev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix.
</pre>
<li><a href=ssifa.f.html> ssifa </a>
<pre>
Factor a real symmetric matrix by elimination with
symmetric pivoting.
</pre>
<li><a href=ssisl.f.html> ssisl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSIFA.
</pre>
<li><a href=sspco.f.html> sspco </a>
<pre>
Factor a real symmetric matrix stored in packed form
by elimination with symmetric pivoting and estimate the
condition number of the matrix.
</pre>
<li><a href=sspdi.f.html> sspdi </a>
<pre>
Compute the determinant, inertia, inverse of a real
symmetric matrix stored in packed form using the factors
from SSPFA.
</pre>
<li><a href=sspev.f.html> sspev </a>
<pre>
Compute the eigenvalues and, optionally, the eigenvectors
of a real symmetric matrix stored in packed form.
</pre>
<li><a href=sspfa.f.html> sspfa </a>
<pre>
Factor a real symmetric matrix stored in packed form by
elimination with symmetric pivoting.
</pre>
<li><a href=sspsl.f.html> sspsl </a>
<pre>
Solve a real symmetric system using the factors obtained
from SSPFA.
</pre>
</ul>
<h3> <a name="SYMMETRIC_LINEAR_SYSTEM"> SYMMETRIC LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=dcg.f.html> dcg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=dsdcg.f.html> dsdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=dsiccg.f.html> dsiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
<li><a href=scg.f.html> scg </a>
<pre>
Preconditioned Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.
</pre>
<li><a href=ssdcg.f.html> ssdcg </a>
<pre>
Diagonally Scaled Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the Preconditioned Conjugate
Gradient method.  The preconditioner is diagonal scaling.
</pre>
<li><a href=ssiccg.f.html> ssiccg </a>
<pre>
Incomplete Cholesky Conjugate Gradient Sparse Ax=b Solver.
Routine to solve a symmetric positive definite linear
system  Ax = b  using the incomplete Cholesky
Preconditioned Conjugate Gradient method.
</pre>
</ul>
<h3> <a name="SYMMETRIC_LINEAR_SYSTEM_SOLVE"> SYMMETRIC LINEAR SYSTEM SOLVE </a> </h3>
<ul>
<li><a href=dllti2.f.html> dllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
<li><a href=sllti2.f.html> sllti2 </a>
<pre>
SLAP Backsolve routine for LDL' Factorization.
Routine to solve a system of the form  L*D*L' X = B,
where L is a unit lower triangular matrix and D is a
diagonal matrix and ' means transpose.
</pre>
</ul>
<h3> <a name="TABULATED_DATA"> TABULATED DATA </a> </h3>
<ul>
<li><a href=avint.f.html> avint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
<li><a href=davint.f.html> davint </a>
<pre>
Integrate a function tabulated at arbitrarily spaced
abscissas using overlapping parabolas.
</pre>
</ul>
<h3> <a name="TANGENT"> TANGENT </a> </h3>
<ul>
<li><a href=ctan.f.html> ctan </a>
<pre>
Compute the complex tangent.
</pre>
</ul>
<h3> <a name="TAYLOR_SERIES"> TAYLOR SERIES </a> </h3>
<ul>
<li><a href=drc.f.html> drc </a>
<pre>
Calculate a double precision approximation to
 DRC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=drd.f.html> drd </a>
<pre>
Compute the incomplete or complete elliptic integral of
the 2nd kind. For X and Y nonnegative, X+Y and Z positive,
DRD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=drf.f.html> drf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=drj.f.html> drj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                  -1/2     -1/2     -1/2     -1
        (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
<li><a href=rc.f.html> rc </a>
<pre>
Calculate an approximation to
 RC(X,Y) = Integral from zero to infinity of
                  -1/2     -1
        (1/2)(t+X)    (t+Y)  dt,
where X is nonnegative and Y is positive.
</pre>
<li><a href=rd.f.html> rd </a>
<pre>
Compute the incomplete or complete elliptic integral of the
2nd kind.  For X and Y nonnegative, X+Y and Z positive,
 RD(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -3/2
          (3/2)(t+X)    (t+Y)    (t+Z)    dt.
If X or Y is zero, the integral is complete.
</pre>
<li><a href=rf.f.html> rf </a>
<pre>
Compute the incomplete or complete elliptic integral of the
1st kind.  For X, Y, and Z non-negative and at most one of
them zero, RF(X,Y,Z) = Integral from zero to infinity of
                    -1/2     -1/2     -1/2
          (1/2)(t+X)    (t+Y)    (t+Z)    dt.
If X, Y or Z is zero, the integral is complete.
</pre>
<li><a href=rj.f.html> rj </a>
<pre>
Compute the incomplete or complete (X or Y or Z is zero)
elliptic integral of the 3rd kind.  For X, Y, and Z non-
negative, at most one of them zero, and P positive,
 RJ(X,Y,Z,P) = Integral from zero to infinity of
                      -1/2     -1/2     -1/2     -1
            (3/2)(t+X)    (t+Y)    (t+Z)    (t+P)  dt.
</pre>
</ul>
<h3> <a name="THIRD_KIND"> THIRD KIND </a> </h3>
<ul>
<li><a href=besk0.f.html> besk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=besk0e.f.html> besk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=besk1.f.html> besk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=besk1e.f.html> besk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=beskes.f.html> beskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
<li><a href=besks.f.html> besks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbesk0.f.html> dbesk0 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order zero.
</pre>
<li><a href=dbesk1.f.html> dbesk1 </a>
<pre>
Compute the modified (hyperbolic) Bessel function of the
third kind of order one.
</pre>
<li><a href=dbesks.f.html> dbesks </a>
<pre>
Compute a sequence of modified Bessel functions of the
third kind of fractional order.
</pre>
<li><a href=dbsk0e.f.html> dbsk0e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order zero.
</pre>
<li><a href=dbsk1e.f.html> dbsk1e </a>
<pre>
Compute the exponentially scaled modified (hyperbolic)
Bessel function of the third kind of order one.
</pre>
<li><a href=dbskes.f.html> dbskes </a>
<pre>
Compute a sequence of exponentially scaled modified Bessel
functions of the third kind of fractional order.
</pre>
</ul>
<h3> <a name="TRANSFORMATION"> TRANSFORMATION </a> </h3>
<ul>
<li><a href=dqagi.f.html> dqagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
OR I = Integral of F over (-INFINITY,BOUND)
OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=dqagie.f.html> dqagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
or I = Integral of F over (-INFINITY,BOUND)
or I = Integral of F over (-INFINITY,+INFINITY),
hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
<li><a href=qagi.f.html> qagi </a>
<pre>
The routine calculates an approximation result to a given
INTEGRAL   I = Integral of F over (BOUND,+INFINITY)
        OR I = Integral of F over (-INFINITY,BOUND)
        OR I = Integral of F over (-INFINITY,+INFINITY)
Hopefully satisfying following claim for accuracy
ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
</pre>
<li><a href=qagie.f.html> qagie </a>
<pre>
The routine calculates an approximation result to a given
integral   I = Integral of F over (BOUND,+INFINITY)
        or I = Integral of F over (-INFINITY,BOUND)
        or I = Integral of F over (-INFINITY,+INFINITY),
        hopefully satisfying following claim for accuracy
        ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I))
</pre>
</ul>
<h3> <a name="TRIAD"> TRIAD </a> </h3>
<ul>
<li><a href=caxpy.f.html> caxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=daxpy.f.html> daxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=saxpy.f.html> saxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
</ul>
<h3> <a name="TRIANGULAR"> TRIANGULAR </a> </h3>
<ul>
<li><a href=strdi.f.html> strdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
</ul>
<h3> <a name="TRIANGULAR_LINEAR_SYSTEM"> TRIANGULAR LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=ctrsl.f.html> ctrsl </a>
<pre>
Solve a system of the form  T*X=B or CTRANS(T)*X=B, where
T is a triangular matrix.  Here CTRANS(T) is the conjugate
transpose.
</pre>
<li><a href=dtrsl.f.html> dtrsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
<li><a href=strsl.f.html> strsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
</ul>
<h3> <a name="TRIANGULAR_MATRIX"> TRIANGULAR MATRIX </a> </h3>
<ul>
<li><a href=ctrco.f.html> ctrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=ctrdi.f.html> ctrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=ctrsl.f.html> ctrsl </a>
<pre>
Solve a system of the form  T*X=B or CTRANS(T)*X=B, where
T is a triangular matrix.  Here CTRANS(T) is the conjugate
transpose.
</pre>
<li><a href=dtrco.f.html> dtrco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=dtrdi.f.html> dtrdi </a>
<pre>
Compute the determinant and inverse of a triangular matrix.
</pre>
<li><a href=dtrsl.f.html> dtrsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
<li><a href=strco.f.html> strco </a>
<pre>
Estimate the condition number of a triangular matrix.
</pre>
<li><a href=strsl.f.html> strsl </a>
<pre>
Solve a system of the form  T*X=B or TRANS(T)*X=B, where
T is a triangular matrix.
</pre>
</ul>
<h3> <a name="TRICOMI"> TRICOMI </a> </h3>
<ul>
<li><a href=d9gmit.f.html> d9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=d9lgit.f.html> d9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
<li><a href=dgamit.f.html> dgamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=gamit.f.html> gamit </a>
<pre>
Calculate Tricomi's form of the incomplete Gamma function.
</pre>
<li><a href=r9gmit.f.html> r9gmit </a>
<pre>
Compute Tricomi's incomplete Gamma function for small
arguments.
</pre>
<li><a href=r9lgit.f.html> r9lgit </a>
<pre>
Compute the logarithm of Tricomi's incomplete Gamma
function with Perron's continued fraction for large X and
A .GE. X.
</pre>
</ul>
<h3> <a name="TRIDIAGONAL"> TRIDIAGONAL </a> </h3>
<ul>
<li><a href=cgtsl.f.html> cgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=cptsl.f.html> cptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=dgtsl.f.html> dgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=dptsl.f.html> dptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
<li><a href=genbun.f.html> genbun </a>
<pre>
Solve by a cyclic reduction algorithm the linear system
of equations that results from a finite difference
approximation to certain 2-d elliptic PDE's on a centered
grid .
</pre>
<li><a href=poistg.f.html> poistg </a>
<pre>
Solve a block tridiagonal system of linear equations
that results from a staggered grid finite difference
approximation to 2-D elliptic PDE's.
</pre>
<li><a href=sgtsl.f.html> sgtsl </a>
<pre>
Solve a tridiagonal linear system.
</pre>
<li><a href=sptsl.f.html> sptsl </a>
<pre>
Solve a positive definite tridiagonal linear system.
</pre>
</ul>
<h3> <a name="TRIDIAGONAL_LINEAR_SYSTEM"> TRIDIAGONAL LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=blktri.f.html> blktri </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cblktr.f.html> cblktr </a>
<pre>
Solve a block tridiagonal system of linear equations
(usually resulting from the discretization of separable
two-dimensional elliptic equations).
</pre>
<li><a href=cmgnbn.f.html> cmgnbn </a>
<pre>
Solve a complex block tridiagonal linear system of
equations by a cyclic reduction algorithm.
</pre>
</ul>
<h3> <a name="TRIGONOMETRIC"> TRIGONOMETRIC </a> </h3>
<ul>
<li><a href=cacos.f.html> cacos </a>
<pre>
Compute the complex arc cosine.
</pre>
<li><a href=casin.f.html> casin </a>
<pre>
Compute the complex arc sine.
</pre>
<li><a href=catan.f.html> catan </a>
<pre>
Compute the complex arc tangent.
</pre>
<li><a href=catan2.f.html> catan2 </a>
<pre>
Compute the complex arc tangent in the proper quadrant.
</pre>
<li><a href=ccot.f.html> ccot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=cosdg.f.html> cosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=cot.f.html> cot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=ctan.f.html> ctan </a>
<pre>
Compute the complex tangent.
</pre>
<li><a href=d9atn1.f.html> d9atn1 </a>
<pre>
Evaluate DATAN(X) from first order relative accuracy so
that DATAN(X) = X + X**3*D9ATN1(X).
</pre>
<li><a href=dcosdg.f.html> dcosdg </a>
<pre>
Compute the cosine of an argument in degrees.
</pre>
<li><a href=dcot.f.html> dcot </a>
<pre>
Compute the cotangent.
</pre>
<li><a href=dsindg.f.html> dsindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
<li><a href=r9atn1.f.html> r9atn1 </a>
<pre>
Evaluate ATAN(X) from first order relative accuracy so that
ATAN(X) = X + X**3*R9ATN1(X).
</pre>
<li><a href=sindg.f.html> sindg </a>
<pre>
Compute the sine of an argument in degrees.
</pre>
</ul>
<h3> <a name="TWO-POINT_BOUNDARY_VALUE_PROBLEM"> TWO-POINT BOUNDARY VALUE PROBLEM </a> </h3>
<ul>
<li><a href=bvsup.f.html> bvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
<li><a href=dbvsup.f.html> dbvsup </a>
<pre>
Solve a linear two-point boundary value problem using
superposition coupled with an orthonormalization procedure
and a variable-step integration scheme.
</pre>
</ul>
<h3> <a name="UNDERDETERMINED_LINEAR_SYSTEM"> UNDERDETERMINED LINEAR SYSTEM </a> </h3>
<ul>
<li><a href=dulsia.f.html> dulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
<li><a href=ulsia.f.html> ulsia </a>
<pre>
Solve an underdetermined linear system of equations by
performing an LQ factorization of the matrix using
Householder transformations.  Emphasis is put on detecting
possible rank deficiency.
</pre>
</ul>
<h3> <a name="UNDERDETERMINED_LINEAR_SYSTEMS"> UNDERDETERMINED LINEAR SYSTEMS </a> </h3>
<ul>
<li><a href=dglss.f.html> dglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the input matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
<li><a href=sglss.f.html> sglss </a>
<pre>
Solve a linear least squares problems by performing a QR
factorization of the matrix using Householder
transformations.  Emphasis is put on detecting possible
rank deficiency.
</pre>
</ul>
<h3> <a name="UNIFORM"> UNIFORM </a> </h3>
<ul>
<li><a href=rand.f.html> rand </a>
<pre>
Generate a uniformly distributed random number.
</pre>
<li><a href=runif.f.html> runif </a>
<pre>
Generate a uniformly distributed random number.
</pre>
</ul>
<h3> <a name="UNITARY"> UNITARY </a> </h3>
<ul>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
</ul>
<h3> <a name="UNPACK"> UNPACK </a> </h3>
<ul>
<li><a href=d9upak.f.html> d9upak </a>
<pre>
Unpack a floating point number X so that X = Y*2**N.
</pre>
<li><a href=r9upak.f.html> r9upak </a>
<pre>
Unpack a floating point number X so that X = Y*2**N.
</pre>
</ul>
<h3> <a name="UPDATE"> UPDATE </a> </h3>
<ul>
<li><a href=cchud.f.html> cchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=dchud.f.html> dchud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
<li><a href=schud.f.html> schud </a>
<pre>
Update an augmented Cholesky decomposition of the
triangular part of an augmented QR decomposition.
</pre>
</ul>
<h3> <a name="UTILITY_ROUTINE"> UTILITY ROUTINE </a> </h3>
<ul>
<li><a href=dpchcm.f.html> dpchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
<li><a href=pchcm.f.html> pchcm </a>
<pre>
Check a cubic Hermite function for monotonicity.
</pre>
</ul>
<h3> <a name="VECTOR"> VECTOR </a> </h3>
<ul>
<li><a href=caxpy.f.html> caxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=ccopy.f.html> ccopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=cdcdot.f.html> cdcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=cdotc.f.html> cdotc </a>
<pre>
Dot product of two complex vectors using the complex
conjugate of the first vector.
</pre>
<li><a href=cdotu.f.html> cdotu </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=crotg.f.html> crotg </a>
<pre>
Construct a Givens transformation.
</pre>
<li><a href=cscal.f.html> cscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=csrot.f.html> csrot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=csscal.f.html> csscal </a>
<pre>
Scale a complex vector.
</pre>
<li><a href=cswap.f.html> cswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=daxpy.f.html> daxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=dcdot.f.html> dcdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dcopy.f.html> dcopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=dcopym.f.html> dcopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
<li><a href=ddot.f.html> ddot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=dnrm2.f.html> dnrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=drot.f.html> drot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=drotg.f.html> drotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=drotm.f.html> drotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=drotmg.f.html> drotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=dscal.f.html> dscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=dsdot.f.html> dsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation and result.
</pre>
<li><a href=dswap.f.html> dswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=icamax.f.html> icamax </a>
<pre>
Find the smallest index of the component of a complex
vector having the maximum sum of magnitudes of real
and imaginary parts.
</pre>
<li><a href=icopy.f.html> icopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=idamax.f.html> idamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=isamax.f.html> isamax </a>
<pre>
Find the smallest index of that component of a vector
having the maximum magnitude.
</pre>
<li><a href=iswap.f.html> iswap </a>
<pre>
Interchange two vectors.
</pre>
<li><a href=saxpy.f.html> saxpy </a>
<pre>
Compute a constant times a vector plus a vector.
</pre>
<li><a href=scnrm2.f.html> scnrm2 </a>
<pre>
Compute the unitary norm of a complex vector.
</pre>
<li><a href=scopy.f.html> scopy </a>
<pre>
Copy a vector.
</pre>
<li><a href=scopym.f.html> scopym </a>
<pre>
Copy the negative of a vector to a vector.
</pre>
<li><a href=sdot.f.html> sdot </a>
<pre>
Compute the inner product of two vectors.
</pre>
<li><a href=sdsdot.f.html> sdsdot </a>
<pre>
Compute the inner product of two vectors with extended
precision accumulation.
</pre>
<li><a href=snrm2.f.html> snrm2 </a>
<pre>
Compute the Euclidean length (L2 norm) of a vector.
</pre>
<li><a href=srot.f.html> srot </a>
<pre>
Apply a plane Givens rotation.
</pre>
<li><a href=srotg.f.html> srotg </a>
<pre>
Construct a plane Givens rotation.
</pre>
<li><a href=srotm.f.html> srotm </a>
<pre>
Apply a modified Givens transformation.
</pre>
<li><a href=srotmg.f.html> srotmg </a>
<pre>
Construct a modified Givens transformation.
</pre>
<li><a href=sscal.f.html> sscal </a>
<pre>
Multiply a vector by a constant.
</pre>
<li><a href=sswap.f.html> sswap </a>
<pre>
Interchange two vectors.
</pre>
</ul>
<h3> <a name="VECTOR_ADDITION_COEFFICIENTS"> VECTOR ADDITION COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="VERSION"> VERSION </a> </h3>
<ul>
<li><a href=aaaaaa.f.html> aaaaaa </a>
<pre>
SLATEC Common Mathematical Library disclaimer and version.
</pre>
</ul>
<h3> <a name="WEBER'S_FUNCTION"> WEBER'S FUNCTION </a> </h3>
<ul>
<li><a href=cbesy.f.html> cbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesy.f.html> zbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="WEIGHT_FUNCTION"> WEIGHT FUNCTION </a> </h3>
<ul>
<li><a href=dqwgtc.f.html> dqwgtc </a>
<pre>
This function subprogram is used together with the
routine DQAWC and defines the WEIGHT function.
</pre>
<li><a href=dqwgts.f.html> dqwgts </a>
<pre>
This function subprogram is used together with the
routine DQAWS and defines the WEIGHT function.
</pre>
<li><a href=qwgtc.f.html> qwgtc </a>
<pre>
This function subprogram is used together with the
routine QAWC and defines the WEIGHT function.
</pre>
<li><a href=qwgts.f.html> qwgts </a>
<pre>
This function subprogram is used together with the
routine QAWS and defines the WEIGHT function.
</pre>
</ul>
<h3> <a name="WEIGHTED_LEAST_SQUARES"> WEIGHTED LEAST SQUARES </a> </h3>
<ul>
<li><a href=dfc.f.html> dfc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
<li><a href=efc.f.html> efc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
</pre>
<li><a href=fc.f.html> fc </a>
<pre>
Fit a piecewise polynomial curve to discrete data.
The piecewise polynomials are represented as B-splines.
The fitting is done in a weighted least squares sense.
Equality and inequality constraints can be imposed on the
fitted curve.
</pre>
</ul>
<h3> <a name="WIGNER_COEFFICIENTS"> WIGNER COEFFICIENTS </a> </h3>
<ul>
<li><a href=drc3jj.f.html> drc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=drc3jm.f.html> drc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=drc6j.f.html> drc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jj.f.html> rc3jj </a>
<pre>
Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
                               (-M2-M3 M2 M3)
for all allowed values of L1, the other parameters
being held fixed.
</pre>
<li><a href=rc3jm.f.html> rc3jm </a>
<pre>
Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
                               (M1 M2 -M1-M2)
for all allowed values of M2, the other parameters
being held fixed.
</pre>
<li><a href=rc6j.f.html> rc6j </a>
<pre>
Evaluate the 6j symbol h(L1) = {L1 L2 L3}
                               {L4 L5 L6}
for all allowed values of L1, the other parameters
being held fixed.
</pre>
</ul>
<h3> <a name="WORKSPACE_CHECKING"> WORKSPACE CHECKING </a> </h3>
<ul>
<li><a href=dchkw.f.html> dchkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
<li><a href=schkw.f.html> schkw </a>
<pre>
SLAP WORK/IWORK Array Bounds Checker.
This routine checks the work array lengths and interfaces
to the SLATEC error handler if a problem is found.
</pre>
</ul>
<h3> <a name="XERMSG"> XERMSG </a> </h3>
<ul>
<li><a href=fdump.f.html> fdump </a>
<pre>
Symbolic dump (should be locally written).
</pre>
</ul>
<h3> <a name="XERROR"> XERROR </a> </h3>
<ul>
<li><a href=j4save.f.html> j4save </a>
<pre>
Save or recall global variables needed by error
handling routines.
</pre>
<li><a href=numxer.f.html> numxer </a>
<pre>
Return the most recent error number.
</pre>
<li><a href=xerclr.f.html> xerclr </a>
<pre>
Reset current error number to zero.
</pre>
<li><a href=xercnt.f.html> xercnt </a>
<pre>
Allow user control over handling of errors.
</pre>
<li><a href=xerdmp.f.html> xerdmp </a>
<pre>
Print the error tables and then clear them.
</pre>
<li><a href=xerhlt.f.html> xerhlt </a>
<pre>
Abort program execution and print error message.
</pre>
<li><a href=xermax.f.html> xermax </a>
<pre>
Set maximum number of times any error message is to be
printed.
</pre>
<li><a href=xermsg.f.html> xermsg </a>
<pre>
Process error messages for SLATEC and other libraries.
</pre>
<li><a href=xerprn.f.html> xerprn </a>
<pre>
Print error messages processed by XERMSG.
</pre>
<li><a href=xersve.f.html> xersve </a>
<pre>
Record that an error has occurred.
</pre>
<li><a href=xgetf.f.html> xgetf </a>
<pre>
Return the current value of the error control flag.
</pre>
<li><a href=xgetua.f.html> xgetua </a>
<pre>
Return unit number(s) to which error messages are being
sent.
</pre>
<li><a href=xgetun.f.html> xgetun </a>
<pre>
Return the (first) output file to which error messages
are being sent.
</pre>
<li><a href=xsetf.f.html> xsetf </a>
<pre>
Set the error control flag.
</pre>
<li><a href=xsetua.f.html> xsetua </a>
<pre>
Set logical unit numbers (up to 5) to which error
messages are to be sent.
</pre>
<li><a href=xsetun.f.html> xsetun </a>
<pre>
Set output file to which error messages are to be sent.
</pre>
</ul>
<h3> <a name="Y_BESSEL_FUNCTION"> Y BESSEL FUNCTION </a> </h3>
<ul>
<li><a href=besy.f.html> besy </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions Y/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
<li><a href=dbesy.f.html> dbesy </a>
<pre>
Implement forward recursion on the three term recursion
relation for a sequence of non-negative order Bessel
functions Y/SUB(FNU+I-1)/(X), I=1,...,N for real, positive
X and non-negative orders FNU.
</pre>
</ul>
<h3> <a name="Y_BESSEL_FUNCTIONS"> Y BESSEL FUNCTIONS </a> </h3>
<ul>
<li><a href=cbesy.f.html> cbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
<li><a href=zbesy.f.html> zbesy </a>
<pre>
Compute a sequence of the Bessel functions Y(a,z) for
complex argument z and real nonnegative orders a=b,b+1,
b+2,... where b>0.  A scaling option is available to
help avoid overflow.
</pre>
</ul>
<h3> <a name="ZEROS"> ZEROS </a> </h3>
<ul>
<li><a href=dfzero.f.html> dfzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=dnsq.f.html> dnsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=dnsqe.f.html> dnsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
<li><a href=fzero.f.html> fzero </a>
<pre>
Search for a zero of a function F(X) in a given interval
(B,C).  It is designed primarily for problems where F(B)
and F(C) have opposite signs.
</pre>
<li><a href=snsq.f.html> snsq </a>
<pre>
Find a zero of a system of a N nonlinear functions in N
variables by a modification of the Powell hybrid method.
</pre>
<li><a href=snsqe.f.html> snsqe </a>
<pre>
An easy-to-use code to find a zero of a system of N
nonlinear functions in N variables by a modification of
the Powell hybrid method.
</pre>
</ul>
